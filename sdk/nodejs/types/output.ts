// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ServiceACLEntriesv1Entry {
    /**
     * A personal freeform descriptive note
     */
    comment?: string;
    id: string;
    /**
     * An IP address that is the focus for the ACL
     */
    ip: string;
    /**
     * A boolean that will negate the match if true
     */
    negated?: boolean;
    /**
     * An optional subnet mask applied to the IP address
     */
    subnet?: string;
}

export interface Servicev1Acl {
    /**
     * The ID of the ACL.
     */
    aclId: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
}

export interface Servicev1Backend {
    /**
     * The SFTP address to stream logs to.
     */
    address: string;
    /**
     * Denotes if this Backend should be
     * included in the pool of backends that requests are load balanced against.
     * Default `true`.
     */
    autoLoadbalance?: boolean;
    /**
     * How long to wait between bytes in milliseconds. Default `10000`.
     */
    betweenBytesTimeout?: number;
    /**
     * How long to wait for a timeout in milliseconds.
     * Default `1000`
     */
    connectTimeout?: number;
    /**
     * Number of errors to allow before the Backend is marked as down. Default `0`.
     */
    errorThreshold?: number;
    /**
     * How long to wait for the first bytes in milliseconds. Default `15000`.
     */
    firstByteTimeout?: number;
    /**
     * Name of a defined `healthcheck` to assign to this backend.
     */
    healthcheck?: string;
    /**
     * Maximum number of connections for this Backend.
     * Default `200`.
     */
    maxConn?: number;
    /**
     * Maximum allowed TLS version on SSL connections to this backend.
     */
    maxTlsVersion?: string;
    /**
     * Minimum allowed TLS version on SSL connections to this backend.
     */
    minTlsVersion?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The hostname to override the Host header.
     */
    overrideHost?: string;
    /**
     * The port the SFTP service listens on. (Default: `22`).
     */
    port?: number;
    /**
     * Name of already defined `condition` to be checked during the request phase. If the condition passes then this object will be delivered. This `condition` must be of type `REQUEST`.
     */
    requestCondition?: string;
    /**
     * Selected POP to serve as a "shield" for backends. Valid values for `shield` are included in the [`GET /datacenters`](https://developer.fastly.com/reference/api/utils/datacenter/) API response.
     */
    shield?: string;
    /**
     * CA certificate attached to origin.
     */
    sslCaCert?: string;
    /**
     * Overrides ssl_hostname, but only for cert verification. Does not affect SNI at all.
     */
    sslCertHostname?: string;
    /**
     * Be strict about checking SSL certs. Default `true`.
     */
    sslCheckCert?: boolean;
    /**
     * Comma separated list of OpenSSL Ciphers to try when negotiating to the backend.
     */
    sslCiphers?: string;
    /**
     * Client certificate attached to origin. Used when connecting to the backend.
     */
    sslClientCert?: string;
    /**
     * Client key attached to origin. Used when connecting to the backend.
     */
    sslClientKey?: string;
    /**
     * Used for both SNI during the TLS handshake and to validate the cert.
     *
     * @deprecated Use ssl_cert_hostname and ssl_sni_hostname instead.
     */
    sslHostname?: string;
    /**
     * Overrides ssl_hostname, but only for SNI in the handshake. Does not affect cert validation at all.
     */
    sslSniHostname?: string;
    /**
     * Whether or not to use SSL to reach the backend. Default `false`.
     */
    useSsl?: boolean;
    /**
     * The [portion of traffic](https://docs.fastly.com/en/guides/load-balancing-configuration#how-weight-affects-load-balancing) to send to this Backend. Each Backend receives `weight / total` of the traffic. Default `100`.
     */
    weight?: number;
}

export interface Servicev1Bigquerylogging {
    /**
     * The Honeycomb Dataset you want to log to.
     */
    dataset: string;
    /**
     * The email for the service account with write access to your BigQuery dataset. If not provided, this will be pulled from a `FASTLY_BQ_EMAIL` environment variable.
     */
    email?: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The ID of your Google Cloud Platform project.
     */
    projectId: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * Your DigitalOcean Spaces account secret key.
     */
    secretKey?: string;
    /**
     * The ID of your BigQuery table.
     */
    table: string;
    /**
     * Big query table name suffix template. If set will be interpreted as a strftime compatible string and used as the [Template Suffix for your table](https://cloud.google.com/bigquery/streaming-data-into-bigquery#template-tables).
     */
    template?: string;
}

export interface Servicev1Blobstoragelogging {
    /**
     * The unique Azure Blob Storage namespace in which your data objects are stored.
     */
    accountName: string;
    /**
     * The name of the Azure Blob Storage container in which to store logs.
     */
    container: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * What level of GZIP encoding to have when dumping logs (default 0, no compression).
     */
    gzipLevel?: number;
    /**
     * How the message should be formatted. One of: classic (default), loggly, logplex or blank.
     */
    messageType?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The path to upload logs to.
     */
    path?: string;
    /**
     * How frequently log files are finalized so they can be available for reading (in seconds, default 3600).
     */
    period?: number;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The PGP public key that Fastly will use to encrypt your log files before writing them to disk.
     */
    publicKey?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The Azure shared access signature providing write access to the blob service objects. Be sure to update your token before it expires or the logging functionality will not work.
     */
    sasToken: string;
    /**
     * The strftime specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`).
     */
    timestampFormat?: string;
}

export interface Servicev1CacheSetting {
    /**
     * Allows you to terminate request handling and immediately
     * perform an action. When set it can be `lookup` or `pass` (Ignore the cache completely).
     */
    action?: string;
    /**
     * Name of already defined `condition` to check after we have retrieved an object. If the condition passes then deliver this Request Object instead. This `condition` must be of type `CACHE`. For detailed information about Conditionals,
     * see [Fastly's Documentation on Conditionals][fastly-conditionals].
     */
    cacheCondition?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Max "Time To Live" for stale (unreachable) objects.
     */
    staleTtl?: number;
    /**
     * The Time-To-Live (TTL) for the object.
     */
    ttl?: number;
}

export interface Servicev1Condition {
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Priority determines the ordering for multiple snippets. Lower numbers execute first.  Defaults to `100`.
     */
    priority?: number;
    /**
     * The statement used to determine if the condition is met.
     */
    statement: string;
    /**
     * The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`).
     */
    type: string;
}

export interface Servicev1Dictionary {
    /**
     * The ID of the dictionary.
     */
    dictionaryId: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * If `true`, the dictionary is a private dictionary, and items are not readable in the UI or
     * via API. Default is `false`. It is important to note that changing this attribute will delete and recreate the
     * dictionary, discard the current items in the dictionary. Using a write-only/private dictionary should only be done if
     * the items are managed outside of the provider.
     */
    writeOnly?: boolean;
}

export interface Servicev1Director {
    /**
     * Names of defined backends to map the director to. Example: `[ "origin1", "origin2" ]`
     */
    backends: string[];
    /**
     * Load balancing weight for the backends. Default `100`.
     */
    capacity?: number;
    /**
     * An optional comment about the Director.
     */
    comment?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Percentage of capacity that needs to be up for the director itself to be considered up. Default `75`.
     */
    quorum?: number;
    /**
     * How many backends to search if it fails. Default `5`.
     */
    retries?: number;
    /**
     * Selected POP to serve as a "shield" for backends. Valid values for `shield` are included in the [`GET /datacenters`](https://developer.fastly.com/reference/api/utils/datacenter/) API response.
     */
    shield?: string;
    /**
     * The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`).
     */
    type?: number;
}

export interface Servicev1Domain {
    /**
     * An optional comment about the Director.
     */
    comment?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
}

export interface Servicev1Dynamicsnippet {
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Priority determines the ordering for multiple snippets. Lower numbers execute first.  Defaults to `100`.
     */
    priority?: number;
    /**
     * The ID of the dynamic snippet.
     */
    snippetId: string;
    /**
     * The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`).
     */
    type: string;
}

export interface Servicev1Gcslogging {
    /**
     * The name of your Cloud Files container.
     */
    bucketName: string;
    /**
     * The email for the service account with write access to your BigQuery dataset. If not provided, this will be pulled from a `FASTLY_BQ_EMAIL` environment variable.
     */
    email?: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * What level of GZIP encoding to have when dumping logs (default 0, no compression).
     */
    gzipLevel?: number;
    /**
     * How the message should be formatted. One of: classic (default), loggly, logplex or blank.
     */
    messageType?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The path to upload logs to.
     */
    path?: string;
    /**
     * How frequently log files are finalized so they can be available for reading (in seconds, default 3600).
     */
    period?: number;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * Your DigitalOcean Spaces account secret key.
     */
    secretKey?: string;
    /**
     * The strftime specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`).
     */
    timestampFormat?: string;
}

export interface Servicev1Gzip {
    /**
     * Name of already defined `condition` to check after we have retrieved an object. If the condition passes then deliver this Request Object instead. This `condition` must be of type `CACHE`. For detailed information about Conditionals,
     * see [Fastly's Documentation on Conditionals][fastly-conditionals].
     */
    cacheCondition?: string;
    /**
     * The content-type for each type of content you wish to
     * have dynamically gzip'ed. Example: `["text/html", "text/css"]`.
     */
    contentTypes?: string[];
    /**
     * File extensions for each file type to dynamically
     * gzip. Example: `["css", "js"]`.
     */
    extensions?: string[];
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
}

export interface Servicev1Header {
    /**
     * Allows you to terminate request handling and immediately
     * perform an action. When set it can be `lookup` or `pass` (Ignore the cache completely).
     */
    action: string;
    /**
     * Name of already defined `condition` to check after we have retrieved an object. If the condition passes then deliver this Request Object instead. This `condition` must be of type `CACHE`. For detailed information about Conditionals,
     * see [Fastly's Documentation on Conditionals][fastly-conditionals].
     */
    cacheCondition?: string;
    /**
     * The name of the header that is going to be affected by the Action.
     */
    destination: string;
    /**
     * Do not add the header if it is already present. (Only applies to the `set` action.). Default `false`.
     */
    ignoreIfSet?: boolean;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Priority determines the ordering for multiple snippets. Lower numbers execute first.  Defaults to `100`.
     */
    priority?: number;
    /**
     * Regular expression to use (Only applies to the `regex` and `regexRepeat` actions.)
     */
    regex: string;
    /**
     * Name of already defined `condition` to be checked during the request phase. If the condition passes then this object will be delivered. This `condition` must be of type `REQUEST`.
     */
    requestCondition?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * Variable to be used as a source for the header
     * content. (Does not apply to the `delete` action.)
     */
    source: string;
    /**
     * Value to substitute in place of regular expression. (Only applies to the `regex` and `regexRepeat` actions.)
     */
    substitution: string;
    /**
     * The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`).
     */
    type: string;
}

export interface Servicev1Healthcheck {
    /**
     * How often to run the Healthcheck in milliseconds. Default `5000`.
     */
    checkInterval?: number;
    /**
     * The status code expected from the host. Default `200`.
     */
    expectedResponse?: number;
    /**
     * The Host header to send for this Healthcheck.
     */
    host: string;
    /**
     * Whether to use version 1.0 or 1.1 HTTP. Default `1.1`.
     */
    httpVersion?: string;
    /**
     * When loading a config, the initial number of probes to be seen as OK. Default `2`.
     */
    initial?: number;
    /**
     * HTTP method used for request. Can be either `POST` or `PUT`. Default `POST`.
     */
    method?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The path to upload logs to.
     */
    path: string;
    /**
     * How many Healthchecks must succeed to be considered healthy. Default `3`.
     */
    threshold?: number;
    /**
     * Timeout in milliseconds. Default `500`.
     */
    timeout?: number;
    /**
     * The number of most recent Healthcheck queries to keep for this Healthcheck. Default `5`.
     */
    window?: number;
}

export interface Servicev1Httpslogging {
    /**
     * The MIME type of the content.
     */
    contentType?: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * Custom header sent with the request.
     */
    headerName?: string;
    /**
     * Value of the custom header sent with the request.
     */
    headerValue?: string;
    /**
     * Formats log entries as JSON. Can be either disabled (`0`), array of json (`1`), or newline delimited json (`2`).
     */
    jsonFormat?: string;
    /**
     * How the message should be formatted. One of: classic (default), loggly, logplex or blank.
     */
    messageType?: string;
    /**
     * HTTP method used for request. Can be either `POST` or `PUT`. Default `POST`.
     */
    method?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The maximum number of bytes sent in one request. Defaults to `0` for unbounded.
     */
    requestMaxBytes?: number;
    /**
     * The maximum number of logs sent in one request. Defaults to `0` for unbounded.
     */
    requestMaxEntries?: number;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * A secure certificate to authenticate the server with. Must be in PEM format.
     */
    tlsCaCert?: string;
    /**
     * The client certificate used to make authenticated requests. Must be in PEM format.
     */
    tlsClientCert?: string;
    /**
     * The client private key used to make authenticated requests. Must be in PEM format.
     */
    tlsClientKey?: string;
    /**
     * The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN).
     */
    tlsHostname?: string;
    /**
     * Your OpenStack auth url.
     */
    url: string;
}

export interface Servicev1Logentry {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The port the SFTP service listens on. (Default: `22`).
     */
    port?: number;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The data authentication token associated with this endpoint.
     */
    token: string;
    /**
     * Whether to use TLS for secure logging. Can be either true or false.
     */
    useTls?: boolean;
}

export interface Servicev1LoggingCloudfile {
    /**
     * Your Cloud File account access key.
     */
    accessKey: string;
    /**
     * The name of your Cloud Files container.
     */
    bucketName: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * What level of GZIP encoding to have when dumping logs (default 0, no compression).
     */
    gzipLevel?: number;
    /**
     * How the message should be formatted. One of: classic (default), loggly, logplex or blank.
     */
    messageType?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The path to upload logs to.
     */
    path?: string;
    /**
     * How frequently log files are finalized so they can be available for reading (in seconds, default 3600).
     */
    period?: number;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The PGP public key that Fastly will use to encrypt your log files before writing them to disk.
     */
    publicKey?: string;
    /**
     * The region to stream logs to. One of: DFW (Dallas), ORD (Chicago), IAD (Northern Virginia), LON (London), SYD (Sydney), HKG (Hong Kong).
     */
    region?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The strftime specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`).
     */
    timestampFormat?: string;
    /**
     * The username for your Cloud Files account.
     */
    user: string;
}

export interface Servicev1LoggingDatadog {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The region to stream logs to. One of: DFW (Dallas), ORD (Chicago), IAD (Northern Virginia), LON (London), SYD (Sydney), HKG (Hong Kong).
     */
    region?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The data authentication token associated with this endpoint.
     */
    token: string;
}

export interface Servicev1LoggingDigitalocean {
    /**
     * Your Cloud File account access key.
     */
    accessKey: string;
    /**
     * The name of your Cloud Files container.
     */
    bucketName: string;
    /**
     * The domain of the DigitalOcean Spaces endpoint (default "nyc3.digitaloceanspaces.com").
     */
    domain?: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * What level of GZIP encoding to have when dumping logs (default 0, no compression).
     */
    gzipLevel?: number;
    /**
     * How the message should be formatted. One of: classic (default), loggly, logplex or blank.
     */
    messageType?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The path to upload logs to.
     */
    path?: string;
    /**
     * How frequently log files are finalized so they can be available for reading (in seconds, default 3600).
     */
    period?: number;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The PGP public key that Fastly will use to encrypt your log files before writing them to disk.
     */
    publicKey?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * Your DigitalOcean Spaces account secret key.
     */
    secretKey: string;
    /**
     * The strftime specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`).
     */
    timestampFormat?: string;
}

export interface Servicev1LoggingElasticsearch {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * The name of the Elasticsearch index to send documents (logs) to.
     */
    index: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The password for the server. If both `password` and `secretKey` are passed, `secretKey` will be preferred.
     */
    password?: string;
    /**
     * The ID of the Elasticsearch ingest pipeline to apply pre-process transformations to before indexing.
     */
    pipeline?: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The maximum number of bytes sent in one request. Defaults to `0` for unbounded.
     */
    requestMaxBytes?: number;
    /**
     * The maximum number of logs sent in one request. Defaults to `0` for unbounded.
     */
    requestMaxEntries?: number;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * A secure certificate to authenticate the server with. Must be in PEM format.
     */
    tlsCaCert?: string;
    /**
     * The client certificate used to make authenticated requests. Must be in PEM format.
     */
    tlsClientCert?: string;
    /**
     * The client private key used to make authenticated requests. Must be in PEM format.
     */
    tlsClientKey?: string;
    /**
     * The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN).
     */
    tlsHostname?: string;
    /**
     * Your OpenStack auth url.
     */
    url: string;
    /**
     * The username for your Cloud Files account.
     */
    user?: string;
}

export interface Servicev1LoggingFtp {
    /**
     * The SFTP address to stream logs to.
     */
    address: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * What level of GZIP encoding to have when dumping logs (default 0, no compression).
     */
    gzipLevel?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The password for the server. If both `password` and `secretKey` are passed, `secretKey` will be preferred.
     */
    password: string;
    /**
     * The path to upload logs to.
     */
    path: string;
    /**
     * How frequently log files are finalized so they can be available for reading (in seconds, default 3600).
     */
    period?: number;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The port the SFTP service listens on. (Default: `22`).
     */
    port?: number;
    /**
     * The PGP public key that Fastly will use to encrypt your log files before writing them to disk.
     */
    publicKey?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The strftime specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`).
     */
    timestampFormat?: string;
    /**
     * The username for your Cloud Files account.
     */
    user: string;
}

export interface Servicev1LoggingGooglepubsub {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The ID of your Google Cloud Platform project.
     */
    projectId: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * Your DigitalOcean Spaces account secret key.
     */
    secretKey: string;
    /**
     * The Kafka topic to send logs to.
     */
    topic: string;
    /**
     * The username for your Cloud Files account.
     */
    user: string;
}

export interface Servicev1LoggingHeroku {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The data authentication token associated with this endpoint.
     */
    token: string;
    /**
     * Your OpenStack auth url.
     */
    url: string;
}

export interface Servicev1LoggingHoneycomb {
    /**
     * The Honeycomb Dataset you want to log to.
     */
    dataset: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The data authentication token associated with this endpoint.
     */
    token: string;
}

export interface Servicev1LoggingKafka {
    /**
     * A comma-separated list of IP addresses or hostnames of Kafka brokers.
     */
    brokers: string;
    /**
     * The codec used for compression of your logs. One of: gzip, snappy, lz4.
     */
    compressionCodec?: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The Number of acknowledgements a leader must receive before a write is considered successful. One of: 1 (default) One server needs to respond. 0 No servers need to respond. -1	Wait for all in-sync replicas to respond.
     */
    requiredAcks?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * A secure certificate to authenticate the server with. Must be in PEM format.
     */
    tlsCaCert?: string;
    /**
     * The client certificate used to make authenticated requests. Must be in PEM format.
     */
    tlsClientCert?: string;
    /**
     * The client private key used to make authenticated requests. Must be in PEM format.
     */
    tlsClientKey?: string;
    /**
     * The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN).
     */
    tlsHostname?: string;
    /**
     * The Kafka topic to send logs to.
     */
    topic: string;
    /**
     * Whether to use TLS for secure logging. Can be either true or false.
     */
    useTls?: boolean;
}

export interface Servicev1LoggingLoggly {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The data authentication token associated with this endpoint.
     */
    token: string;
}

export interface Servicev1LoggingLogshuttle {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The data authentication token associated with this endpoint.
     */
    token: string;
    /**
     * Your OpenStack auth url.
     */
    url: string;
}

export interface Servicev1LoggingNewrelic {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The data authentication token associated with this endpoint.
     */
    token: string;
}

export interface Servicev1LoggingOpenstack {
    /**
     * Your Cloud File account access key.
     */
    accessKey: string;
    /**
     * The name of your Cloud Files container.
     */
    bucketName: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * What level of GZIP encoding to have when dumping logs (default 0, no compression).
     */
    gzipLevel?: number;
    /**
     * How the message should be formatted. One of: classic (default), loggly, logplex or blank.
     */
    messageType?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The path to upload logs to.
     */
    path?: string;
    /**
     * How frequently log files are finalized so they can be available for reading (in seconds, default 3600).
     */
    period?: number;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The PGP public key that Fastly will use to encrypt your log files before writing them to disk.
     */
    publicKey?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The strftime specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`).
     */
    timestampFormat?: string;
    /**
     * Your OpenStack auth url.
     */
    url: string;
    /**
     * The username for your Cloud Files account.
     */
    user: string;
}

export interface Servicev1LoggingScalyr {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The region to stream logs to. One of: DFW (Dallas), ORD (Chicago), IAD (Northern Virginia), LON (London), SYD (Sydney), HKG (Hong Kong).
     */
    region?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * The data authentication token associated with this endpoint.
     */
    token: string;
}

export interface Servicev1LoggingSftp {
    /**
     * The SFTP address to stream logs to.
     */
    address: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * What level of GZIP encoding to have when dumping logs (default 0, no compression).
     */
    gzipLevel?: number;
    /**
     * How the message should be formatted. One of: classic (default), loggly, logplex or blank.
     */
    messageType?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The password for the server. If both `password` and `secretKey` are passed, `secretKey` will be preferred.
     */
    password?: string;
    /**
     * The path to upload logs to.
     */
    path: string;
    /**
     * How frequently log files are finalized so they can be available for reading (in seconds, default 3600).
     */
    period?: number;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The port the SFTP service listens on. (Default: `22`).
     */
    port?: number;
    /**
     * The PGP public key that Fastly will use to encrypt your log files before writing them to disk.
     */
    publicKey?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * Your DigitalOcean Spaces account secret key.
     */
    secretKey?: string;
    /**
     * A list of host keys for all hosts we can connect to over SFTP.
     */
    sshKnownHosts: string;
    /**
     * The strftime specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`).
     */
    timestampFormat?: string;
    /**
     * The username for your Cloud Files account.
     */
    user: string;
}

export interface Servicev1Papertrail {
    /**
     * The SFTP address to stream logs to.
     */
    address: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The port the SFTP service listens on. (Default: `22`).
     */
    port: number;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
}

export interface Servicev1RequestSetting {
    /**
     * Allows you to terminate request handling and immediately
     * perform an action. When set it can be `lookup` or `pass` (Ignore the cache completely).
     */
    action?: string;
    /**
     * Disable collapsed forwarding, so you don't wait
     * for other objects to origin.
     */
    bypassBusyWait?: boolean;
    /**
     * Sets the host header.
     */
    defaultHost?: string;
    /**
     * Force a cache miss for the request. If specified,
     * can be `true` or `false`.
     */
    forceMiss?: boolean;
    /**
     * Forces the request to use SSL (Redirects a non-SSL request to SSL).
     */
    forceSsl?: boolean;
    /**
     * Injects Fastly-Geo-Country, Fastly-Geo-City, and
     * Fastly-Geo-Region into the request headers.
     */
    geoHeaders?: boolean;
    /**
     * Comma separated list of varnish request object fields
     * that should be in the hash key.
     */
    hashKeys?: string;
    /**
     * How old an object is allowed to be to serve
     * `stale-if-error` or `stale-while-revalidate`, in seconds.
     */
    maxStaleAge?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Name of already defined `condition` to be checked during the request phase. If the condition passes then this object will be delivered. This `condition` must be of type `REQUEST`.
     */
    requestCondition?: string;
    /**
     * Injects the X-Timer info into the request for
     * viewing origin fetch durations.
     */
    timerSupport?: boolean;
    /**
     * X-Forwarded-For, should be `clear`, `leave`, `append`,
     * `appendAll`, or `overwrite`. Default `append`.
     */
    xff?: string;
}

export interface Servicev1ResponseObject {
    /**
     * Name of already defined `condition` to check after we have retrieved an object. If the condition passes then deliver this Request Object instead. This `condition` must be of type `CACHE`. For detailed information about Conditionals,
     * see [Fastly's Documentation on Conditionals][fastly-conditionals].
     */
    cacheCondition?: string;
    /**
     * The custom VCL code to upload.
     */
    content?: string;
    /**
     * The MIME type of the content.
     */
    contentType?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Name of already defined `condition` to be checked during the request phase. If the condition passes then this object will be delivered. This `condition` must be of type `REQUEST`.
     */
    requestCondition?: string;
    /**
     * The HTTP Response. Default `Ok`.
     */
    response?: string;
    /**
     * The HTTP Status Code. Default `200`.
     */
    status?: number;
}

export interface Servicev1S3logging {
    /**
     * The name of your Cloud Files container.
     */
    bucketName: string;
    /**
     * The domain of the DigitalOcean Spaces endpoint (default "nyc3.digitaloceanspaces.com").
     */
    domain?: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * What level of GZIP encoding to have when dumping logs (default 0, no compression).
     */
    gzipLevel?: number;
    /**
     * How the message should be formatted. One of: classic (default), loggly, logplex or blank.
     */
    messageType?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * The path to upload logs to.
     */
    path?: string;
    /**
     * How frequently log files are finalized so they can be available for reading (in seconds, default 3600).
     */
    period?: number;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The PGP public key that Fastly will use to encrypt your log files before writing them to disk.
     */
    publicKey?: string;
    /**
     * The S3 redundancy level. Should be formatted; one of: `standard`, `reducedRedundancy` or null. Default `null`.
     */
    redundancy?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * AWS Access Key of an account with the required
     * permissions to post logs. It is **strongly** recommended you create a separate
     * IAM user with permissions to only operate on this Bucket. This key will be
     * not be encrypted. You can provide this key via an environment variable, `FASTLY_S3_ACCESS_KEY`.
     */
    s3AccessKey?: string;
    /**
     * AWS Secret Key of an account with the required
     * permissions to post logs. It is **strongly** recommended you create a separate
     * IAM user with permissions to only operate on this Bucket. This secret will be
     * not be encrypted. You can provide this secret via an environment variable, `FASTLY_S3_SECRET_KEY`.
     */
    s3SecretKey?: string;
    serverSideEncryption?: string;
    serverSideEncryptionKmsKeyId?: string;
    /**
     * The strftime specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`).
     */
    timestampFormat?: string;
}

export interface Servicev1Snippet {
    /**
     * The custom VCL code to upload.
     */
    content: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Priority determines the ordering for multiple snippets. Lower numbers execute first.  Defaults to `100`.
     */
    priority?: number;
    /**
     * The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`).
     */
    type: string;
}

export interface Servicev1Splunk {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * A secure certificate to authenticate the server with. Must be in PEM format.
     */
    tlsCaCert?: string;
    /**
     * The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN).
     */
    tlsHostname?: string;
    /**
     * The data authentication token associated with this endpoint.
     */
    token: string;
    /**
     * Your OpenStack auth url.
     */
    url: string;
}

export interface Servicev1Sumologic {
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * How the message should be formatted. One of: classic (default), loggly, logplex or blank.
     */
    messageType?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * Your OpenStack auth url.
     */
    url: string;
}

export interface Servicev1Syslog {
    /**
     * The SFTP address to stream logs to.
     */
    address: string;
    /**
     * Apache style log formatting.
     */
    format?: string;
    /**
     * The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
     */
    formatVersion?: number;
    /**
     * How the message should be formatted. One of: classic (default), loggly, logplex or blank.
     */
    messageType?: string;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
    /**
     * Where in the generated VCL the logging call should be placed. Can be `none` or `wafDebug`.
     */
    placement?: string;
    /**
     * The port the SFTP service listens on. (Default: `22`).
     */
    port?: number;
    /**
     * The name of an existing condition in the configured endpoint, or leave blank to always execute.
     */
    responseCondition?: string;
    /**
     * A secure certificate to authenticate the server with. Must be in PEM format.
     */
    tlsCaCert?: string;
    /**
     * The client certificate used to make authenticated requests. Must be in PEM format.
     */
    tlsClientCert?: string;
    /**
     * The client private key used to make authenticated requests. Must be in PEM format.
     */
    tlsClientKey?: string;
    /**
     * The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN).
     */
    tlsHostname?: string;
    /**
     * The data authentication token associated with this endpoint.
     */
    token?: string;
    /**
     * Whether to use TLS for secure logging. Can be either true or false.
     */
    useTls?: boolean;
}

export interface Servicev1Vcl {
    /**
     * The custom VCL code to upload.
     */
    content: string;
    /**
     * If `true`, use this block as the main configuration. If
     * `false`, use this block as an includable library. Only a single VCL block can be
     * marked as the main block. Default is `false`.
     */
    main?: boolean;
    /**
     * A unique name to identify this dictionary.
     */
    name: string;
}
