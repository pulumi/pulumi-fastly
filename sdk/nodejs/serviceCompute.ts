// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

/**
 * ## Import
 *
 * Fastly Services can be imported using their service ID, e.g.
 *
 * ```sh
 * $ pulumi import fastly:index/serviceCompute:ServiceCompute demo xxxxxxxxxxxxxxxxxxxx
 * ```
 *
 * By default, either the active version will be imported, or the latest version if no version is active.
 *
 * Alternatively, a specific version of the service can be selected by appending an `@` followed by the version number to the service ID, e.g.
 *
 * ```sh
 * $ pulumi import fastly:index/serviceCompute:ServiceCompute demo xxxxxxxxxxxxxxxxxxxx@2
 * ```
 */
export class ServiceCompute extends pulumi.CustomResource {
    /**
     * Get an existing ServiceCompute resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ServiceComputeState, opts?: pulumi.CustomResourceOptions): ServiceCompute {
        return new ServiceCompute(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'fastly:index/serviceCompute:ServiceCompute';

    /**
     * Returns true if the given object is an instance of ServiceCompute.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is ServiceCompute {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === ServiceCompute.__pulumiType;
    }

    /**
     * Conditionally prevents new service versions from being activated. The apply step will create a new draft version but will not activate it if this is set to `false`. Default `true`
     */
    declare public readonly activate: pulumi.Output<boolean | undefined>;
    /**
     * The currently active version of your Fastly Service
     */
    declare public /*out*/ readonly activeVersion: pulumi.Output<number>;
    declare public readonly backends: pulumi.Output<outputs.ServiceComputeBackend[] | undefined>;
    /**
     * The latest cloned version by the provider
     */
    declare public /*out*/ readonly clonedVersion: pulumi.Output<number>;
    declare public readonly comment: pulumi.Output<string | undefined>;
    declare public readonly dictionaries: pulumi.Output<outputs.ServiceComputeDictionary[] | undefined>;
    /**
     * A set of Domain names to serve as entry points for your Service
     */
    declare public readonly domains: pulumi.Output<outputs.ServiceComputeDomain[]>;
    /**
     * Services that are active cannot be destroyed. In order to destroy the Service, set `forceDestroy` to `true`. Default `false`
     */
    declare public readonly forceDestroy: pulumi.Output<boolean | undefined>;
    declare public /*out*/ readonly forceRefresh: pulumi.Output<boolean>;
    declare public readonly imageOptimizerDefaultSettings: pulumi.Output<outputs.ServiceComputeImageOptimizerDefaultSettings | undefined>;
    /**
     * Used internally by the provider to temporarily indicate if the service is being imported, and is reset to false once the import is finished
     */
    declare public /*out*/ readonly imported: pulumi.Output<boolean>;
    declare public readonly loggingBigqueries: pulumi.Output<outputs.ServiceComputeLoggingBigquery[] | undefined>;
    declare public readonly loggingBlobstorages: pulumi.Output<outputs.ServiceComputeLoggingBlobstorage[] | undefined>;
    declare public readonly loggingCloudfiles: pulumi.Output<outputs.ServiceComputeLoggingCloudfile[] | undefined>;
    declare public readonly loggingDatadogs: pulumi.Output<outputs.ServiceComputeLoggingDatadog[] | undefined>;
    declare public readonly loggingDigitaloceans: pulumi.Output<outputs.ServiceComputeLoggingDigitalocean[] | undefined>;
    declare public readonly loggingElasticsearches: pulumi.Output<outputs.ServiceComputeLoggingElasticsearch[] | undefined>;
    declare public readonly loggingFtps: pulumi.Output<outputs.ServiceComputeLoggingFtp[] | undefined>;
    declare public readonly loggingGcs: pulumi.Output<outputs.ServiceComputeLoggingGc[] | undefined>;
    declare public readonly loggingGooglepubsubs: pulumi.Output<outputs.ServiceComputeLoggingGooglepubsub[] | undefined>;
    declare public readonly loggingGrafanacloudlogs: pulumi.Output<outputs.ServiceComputeLoggingGrafanacloudlog[] | undefined>;
    declare public readonly loggingHeroku: pulumi.Output<outputs.ServiceComputeLoggingHeroku[] | undefined>;
    declare public readonly loggingHoneycombs: pulumi.Output<outputs.ServiceComputeLoggingHoneycomb[] | undefined>;
    declare public readonly loggingHttps: pulumi.Output<outputs.ServiceComputeLoggingHttp[] | undefined>;
    declare public readonly loggingKafkas: pulumi.Output<outputs.ServiceComputeLoggingKafka[] | undefined>;
    declare public readonly loggingKineses: pulumi.Output<outputs.ServiceComputeLoggingKinese[] | undefined>;
    declare public readonly loggingLogentries: pulumi.Output<outputs.ServiceComputeLoggingLogentry[] | undefined>;
    declare public readonly loggingLogglies: pulumi.Output<outputs.ServiceComputeLoggingLoggly[] | undefined>;
    declare public readonly loggingLogshuttles: pulumi.Output<outputs.ServiceComputeLoggingLogshuttle[] | undefined>;
    declare public readonly loggingNewrelics: pulumi.Output<outputs.ServiceComputeLoggingNewrelic[] | undefined>;
    declare public readonly loggingOpenstacks: pulumi.Output<outputs.ServiceComputeLoggingOpenstack[] | undefined>;
    declare public readonly loggingPapertrails: pulumi.Output<outputs.ServiceComputeLoggingPapertrail[] | undefined>;
    declare public readonly loggingS3s: pulumi.Output<outputs.ServiceComputeLoggingS3[] | undefined>;
    declare public readonly loggingScalyrs: pulumi.Output<outputs.ServiceComputeLoggingScalyr[] | undefined>;
    declare public readonly loggingSftps: pulumi.Output<outputs.ServiceComputeLoggingSftp[] | undefined>;
    declare public readonly loggingSplunks: pulumi.Output<outputs.ServiceComputeLoggingSplunk[] | undefined>;
    declare public readonly loggingSumologics: pulumi.Output<outputs.ServiceComputeLoggingSumologic[] | undefined>;
    declare public readonly loggingSyslogs: pulumi.Output<outputs.ServiceComputeLoggingSyslog[] | undefined>;
    /**
     * The unique name for the Service to create
     */
    declare public readonly name: pulumi.Output<string>;
    /**
     * The `package` block supports uploading or modifying Wasm packages for use in a Fastly Compute service (if omitted, ensure `activate = false` is set on `fastly.ServiceCompute` to avoid service validation errors). See Fastly's documentation on [Compute](https://developer.fastly.com/learning/compute/)
     */
    declare public readonly package: pulumi.Output<outputs.ServiceComputePackage | undefined>;
    declare public readonly productEnablement: pulumi.Output<outputs.ServiceComputeProductEnablement | undefined>;
    /**
     * A resource link represents a link between a shared resource (such as an KV Store or Config Store) and a service version.
     */
    declare public readonly resourceLinks: pulumi.Output<outputs.ServiceComputeResourceLink[] | undefined>;
    declare public readonly reuse: pulumi.Output<boolean | undefined>;
    /**
     * Conditionally enables new service versions to be staged. If `set` to true, all changes made by an `apply` step will be staged, even if `apply` did not create a new draft version. Default `false`
     */
    declare public readonly stage: pulumi.Output<boolean | undefined>;
    /**
     * The currently staged version of your Fastly Service
     */
    declare public /*out*/ readonly stagedVersion: pulumi.Output<number>;
    /**
     * Description field for the version
     */
    declare public readonly versionComment: pulumi.Output<string | undefined>;

    /**
     * Create a ServiceCompute resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ServiceComputeArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ServiceComputeArgs | ServiceComputeState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as ServiceComputeState | undefined;
            resourceInputs["activate"] = state?.activate;
            resourceInputs["activeVersion"] = state?.activeVersion;
            resourceInputs["backends"] = state?.backends;
            resourceInputs["clonedVersion"] = state?.clonedVersion;
            resourceInputs["comment"] = state?.comment;
            resourceInputs["dictionaries"] = state?.dictionaries;
            resourceInputs["domains"] = state?.domains;
            resourceInputs["forceDestroy"] = state?.forceDestroy;
            resourceInputs["forceRefresh"] = state?.forceRefresh;
            resourceInputs["imageOptimizerDefaultSettings"] = state?.imageOptimizerDefaultSettings;
            resourceInputs["imported"] = state?.imported;
            resourceInputs["loggingBigqueries"] = state?.loggingBigqueries;
            resourceInputs["loggingBlobstorages"] = state?.loggingBlobstorages;
            resourceInputs["loggingCloudfiles"] = state?.loggingCloudfiles;
            resourceInputs["loggingDatadogs"] = state?.loggingDatadogs;
            resourceInputs["loggingDigitaloceans"] = state?.loggingDigitaloceans;
            resourceInputs["loggingElasticsearches"] = state?.loggingElasticsearches;
            resourceInputs["loggingFtps"] = state?.loggingFtps;
            resourceInputs["loggingGcs"] = state?.loggingGcs;
            resourceInputs["loggingGooglepubsubs"] = state?.loggingGooglepubsubs;
            resourceInputs["loggingGrafanacloudlogs"] = state?.loggingGrafanacloudlogs;
            resourceInputs["loggingHeroku"] = state?.loggingHeroku;
            resourceInputs["loggingHoneycombs"] = state?.loggingHoneycombs;
            resourceInputs["loggingHttps"] = state?.loggingHttps;
            resourceInputs["loggingKafkas"] = state?.loggingKafkas;
            resourceInputs["loggingKineses"] = state?.loggingKineses;
            resourceInputs["loggingLogentries"] = state?.loggingLogentries;
            resourceInputs["loggingLogglies"] = state?.loggingLogglies;
            resourceInputs["loggingLogshuttles"] = state?.loggingLogshuttles;
            resourceInputs["loggingNewrelics"] = state?.loggingNewrelics;
            resourceInputs["loggingOpenstacks"] = state?.loggingOpenstacks;
            resourceInputs["loggingPapertrails"] = state?.loggingPapertrails;
            resourceInputs["loggingS3s"] = state?.loggingS3s;
            resourceInputs["loggingScalyrs"] = state?.loggingScalyrs;
            resourceInputs["loggingSftps"] = state?.loggingSftps;
            resourceInputs["loggingSplunks"] = state?.loggingSplunks;
            resourceInputs["loggingSumologics"] = state?.loggingSumologics;
            resourceInputs["loggingSyslogs"] = state?.loggingSyslogs;
            resourceInputs["name"] = state?.name;
            resourceInputs["package"] = state?.package;
            resourceInputs["productEnablement"] = state?.productEnablement;
            resourceInputs["resourceLinks"] = state?.resourceLinks;
            resourceInputs["reuse"] = state?.reuse;
            resourceInputs["stage"] = state?.stage;
            resourceInputs["stagedVersion"] = state?.stagedVersion;
            resourceInputs["versionComment"] = state?.versionComment;
        } else {
            const args = argsOrState as ServiceComputeArgs | undefined;
            if (args?.domains === undefined && !opts.urn) {
                throw new Error("Missing required property 'domains'");
            }
            resourceInputs["activate"] = args?.activate;
            resourceInputs["backends"] = args?.backends;
            resourceInputs["comment"] = args?.comment;
            resourceInputs["dictionaries"] = args?.dictionaries;
            resourceInputs["domains"] = args?.domains;
            resourceInputs["forceDestroy"] = args?.forceDestroy;
            resourceInputs["imageOptimizerDefaultSettings"] = args?.imageOptimizerDefaultSettings;
            resourceInputs["loggingBigqueries"] = args?.loggingBigqueries;
            resourceInputs["loggingBlobstorages"] = args?.loggingBlobstorages;
            resourceInputs["loggingCloudfiles"] = args?.loggingCloudfiles;
            resourceInputs["loggingDatadogs"] = args?.loggingDatadogs;
            resourceInputs["loggingDigitaloceans"] = args?.loggingDigitaloceans;
            resourceInputs["loggingElasticsearches"] = args?.loggingElasticsearches;
            resourceInputs["loggingFtps"] = args?.loggingFtps;
            resourceInputs["loggingGcs"] = args?.loggingGcs;
            resourceInputs["loggingGooglepubsubs"] = args?.loggingGooglepubsubs;
            resourceInputs["loggingGrafanacloudlogs"] = args?.loggingGrafanacloudlogs;
            resourceInputs["loggingHeroku"] = args?.loggingHeroku;
            resourceInputs["loggingHoneycombs"] = args?.loggingHoneycombs;
            resourceInputs["loggingHttps"] = args?.loggingHttps;
            resourceInputs["loggingKafkas"] = args?.loggingKafkas;
            resourceInputs["loggingKineses"] = args?.loggingKineses;
            resourceInputs["loggingLogentries"] = args?.loggingLogentries;
            resourceInputs["loggingLogglies"] = args?.loggingLogglies;
            resourceInputs["loggingLogshuttles"] = args?.loggingLogshuttles;
            resourceInputs["loggingNewrelics"] = args?.loggingNewrelics;
            resourceInputs["loggingOpenstacks"] = args?.loggingOpenstacks;
            resourceInputs["loggingPapertrails"] = args?.loggingPapertrails;
            resourceInputs["loggingS3s"] = args?.loggingS3s;
            resourceInputs["loggingScalyrs"] = args?.loggingScalyrs;
            resourceInputs["loggingSftps"] = args?.loggingSftps;
            resourceInputs["loggingSplunks"] = args?.loggingSplunks;
            resourceInputs["loggingSumologics"] = args?.loggingSumologics;
            resourceInputs["loggingSyslogs"] = args?.loggingSyslogs;
            resourceInputs["name"] = args?.name;
            resourceInputs["package"] = args?.package;
            resourceInputs["productEnablement"] = args?.productEnablement;
            resourceInputs["resourceLinks"] = args?.resourceLinks;
            resourceInputs["reuse"] = args?.reuse;
            resourceInputs["stage"] = args?.stage;
            resourceInputs["versionComment"] = args?.versionComment;
            resourceInputs["activeVersion"] = undefined /*out*/;
            resourceInputs["clonedVersion"] = undefined /*out*/;
            resourceInputs["forceRefresh"] = undefined /*out*/;
            resourceInputs["imported"] = undefined /*out*/;
            resourceInputs["stagedVersion"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(ServiceCompute.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering ServiceCompute resources.
 */
export interface ServiceComputeState {
    /**
     * Conditionally prevents new service versions from being activated. The apply step will create a new draft version but will not activate it if this is set to `false`. Default `true`
     */
    activate?: pulumi.Input<boolean>;
    /**
     * The currently active version of your Fastly Service
     */
    activeVersion?: pulumi.Input<number>;
    backends?: pulumi.Input<pulumi.Input<inputs.ServiceComputeBackend>[]>;
    /**
     * The latest cloned version by the provider
     */
    clonedVersion?: pulumi.Input<number>;
    comment?: pulumi.Input<string>;
    dictionaries?: pulumi.Input<pulumi.Input<inputs.ServiceComputeDictionary>[]>;
    /**
     * A set of Domain names to serve as entry points for your Service
     */
    domains?: pulumi.Input<pulumi.Input<inputs.ServiceComputeDomain>[]>;
    /**
     * Services that are active cannot be destroyed. In order to destroy the Service, set `forceDestroy` to `true`. Default `false`
     */
    forceDestroy?: pulumi.Input<boolean>;
    forceRefresh?: pulumi.Input<boolean>;
    imageOptimizerDefaultSettings?: pulumi.Input<inputs.ServiceComputeImageOptimizerDefaultSettings>;
    /**
     * Used internally by the provider to temporarily indicate if the service is being imported, and is reset to false once the import is finished
     */
    imported?: pulumi.Input<boolean>;
    loggingBigqueries?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingBigquery>[]>;
    loggingBlobstorages?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingBlobstorage>[]>;
    loggingCloudfiles?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingCloudfile>[]>;
    loggingDatadogs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingDatadog>[]>;
    loggingDigitaloceans?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingDigitalocean>[]>;
    loggingElasticsearches?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingElasticsearch>[]>;
    loggingFtps?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingFtp>[]>;
    loggingGcs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingGc>[]>;
    loggingGooglepubsubs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingGooglepubsub>[]>;
    loggingGrafanacloudlogs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingGrafanacloudlog>[]>;
    loggingHeroku?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingHeroku>[]>;
    loggingHoneycombs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingHoneycomb>[]>;
    loggingHttps?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingHttp>[]>;
    loggingKafkas?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingKafka>[]>;
    loggingKineses?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingKinese>[]>;
    loggingLogentries?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingLogentry>[]>;
    loggingLogglies?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingLoggly>[]>;
    loggingLogshuttles?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingLogshuttle>[]>;
    loggingNewrelics?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingNewrelic>[]>;
    loggingOpenstacks?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingOpenstack>[]>;
    loggingPapertrails?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingPapertrail>[]>;
    loggingS3s?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingS3>[]>;
    loggingScalyrs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingScalyr>[]>;
    loggingSftps?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingSftp>[]>;
    loggingSplunks?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingSplunk>[]>;
    loggingSumologics?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingSumologic>[]>;
    loggingSyslogs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingSyslog>[]>;
    /**
     * The unique name for the Service to create
     */
    name?: pulumi.Input<string>;
    /**
     * The `package` block supports uploading or modifying Wasm packages for use in a Fastly Compute service (if omitted, ensure `activate = false` is set on `fastly.ServiceCompute` to avoid service validation errors). See Fastly's documentation on [Compute](https://developer.fastly.com/learning/compute/)
     */
    package?: pulumi.Input<inputs.ServiceComputePackage>;
    productEnablement?: pulumi.Input<inputs.ServiceComputeProductEnablement>;
    /**
     * A resource link represents a link between a shared resource (such as an KV Store or Config Store) and a service version.
     */
    resourceLinks?: pulumi.Input<pulumi.Input<inputs.ServiceComputeResourceLink>[]>;
    reuse?: pulumi.Input<boolean>;
    /**
     * Conditionally enables new service versions to be staged. If `set` to true, all changes made by an `apply` step will be staged, even if `apply` did not create a new draft version. Default `false`
     */
    stage?: pulumi.Input<boolean>;
    /**
     * The currently staged version of your Fastly Service
     */
    stagedVersion?: pulumi.Input<number>;
    /**
     * Description field for the version
     */
    versionComment?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a ServiceCompute resource.
 */
export interface ServiceComputeArgs {
    /**
     * Conditionally prevents new service versions from being activated. The apply step will create a new draft version but will not activate it if this is set to `false`. Default `true`
     */
    activate?: pulumi.Input<boolean>;
    backends?: pulumi.Input<pulumi.Input<inputs.ServiceComputeBackend>[]>;
    comment?: pulumi.Input<string>;
    dictionaries?: pulumi.Input<pulumi.Input<inputs.ServiceComputeDictionary>[]>;
    /**
     * A set of Domain names to serve as entry points for your Service
     */
    domains: pulumi.Input<pulumi.Input<inputs.ServiceComputeDomain>[]>;
    /**
     * Services that are active cannot be destroyed. In order to destroy the Service, set `forceDestroy` to `true`. Default `false`
     */
    forceDestroy?: pulumi.Input<boolean>;
    imageOptimizerDefaultSettings?: pulumi.Input<inputs.ServiceComputeImageOptimizerDefaultSettings>;
    loggingBigqueries?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingBigquery>[]>;
    loggingBlobstorages?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingBlobstorage>[]>;
    loggingCloudfiles?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingCloudfile>[]>;
    loggingDatadogs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingDatadog>[]>;
    loggingDigitaloceans?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingDigitalocean>[]>;
    loggingElasticsearches?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingElasticsearch>[]>;
    loggingFtps?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingFtp>[]>;
    loggingGcs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingGc>[]>;
    loggingGooglepubsubs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingGooglepubsub>[]>;
    loggingGrafanacloudlogs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingGrafanacloudlog>[]>;
    loggingHeroku?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingHeroku>[]>;
    loggingHoneycombs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingHoneycomb>[]>;
    loggingHttps?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingHttp>[]>;
    loggingKafkas?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingKafka>[]>;
    loggingKineses?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingKinese>[]>;
    loggingLogentries?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingLogentry>[]>;
    loggingLogglies?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingLoggly>[]>;
    loggingLogshuttles?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingLogshuttle>[]>;
    loggingNewrelics?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingNewrelic>[]>;
    loggingOpenstacks?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingOpenstack>[]>;
    loggingPapertrails?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingPapertrail>[]>;
    loggingS3s?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingS3>[]>;
    loggingScalyrs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingScalyr>[]>;
    loggingSftps?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingSftp>[]>;
    loggingSplunks?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingSplunk>[]>;
    loggingSumologics?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingSumologic>[]>;
    loggingSyslogs?: pulumi.Input<pulumi.Input<inputs.ServiceComputeLoggingSyslog>[]>;
    /**
     * The unique name for the Service to create
     */
    name?: pulumi.Input<string>;
    /**
     * The `package` block supports uploading or modifying Wasm packages for use in a Fastly Compute service (if omitted, ensure `activate = false` is set on `fastly.ServiceCompute` to avoid service validation errors). See Fastly's documentation on [Compute](https://developer.fastly.com/learning/compute/)
     */
    package?: pulumi.Input<inputs.ServiceComputePackage>;
    productEnablement?: pulumi.Input<inputs.ServiceComputeProductEnablement>;
    /**
     * A resource link represents a link between a shared resource (such as an KV Store or Config Store) and a service version.
     */
    resourceLinks?: pulumi.Input<pulumi.Input<inputs.ServiceComputeResourceLink>[]>;
    reuse?: pulumi.Input<boolean>;
    /**
     * Conditionally enables new service versions to be staged. If `set` to true, all changes made by an `apply` step will be staged, even if `apply` did not create a new draft version. Default `false`
     */
    stage?: pulumi.Input<boolean>;
    /**
     * Description field for the version
     */
    versionComment?: pulumi.Input<string>;
}
