// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "./types";
import * as utilities from "./utilities";

/**
 * Provides a Fastly Service, representing the configuration for a website, app,
 * API, or anything else to be served through Fastly. A Service encompasses Domains
 * and Backends.
 *
 * The Service resource requires a domain name that is correctly set up to direct
 * traffic to the Fastly service. See Fastly's guide on [Adding CNAME Records][fastly-cname]
 * on their documentation site for guidance.
 *
 * ## Example Usage
 *
 * Basic usage:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as fastly from "@pulumi/fastly";
 *
 * const demo = new fastly.Servicev1("demo", {
 *     backends: [{
 *         address: "127.0.0.1",
 *         name: "localhost",
 *         port: 80,
 *     }],
 *     domains: [{
 *         comment: "demo",
 *         name: "demo.notexample.com",
 *     }],
 *     forceDestroy: true,
 * });
 * ```
 *
 * Basic usage with an Amazon S3 Website and that removes the `x-amz-request-id` header:
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as aws from "@pulumi/aws";
 * import * as fastly from "@pulumi/fastly";
 *
 * const demo = new fastly.Servicev1("demo", {
 *     backends: [{
 *         address: "demo.notexample.com.s3-website-us-west-2.amazonaws.com",
 *         name: "AWS S3 hosting",
 *         overrideHost: "demo.notexample.com.s3-website-us-west-2.amazonaws.com",
 *         port: 80,
 *     }],
 *     domains: [{
 *         comment: "demo",
 *         name: "demo.notexample.com",
 *     }],
 *     forceDestroy: true,
 *     gzips: [{
 *         contentTypes: [
 *             "text/html",
 *             "text/css",
 *         ],
 *         extensions: [
 *             "css",
 *             "js",
 *         ],
 *         name: "file extensions and content types",
 *     }],
 *     headers: [{
 *         action: "delete",
 *         destination: "http.x-amz-request-id",
 *         name: "remove x-amz-request-id",
 *         type: "cache",
 *     }],
 * });
 * const website = new aws.s3.Bucket("website", {
 *     acl: "public-read",
 *     website: {
 *         errorDocument: "error.html",
 *         indexDocument: "index.html",
 *     },
 * });
 * ```
 *
 * Basic usage with [custom
 * VCL](https://docs.fastly.com/vcl/custom-vcl/uploading-custom-vcl/):
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as fastly from "@pulumi/fastly";
 * import * as fs from "fs";
 *
 * const demo = new fastly.Servicev1("demo", {
 *     backends: [{
 *         address: "127.0.0.1",
 *         name: "localhost",
 *         port: 80,
 *     }],
 *     domains: [{
 *         comment: "demo",
 *         name: "demo.notexample.com",
 *     }],
 *     forceDestroy: true,
 *     vcls: [
 *         {
 *             content: fs.readFileSync(`./my_custom_main.vcl`, "utf-8"),
 *             main: true,
 *             name: "my_custom_main_vcl",
 *         },
 *         {
 *             content: fs.readFileSync(`./my_custom_library.vcl`, "utf-8"),
 *             name: "my_custom_library_vcl",
 *         },
 *     ],
 * });
 * ```
 *
 * Basic usage with [custom Director](https://developer.fastly.com/reference/api/load-balancing/directors/director/):
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as fastly from "@pulumi/fastly";
 *
 * const demo = new fastly.Servicev1("demo", {
 *     backends: [
 *         {
 *             address: "127.0.0.1",
 *             name: "origin1",
 *             port: 80,
 *         },
 *         {
 *             address: "127.0.0.2",
 *             name: "origin2",
 *             port: 80,
 *         },
 *     ],
 *     directors: [{
 *         backends: [
 *             "origin1",
 *             "origin2",
 *         ],
 *         name: "mydirector",
 *         quorum: 0,
 *         type: 3,
 *     }],
 *     domains: [{
 *         comment: "demo",
 *         name: "demo.notexample.com",
 *     }],
 *     forceDestroy: true,
 * });
 * ```
 *
 * Basic usage with [Web Application Firewall](https://developer.fastly.com/reference/api/waf/):
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as fastly from "@pulumi/fastly";
 *
 * const demo = new fastly.Servicev1("demo", {
 *     backends: [{
 *         address: "127.0.0.1",
 *         name: "origin1",
 *         port: 80,
 *     }],
 *     conditions: [
 *         {
 *             name: "WAF_Prefetch",
 *             statement: "req.backend.is_origin",
 *             type: "PREFETCH",
 *         },
 *         // This condition will always be false
 *         // adding it to the response object created below
 *         // prevents Fastly from returning a 403 on all of your traffic.
 *         {
 *             name: "WAF_always_false",
 *             statement: "false",
 *             type: "REQUEST",
 *         },
 *     ],
 *     domains: [{
 *         comment: "demo",
 *         name: "example.com",
 *     }],
 *     forceDestroy: true,
 *     responseObjects: [{
 *         content: "<html><body>Forbidden</body></html>",
 *         contentType: "text/html",
 *         name: "WAF_Response",
 *         requestCondition: "WAF_always_false",
 *         response: "Forbidden",
 *         status: 403,
 *     }],
 *     waf: {
 *         prefetchCondition: "WAF_Prefetch",
 *         responseObject: "WAF_Response",
 *     },
 * });
 * ```
 *
 * > **Note:** For an AWS S3 Bucket, the Backend address is
 * `<domain>.s3-website-<region>.amazonaws.com`. The `overrideHost` attribute
 * should be set to `<bucket_name>.s3-website-<region>.amazonaws.com` in the `backend` block. See the
 * Fastly documentation on [Amazon S3][fastly-s3].
 *
 * [fastly-cname]: https://docs.fastly.com/en/guides/adding-cname-records
 * [fastly-conditionals]: https://docs.fastly.com/en/guides/using-conditions
 * [fastly-sumologic]: https://developer.fastly.com/reference/api/logging/sumologic/
 * [fastly-gcs]: https://developer.fastly.com/reference/api/logging/gcs/
 *
 * ## Import
 *
 * Fastly Services can be imported using their service ID, e.g.
 *
 * ```sh
 *  $ pulumi import fastly:index/servicev1:Servicev1 demo xxxxxxxxxxxxxxxxxxxx
 * ```
 *
 *  By default, either the active version will be imported, or the latest version if no version is active. Alternatively, a specific version of the service can be selected by appending an `@` followed by the version number to the service ID, e.g.
 *
 * ```sh
 *  $ pulumi import fastly:index/servicev1:Servicev1 demo xxxxxxxxxxxxxxxxxxxx@2
 * ```
 */
export class Servicev1 extends pulumi.CustomResource {
    /**
     * Get an existing Servicev1 resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: Servicev1State, opts?: pulumi.CustomResourceOptions): Servicev1 {
        return new Servicev1(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'fastly:index/servicev1:Servicev1';

    /**
     * Returns true if the given object is an instance of Servicev1.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Servicev1 {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Servicev1.__pulumiType;
    }

    public readonly acls!: pulumi.Output<outputs.Servicev1Acl[] | undefined>;
    /**
     * Conditionally prevents the Service from being activated. The apply step will continue to create a new draft version but will not activate it if this is set to `false`. Default `true`
     */
    public readonly activate!: pulumi.Output<boolean | undefined>;
    /**
     * The currently active version of your Fastly Service
     */
    public /*out*/ readonly activeVersion!: pulumi.Output<number>;
    public readonly backends!: pulumi.Output<outputs.Servicev1Backend[] | undefined>;
    public readonly bigqueryloggings!: pulumi.Output<outputs.Servicev1Bigquerylogging[] | undefined>;
    public readonly blobstorageloggings!: pulumi.Output<outputs.Servicev1Blobstoragelogging[] | undefined>;
    public readonly cacheSettings!: pulumi.Output<outputs.Servicev1CacheSetting[] | undefined>;
    /**
     * The latest cloned version by the provider
     */
    public /*out*/ readonly clonedVersion!: pulumi.Output<number>;
    /**
     * Description field for the service. Default `Managed by Terraform`
     */
    public readonly comment!: pulumi.Output<string | undefined>;
    public readonly conditions!: pulumi.Output<outputs.Servicev1Condition[] | undefined>;
    /**
     * The default hostname
     */
    public readonly defaultHost!: pulumi.Output<string | undefined>;
    /**
     * The default Time-to-live (TTL) for requests
     */
    public readonly defaultTtl!: pulumi.Output<number | undefined>;
    public readonly dictionaries!: pulumi.Output<outputs.Servicev1Dictionary[] | undefined>;
    public readonly directors!: pulumi.Output<outputs.Servicev1Director[] | undefined>;
    /**
     * A set of Domain names to serve as entry points for your Service
     */
    public readonly domains!: pulumi.Output<outputs.Servicev1Domain[]>;
    public readonly dynamicsnippets!: pulumi.Output<outputs.Servicev1Dynamicsnippet[] | undefined>;
    /**
     * Services that are active cannot be destroyed. In order to destroy the Service, set `forceDestroy` to `true`. Default `false`
     */
    public readonly forceDestroy!: pulumi.Output<boolean | undefined>;
    public readonly gcsloggings!: pulumi.Output<outputs.Servicev1Gcslogging[] | undefined>;
    public readonly gzips!: pulumi.Output<outputs.Servicev1Gzip[] | undefined>;
    public readonly headers!: pulumi.Output<outputs.Servicev1Header[] | undefined>;
    public readonly healthchecks!: pulumi.Output<outputs.Servicev1Healthcheck[] | undefined>;
    public readonly httpsloggings!: pulumi.Output<outputs.Servicev1Httpslogging[] | undefined>;
    public readonly logentries!: pulumi.Output<outputs.Servicev1Logentry[] | undefined>;
    public readonly loggingCloudfiles!: pulumi.Output<outputs.Servicev1LoggingCloudfile[] | undefined>;
    public readonly loggingDatadogs!: pulumi.Output<outputs.Servicev1LoggingDatadog[] | undefined>;
    public readonly loggingDigitaloceans!: pulumi.Output<outputs.Servicev1LoggingDigitalocean[] | undefined>;
    public readonly loggingElasticsearches!: pulumi.Output<outputs.Servicev1LoggingElasticsearch[] | undefined>;
    public readonly loggingFtps!: pulumi.Output<outputs.Servicev1LoggingFtp[] | undefined>;
    public readonly loggingGooglepubsubs!: pulumi.Output<outputs.Servicev1LoggingGooglepubsub[] | undefined>;
    public readonly loggingHeroku!: pulumi.Output<outputs.Servicev1LoggingHeroku[] | undefined>;
    public readonly loggingHoneycombs!: pulumi.Output<outputs.Servicev1LoggingHoneycomb[] | undefined>;
    public readonly loggingKafkas!: pulumi.Output<outputs.Servicev1LoggingKafka[] | undefined>;
    public readonly loggingKineses!: pulumi.Output<outputs.Servicev1LoggingKinese[] | undefined>;
    public readonly loggingLogglies!: pulumi.Output<outputs.Servicev1LoggingLoggly[] | undefined>;
    public readonly loggingLogshuttles!: pulumi.Output<outputs.Servicev1LoggingLogshuttle[] | undefined>;
    public readonly loggingNewrelics!: pulumi.Output<outputs.Servicev1LoggingNewrelic[] | undefined>;
    public readonly loggingOpenstacks!: pulumi.Output<outputs.Servicev1LoggingOpenstack[] | undefined>;
    public readonly loggingScalyrs!: pulumi.Output<outputs.Servicev1LoggingScalyr[] | undefined>;
    public readonly loggingSftps!: pulumi.Output<outputs.Servicev1LoggingSftp[] | undefined>;
    /**
     * The unique name for the Service to create
     */
    public readonly name!: pulumi.Output<string>;
    public readonly papertrails!: pulumi.Output<outputs.Servicev1Papertrail[] | undefined>;
    public readonly requestSettings!: pulumi.Output<outputs.Servicev1RequestSetting[] | undefined>;
    public readonly responseObjects!: pulumi.Output<outputs.Servicev1ResponseObject[] | undefined>;
    public readonly s3loggings!: pulumi.Output<outputs.Servicev1S3logging[] | undefined>;
    public readonly snippets!: pulumi.Output<outputs.Servicev1Snippet[] | undefined>;
    public readonly splunks!: pulumi.Output<outputs.Servicev1Splunk[] | undefined>;
    /**
     * Enables serving a stale object if there is an error
     */
    public readonly staleIfError!: pulumi.Output<boolean | undefined>;
    /**
     * The default time-to-live (TTL) for serving the stale object for the version
     */
    public readonly staleIfErrorTtl!: pulumi.Output<number | undefined>;
    public readonly sumologics!: pulumi.Output<outputs.Servicev1Sumologic[] | undefined>;
    public readonly syslogs!: pulumi.Output<outputs.Servicev1Syslog[] | undefined>;
    public readonly vcls!: pulumi.Output<outputs.Servicev1Vcl[] | undefined>;
    /**
     * Description field for the version
     */
    public readonly versionComment!: pulumi.Output<string | undefined>;
    public readonly waf!: pulumi.Output<outputs.Servicev1Waf | undefined>;

    /**
     * Create a Servicev1 resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: Servicev1Args, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: Servicev1Args | Servicev1State, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as Servicev1State | undefined;
            resourceInputs["acls"] = state ? state.acls : undefined;
            resourceInputs["activate"] = state ? state.activate : undefined;
            resourceInputs["activeVersion"] = state ? state.activeVersion : undefined;
            resourceInputs["backends"] = state ? state.backends : undefined;
            resourceInputs["bigqueryloggings"] = state ? state.bigqueryloggings : undefined;
            resourceInputs["blobstorageloggings"] = state ? state.blobstorageloggings : undefined;
            resourceInputs["cacheSettings"] = state ? state.cacheSettings : undefined;
            resourceInputs["clonedVersion"] = state ? state.clonedVersion : undefined;
            resourceInputs["comment"] = state ? state.comment : undefined;
            resourceInputs["conditions"] = state ? state.conditions : undefined;
            resourceInputs["defaultHost"] = state ? state.defaultHost : undefined;
            resourceInputs["defaultTtl"] = state ? state.defaultTtl : undefined;
            resourceInputs["dictionaries"] = state ? state.dictionaries : undefined;
            resourceInputs["directors"] = state ? state.directors : undefined;
            resourceInputs["domains"] = state ? state.domains : undefined;
            resourceInputs["dynamicsnippets"] = state ? state.dynamicsnippets : undefined;
            resourceInputs["forceDestroy"] = state ? state.forceDestroy : undefined;
            resourceInputs["gcsloggings"] = state ? state.gcsloggings : undefined;
            resourceInputs["gzips"] = state ? state.gzips : undefined;
            resourceInputs["headers"] = state ? state.headers : undefined;
            resourceInputs["healthchecks"] = state ? state.healthchecks : undefined;
            resourceInputs["httpsloggings"] = state ? state.httpsloggings : undefined;
            resourceInputs["logentries"] = state ? state.logentries : undefined;
            resourceInputs["loggingCloudfiles"] = state ? state.loggingCloudfiles : undefined;
            resourceInputs["loggingDatadogs"] = state ? state.loggingDatadogs : undefined;
            resourceInputs["loggingDigitaloceans"] = state ? state.loggingDigitaloceans : undefined;
            resourceInputs["loggingElasticsearches"] = state ? state.loggingElasticsearches : undefined;
            resourceInputs["loggingFtps"] = state ? state.loggingFtps : undefined;
            resourceInputs["loggingGooglepubsubs"] = state ? state.loggingGooglepubsubs : undefined;
            resourceInputs["loggingHeroku"] = state ? state.loggingHeroku : undefined;
            resourceInputs["loggingHoneycombs"] = state ? state.loggingHoneycombs : undefined;
            resourceInputs["loggingKafkas"] = state ? state.loggingKafkas : undefined;
            resourceInputs["loggingKineses"] = state ? state.loggingKineses : undefined;
            resourceInputs["loggingLogglies"] = state ? state.loggingLogglies : undefined;
            resourceInputs["loggingLogshuttles"] = state ? state.loggingLogshuttles : undefined;
            resourceInputs["loggingNewrelics"] = state ? state.loggingNewrelics : undefined;
            resourceInputs["loggingOpenstacks"] = state ? state.loggingOpenstacks : undefined;
            resourceInputs["loggingScalyrs"] = state ? state.loggingScalyrs : undefined;
            resourceInputs["loggingSftps"] = state ? state.loggingSftps : undefined;
            resourceInputs["name"] = state ? state.name : undefined;
            resourceInputs["papertrails"] = state ? state.papertrails : undefined;
            resourceInputs["requestSettings"] = state ? state.requestSettings : undefined;
            resourceInputs["responseObjects"] = state ? state.responseObjects : undefined;
            resourceInputs["s3loggings"] = state ? state.s3loggings : undefined;
            resourceInputs["snippets"] = state ? state.snippets : undefined;
            resourceInputs["splunks"] = state ? state.splunks : undefined;
            resourceInputs["staleIfError"] = state ? state.staleIfError : undefined;
            resourceInputs["staleIfErrorTtl"] = state ? state.staleIfErrorTtl : undefined;
            resourceInputs["sumologics"] = state ? state.sumologics : undefined;
            resourceInputs["syslogs"] = state ? state.syslogs : undefined;
            resourceInputs["vcls"] = state ? state.vcls : undefined;
            resourceInputs["versionComment"] = state ? state.versionComment : undefined;
            resourceInputs["waf"] = state ? state.waf : undefined;
        } else {
            const args = argsOrState as Servicev1Args | undefined;
            if ((!args || args.domains === undefined) && !opts.urn) {
                throw new Error("Missing required property 'domains'");
            }
            resourceInputs["acls"] = args ? args.acls : undefined;
            resourceInputs["activate"] = args ? args.activate : undefined;
            resourceInputs["backends"] = args ? args.backends : undefined;
            resourceInputs["bigqueryloggings"] = args ? args.bigqueryloggings : undefined;
            resourceInputs["blobstorageloggings"] = args ? args.blobstorageloggings : undefined;
            resourceInputs["cacheSettings"] = args ? args.cacheSettings : undefined;
            resourceInputs["comment"] = args ? args.comment : undefined;
            resourceInputs["conditions"] = args ? args.conditions : undefined;
            resourceInputs["defaultHost"] = args ? args.defaultHost : undefined;
            resourceInputs["defaultTtl"] = args ? args.defaultTtl : undefined;
            resourceInputs["dictionaries"] = args ? args.dictionaries : undefined;
            resourceInputs["directors"] = args ? args.directors : undefined;
            resourceInputs["domains"] = args ? args.domains : undefined;
            resourceInputs["dynamicsnippets"] = args ? args.dynamicsnippets : undefined;
            resourceInputs["forceDestroy"] = args ? args.forceDestroy : undefined;
            resourceInputs["gcsloggings"] = args ? args.gcsloggings : undefined;
            resourceInputs["gzips"] = args ? args.gzips : undefined;
            resourceInputs["headers"] = args ? args.headers : undefined;
            resourceInputs["healthchecks"] = args ? args.healthchecks : undefined;
            resourceInputs["httpsloggings"] = args ? args.httpsloggings : undefined;
            resourceInputs["logentries"] = args ? args.logentries : undefined;
            resourceInputs["loggingCloudfiles"] = args ? args.loggingCloudfiles : undefined;
            resourceInputs["loggingDatadogs"] = args ? args.loggingDatadogs : undefined;
            resourceInputs["loggingDigitaloceans"] = args ? args.loggingDigitaloceans : undefined;
            resourceInputs["loggingElasticsearches"] = args ? args.loggingElasticsearches : undefined;
            resourceInputs["loggingFtps"] = args ? args.loggingFtps : undefined;
            resourceInputs["loggingGooglepubsubs"] = args ? args.loggingGooglepubsubs : undefined;
            resourceInputs["loggingHeroku"] = args ? args.loggingHeroku : undefined;
            resourceInputs["loggingHoneycombs"] = args ? args.loggingHoneycombs : undefined;
            resourceInputs["loggingKafkas"] = args ? args.loggingKafkas : undefined;
            resourceInputs["loggingKineses"] = args ? args.loggingKineses : undefined;
            resourceInputs["loggingLogglies"] = args ? args.loggingLogglies : undefined;
            resourceInputs["loggingLogshuttles"] = args ? args.loggingLogshuttles : undefined;
            resourceInputs["loggingNewrelics"] = args ? args.loggingNewrelics : undefined;
            resourceInputs["loggingOpenstacks"] = args ? args.loggingOpenstacks : undefined;
            resourceInputs["loggingScalyrs"] = args ? args.loggingScalyrs : undefined;
            resourceInputs["loggingSftps"] = args ? args.loggingSftps : undefined;
            resourceInputs["name"] = args ? args.name : undefined;
            resourceInputs["papertrails"] = args ? args.papertrails : undefined;
            resourceInputs["requestSettings"] = args ? args.requestSettings : undefined;
            resourceInputs["responseObjects"] = args ? args.responseObjects : undefined;
            resourceInputs["s3loggings"] = args ? args.s3loggings : undefined;
            resourceInputs["snippets"] = args ? args.snippets : undefined;
            resourceInputs["splunks"] = args ? args.splunks : undefined;
            resourceInputs["staleIfError"] = args ? args.staleIfError : undefined;
            resourceInputs["staleIfErrorTtl"] = args ? args.staleIfErrorTtl : undefined;
            resourceInputs["sumologics"] = args ? args.sumologics : undefined;
            resourceInputs["syslogs"] = args ? args.syslogs : undefined;
            resourceInputs["vcls"] = args ? args.vcls : undefined;
            resourceInputs["versionComment"] = args ? args.versionComment : undefined;
            resourceInputs["waf"] = args ? args.waf : undefined;
            resourceInputs["activeVersion"] = undefined /*out*/;
            resourceInputs["clonedVersion"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Servicev1.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Servicev1 resources.
 */
export interface Servicev1State {
    acls?: pulumi.Input<pulumi.Input<inputs.Servicev1Acl>[]>;
    /**
     * Conditionally prevents the Service from being activated. The apply step will continue to create a new draft version but will not activate it if this is set to `false`. Default `true`
     */
    activate?: pulumi.Input<boolean>;
    /**
     * The currently active version of your Fastly Service
     */
    activeVersion?: pulumi.Input<number>;
    backends?: pulumi.Input<pulumi.Input<inputs.Servicev1Backend>[]>;
    bigqueryloggings?: pulumi.Input<pulumi.Input<inputs.Servicev1Bigquerylogging>[]>;
    blobstorageloggings?: pulumi.Input<pulumi.Input<inputs.Servicev1Blobstoragelogging>[]>;
    cacheSettings?: pulumi.Input<pulumi.Input<inputs.Servicev1CacheSetting>[]>;
    /**
     * The latest cloned version by the provider
     */
    clonedVersion?: pulumi.Input<number>;
    /**
     * Description field for the service. Default `Managed by Terraform`
     */
    comment?: pulumi.Input<string>;
    conditions?: pulumi.Input<pulumi.Input<inputs.Servicev1Condition>[]>;
    /**
     * The default hostname
     */
    defaultHost?: pulumi.Input<string>;
    /**
     * The default Time-to-live (TTL) for requests
     */
    defaultTtl?: pulumi.Input<number>;
    dictionaries?: pulumi.Input<pulumi.Input<inputs.Servicev1Dictionary>[]>;
    directors?: pulumi.Input<pulumi.Input<inputs.Servicev1Director>[]>;
    /**
     * A set of Domain names to serve as entry points for your Service
     */
    domains?: pulumi.Input<pulumi.Input<inputs.Servicev1Domain>[]>;
    dynamicsnippets?: pulumi.Input<pulumi.Input<inputs.Servicev1Dynamicsnippet>[]>;
    /**
     * Services that are active cannot be destroyed. In order to destroy the Service, set `forceDestroy` to `true`. Default `false`
     */
    forceDestroy?: pulumi.Input<boolean>;
    gcsloggings?: pulumi.Input<pulumi.Input<inputs.Servicev1Gcslogging>[]>;
    gzips?: pulumi.Input<pulumi.Input<inputs.Servicev1Gzip>[]>;
    headers?: pulumi.Input<pulumi.Input<inputs.Servicev1Header>[]>;
    healthchecks?: pulumi.Input<pulumi.Input<inputs.Servicev1Healthcheck>[]>;
    httpsloggings?: pulumi.Input<pulumi.Input<inputs.Servicev1Httpslogging>[]>;
    logentries?: pulumi.Input<pulumi.Input<inputs.Servicev1Logentry>[]>;
    loggingCloudfiles?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingCloudfile>[]>;
    loggingDatadogs?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingDatadog>[]>;
    loggingDigitaloceans?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingDigitalocean>[]>;
    loggingElasticsearches?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingElasticsearch>[]>;
    loggingFtps?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingFtp>[]>;
    loggingGooglepubsubs?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingGooglepubsub>[]>;
    loggingHeroku?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingHeroku>[]>;
    loggingHoneycombs?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingHoneycomb>[]>;
    loggingKafkas?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingKafka>[]>;
    loggingKineses?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingKinese>[]>;
    loggingLogglies?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingLoggly>[]>;
    loggingLogshuttles?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingLogshuttle>[]>;
    loggingNewrelics?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingNewrelic>[]>;
    loggingOpenstacks?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingOpenstack>[]>;
    loggingScalyrs?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingScalyr>[]>;
    loggingSftps?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingSftp>[]>;
    /**
     * The unique name for the Service to create
     */
    name?: pulumi.Input<string>;
    papertrails?: pulumi.Input<pulumi.Input<inputs.Servicev1Papertrail>[]>;
    requestSettings?: pulumi.Input<pulumi.Input<inputs.Servicev1RequestSetting>[]>;
    responseObjects?: pulumi.Input<pulumi.Input<inputs.Servicev1ResponseObject>[]>;
    s3loggings?: pulumi.Input<pulumi.Input<inputs.Servicev1S3logging>[]>;
    snippets?: pulumi.Input<pulumi.Input<inputs.Servicev1Snippet>[]>;
    splunks?: pulumi.Input<pulumi.Input<inputs.Servicev1Splunk>[]>;
    /**
     * Enables serving a stale object if there is an error
     */
    staleIfError?: pulumi.Input<boolean>;
    /**
     * The default time-to-live (TTL) for serving the stale object for the version
     */
    staleIfErrorTtl?: pulumi.Input<number>;
    sumologics?: pulumi.Input<pulumi.Input<inputs.Servicev1Sumologic>[]>;
    syslogs?: pulumi.Input<pulumi.Input<inputs.Servicev1Syslog>[]>;
    vcls?: pulumi.Input<pulumi.Input<inputs.Servicev1Vcl>[]>;
    /**
     * Description field for the version
     */
    versionComment?: pulumi.Input<string>;
    waf?: pulumi.Input<inputs.Servicev1Waf>;
}

/**
 * The set of arguments for constructing a Servicev1 resource.
 */
export interface Servicev1Args {
    acls?: pulumi.Input<pulumi.Input<inputs.Servicev1Acl>[]>;
    /**
     * Conditionally prevents the Service from being activated. The apply step will continue to create a new draft version but will not activate it if this is set to `false`. Default `true`
     */
    activate?: pulumi.Input<boolean>;
    backends?: pulumi.Input<pulumi.Input<inputs.Servicev1Backend>[]>;
    bigqueryloggings?: pulumi.Input<pulumi.Input<inputs.Servicev1Bigquerylogging>[]>;
    blobstorageloggings?: pulumi.Input<pulumi.Input<inputs.Servicev1Blobstoragelogging>[]>;
    cacheSettings?: pulumi.Input<pulumi.Input<inputs.Servicev1CacheSetting>[]>;
    /**
     * Description field for the service. Default `Managed by Terraform`
     */
    comment?: pulumi.Input<string>;
    conditions?: pulumi.Input<pulumi.Input<inputs.Servicev1Condition>[]>;
    /**
     * The default hostname
     */
    defaultHost?: pulumi.Input<string>;
    /**
     * The default Time-to-live (TTL) for requests
     */
    defaultTtl?: pulumi.Input<number>;
    dictionaries?: pulumi.Input<pulumi.Input<inputs.Servicev1Dictionary>[]>;
    directors?: pulumi.Input<pulumi.Input<inputs.Servicev1Director>[]>;
    /**
     * A set of Domain names to serve as entry points for your Service
     */
    domains: pulumi.Input<pulumi.Input<inputs.Servicev1Domain>[]>;
    dynamicsnippets?: pulumi.Input<pulumi.Input<inputs.Servicev1Dynamicsnippet>[]>;
    /**
     * Services that are active cannot be destroyed. In order to destroy the Service, set `forceDestroy` to `true`. Default `false`
     */
    forceDestroy?: pulumi.Input<boolean>;
    gcsloggings?: pulumi.Input<pulumi.Input<inputs.Servicev1Gcslogging>[]>;
    gzips?: pulumi.Input<pulumi.Input<inputs.Servicev1Gzip>[]>;
    headers?: pulumi.Input<pulumi.Input<inputs.Servicev1Header>[]>;
    healthchecks?: pulumi.Input<pulumi.Input<inputs.Servicev1Healthcheck>[]>;
    httpsloggings?: pulumi.Input<pulumi.Input<inputs.Servicev1Httpslogging>[]>;
    logentries?: pulumi.Input<pulumi.Input<inputs.Servicev1Logentry>[]>;
    loggingCloudfiles?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingCloudfile>[]>;
    loggingDatadogs?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingDatadog>[]>;
    loggingDigitaloceans?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingDigitalocean>[]>;
    loggingElasticsearches?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingElasticsearch>[]>;
    loggingFtps?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingFtp>[]>;
    loggingGooglepubsubs?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingGooglepubsub>[]>;
    loggingHeroku?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingHeroku>[]>;
    loggingHoneycombs?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingHoneycomb>[]>;
    loggingKafkas?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingKafka>[]>;
    loggingKineses?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingKinese>[]>;
    loggingLogglies?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingLoggly>[]>;
    loggingLogshuttles?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingLogshuttle>[]>;
    loggingNewrelics?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingNewrelic>[]>;
    loggingOpenstacks?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingOpenstack>[]>;
    loggingScalyrs?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingScalyr>[]>;
    loggingSftps?: pulumi.Input<pulumi.Input<inputs.Servicev1LoggingSftp>[]>;
    /**
     * The unique name for the Service to create
     */
    name?: pulumi.Input<string>;
    papertrails?: pulumi.Input<pulumi.Input<inputs.Servicev1Papertrail>[]>;
    requestSettings?: pulumi.Input<pulumi.Input<inputs.Servicev1RequestSetting>[]>;
    responseObjects?: pulumi.Input<pulumi.Input<inputs.Servicev1ResponseObject>[]>;
    s3loggings?: pulumi.Input<pulumi.Input<inputs.Servicev1S3logging>[]>;
    snippets?: pulumi.Input<pulumi.Input<inputs.Servicev1Snippet>[]>;
    splunks?: pulumi.Input<pulumi.Input<inputs.Servicev1Splunk>[]>;
    /**
     * Enables serving a stale object if there is an error
     */
    staleIfError?: pulumi.Input<boolean>;
    /**
     * The default time-to-live (TTL) for serving the stale object for the version
     */
    staleIfErrorTtl?: pulumi.Input<number>;
    sumologics?: pulumi.Input<pulumi.Input<inputs.Servicev1Sumologic>[]>;
    syslogs?: pulumi.Input<pulumi.Input<inputs.Servicev1Syslog>[]>;
    vcls?: pulumi.Input<pulumi.Input<inputs.Servicev1Vcl>[]>;
    /**
     * Description field for the version
     */
    versionComment?: pulumi.Input<string>;
    waf?: pulumi.Input<inputs.Servicev1Waf>;
}
