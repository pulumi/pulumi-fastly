// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.fastly.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.fastly.inputs.TlsSubscriptionManagedDnsChallengeArgs;
import com.pulumi.fastly.inputs.TlsSubscriptionManagedHttpChallengeArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class TlsSubscriptionState extends com.pulumi.resources.ResourceArgs {

    public static final TlsSubscriptionState Empty = new TlsSubscriptionState();

    /**
     * The entity that issues and certifies the TLS certificates for your subscription. Valid values are `lets-encrypt` or `globalsign`.
     * 
     */
    @Import(name="certificateAuthority")
    private @Nullable Output<String> certificateAuthority;

    /**
     * @return The entity that issues and certifies the TLS certificates for your subscription. Valid values are `lets-encrypt` or `globalsign`.
     * 
     */
    public Optional<Output<String>> certificateAuthority() {
        return Optional.ofNullable(this.certificateAuthority);
    }

    /**
     * The certificate ID associated with the subscription.
     * 
     */
    @Import(name="certificateId")
    private @Nullable Output<String> certificateId;

    /**
     * @return The certificate ID associated with the subscription.
     * 
     */
    public Optional<Output<String>> certificateId() {
        return Optional.ofNullable(this.certificateId);
    }

    /**
     * The common name associated with the subscription generated by Fastly TLS. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
     * 
     */
    @Import(name="commonName")
    private @Nullable Output<String> commonName;

    /**
     * @return The common name associated with the subscription generated by Fastly TLS. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
     * 
     */
    public Optional<Output<String>> commonName() {
        return Optional.ofNullable(this.commonName);
    }

    /**
     * The ID of the set of TLS configuration options that apply to the enabled domains on this subscription.
     * 
     */
    @Import(name="configurationId")
    private @Nullable Output<String> configurationId;

    /**
     * @return The ID of the set of TLS configuration options that apply to the enabled domains on this subscription.
     * 
     */
    public Optional<Output<String>> configurationId() {
        return Optional.ofNullable(this.configurationId);
    }

    /**
     * Timestamp (GMT) when the subscription was created.
     * 
     */
    @Import(name="createdAt")
    private @Nullable Output<String> createdAt;

    /**
     * @return Timestamp (GMT) when the subscription was created.
     * 
     */
    public Optional<Output<String>> createdAt() {
        return Optional.ofNullable(this.createdAt);
    }

    /**
     * List of domains on which to enable TLS.
     * 
     */
    @Import(name="domains")
    private @Nullable Output<List<String>> domains;

    /**
     * @return List of domains on which to enable TLS.
     * 
     */
    public Optional<Output<List<String>>> domains() {
        return Optional.ofNullable(this.domains);
    }

    /**
     * Always delete subscription, even when active domains are present. Defaults to false.
     * 
     */
    @Import(name="forceDestroy")
    private @Nullable Output<Boolean> forceDestroy;

    /**
     * @return Always delete subscription, even when active domains are present. Defaults to false.
     * 
     */
    public Optional<Output<Boolean>> forceDestroy() {
        return Optional.ofNullable(this.forceDestroy);
    }

    /**
     * Always update subscription, even when active domains are present. Defaults to false.
     * 
     */
    @Import(name="forceUpdate")
    private @Nullable Output<Boolean> forceUpdate;

    /**
     * @return Always update subscription, even when active domains are present. Defaults to false.
     * 
     */
    public Optional<Output<Boolean>> forceUpdate() {
        return Optional.ofNullable(this.forceUpdate);
    }

    /**
     * The details required to configure DNS to respond to ACME DNS challenge in order to verify domain ownership.
     * 
     * @deprecated
     * Use &#39;managed_dns_challenges&#39; attribute instead
     * 
     */
    @Deprecated /* Use 'managed_dns_challenges' attribute instead */
    @Import(name="managedDnsChallenge")
    private @Nullable Output<Map<String,String>> managedDnsChallenge;

    /**
     * @return The details required to configure DNS to respond to ACME DNS challenge in order to verify domain ownership.
     * 
     * @deprecated
     * Use &#39;managed_dns_challenges&#39; attribute instead
     * 
     */
    @Deprecated /* Use 'managed_dns_challenges' attribute instead */
    public Optional<Output<Map<String,String>>> managedDnsChallenge() {
        return Optional.ofNullable(this.managedDnsChallenge);
    }

    /**
     * A list of options for configuring DNS to respond to ACME DNS challenge in order to verify domain ownership.
     * 
     */
    @Import(name="managedDnsChallenges")
    private @Nullable Output<List<TlsSubscriptionManagedDnsChallengeArgs>> managedDnsChallenges;

    /**
     * @return A list of options for configuring DNS to respond to ACME DNS challenge in order to verify domain ownership.
     * 
     */
    public Optional<Output<List<TlsSubscriptionManagedDnsChallengeArgs>>> managedDnsChallenges() {
        return Optional.ofNullable(this.managedDnsChallenges);
    }

    /**
     * A list of options for configuring DNS to respond to ACME HTTP challenge in order to verify domain ownership. Best accessed through a `for` expression to filter the relevant record.
     * 
     */
    @Import(name="managedHttpChallenges")
    private @Nullable Output<List<TlsSubscriptionManagedHttpChallengeArgs>> managedHttpChallenges;

    /**
     * @return A list of options for configuring DNS to respond to ACME HTTP challenge in order to verify domain ownership. Best accessed through a `for` expression to filter the relevant record.
     * 
     */
    public Optional<Output<List<TlsSubscriptionManagedHttpChallengeArgs>>> managedHttpChallenges() {
        return Optional.ofNullable(this.managedHttpChallenges);
    }

    /**
     * The current state of the subscription. The list of possible states are: `pending`, `processing`, `issued`, and `renewing`.
     * 
     */
    @Import(name="state")
    private @Nullable Output<String> state;

    /**
     * @return The current state of the subscription. The list of possible states are: `pending`, `processing`, `issued`, and `renewing`.
     * 
     */
    public Optional<Output<String>> state() {
        return Optional.ofNullable(this.state);
    }

    /**
     * Timestamp (GMT) when the subscription was updated.
     * 
     */
    @Import(name="updatedAt")
    private @Nullable Output<String> updatedAt;

    /**
     * @return Timestamp (GMT) when the subscription was updated.
     * 
     */
    public Optional<Output<String>> updatedAt() {
        return Optional.ofNullable(this.updatedAt);
    }

    private TlsSubscriptionState() {}

    private TlsSubscriptionState(TlsSubscriptionState $) {
        this.certificateAuthority = $.certificateAuthority;
        this.certificateId = $.certificateId;
        this.commonName = $.commonName;
        this.configurationId = $.configurationId;
        this.createdAt = $.createdAt;
        this.domains = $.domains;
        this.forceDestroy = $.forceDestroy;
        this.forceUpdate = $.forceUpdate;
        this.managedDnsChallenge = $.managedDnsChallenge;
        this.managedDnsChallenges = $.managedDnsChallenges;
        this.managedHttpChallenges = $.managedHttpChallenges;
        this.state = $.state;
        this.updatedAt = $.updatedAt;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(TlsSubscriptionState defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private TlsSubscriptionState $;

        public Builder() {
            $ = new TlsSubscriptionState();
        }

        public Builder(TlsSubscriptionState defaults) {
            $ = new TlsSubscriptionState(Objects.requireNonNull(defaults));
        }

        /**
         * @param certificateAuthority The entity that issues and certifies the TLS certificates for your subscription. Valid values are `lets-encrypt` or `globalsign`.
         * 
         * @return builder
         * 
         */
        public Builder certificateAuthority(@Nullable Output<String> certificateAuthority) {
            $.certificateAuthority = certificateAuthority;
            return this;
        }

        /**
         * @param certificateAuthority The entity that issues and certifies the TLS certificates for your subscription. Valid values are `lets-encrypt` or `globalsign`.
         * 
         * @return builder
         * 
         */
        public Builder certificateAuthority(String certificateAuthority) {
            return certificateAuthority(Output.of(certificateAuthority));
        }

        /**
         * @param certificateId The certificate ID associated with the subscription.
         * 
         * @return builder
         * 
         */
        public Builder certificateId(@Nullable Output<String> certificateId) {
            $.certificateId = certificateId;
            return this;
        }

        /**
         * @param certificateId The certificate ID associated with the subscription.
         * 
         * @return builder
         * 
         */
        public Builder certificateId(String certificateId) {
            return certificateId(Output.of(certificateId));
        }

        /**
         * @param commonName The common name associated with the subscription generated by Fastly TLS. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
         * 
         * @return builder
         * 
         */
        public Builder commonName(@Nullable Output<String> commonName) {
            $.commonName = commonName;
            return this;
        }

        /**
         * @param commonName The common name associated with the subscription generated by Fastly TLS. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
         * 
         * @return builder
         * 
         */
        public Builder commonName(String commonName) {
            return commonName(Output.of(commonName));
        }

        /**
         * @param configurationId The ID of the set of TLS configuration options that apply to the enabled domains on this subscription.
         * 
         * @return builder
         * 
         */
        public Builder configurationId(@Nullable Output<String> configurationId) {
            $.configurationId = configurationId;
            return this;
        }

        /**
         * @param configurationId The ID of the set of TLS configuration options that apply to the enabled domains on this subscription.
         * 
         * @return builder
         * 
         */
        public Builder configurationId(String configurationId) {
            return configurationId(Output.of(configurationId));
        }

        /**
         * @param createdAt Timestamp (GMT) when the subscription was created.
         * 
         * @return builder
         * 
         */
        public Builder createdAt(@Nullable Output<String> createdAt) {
            $.createdAt = createdAt;
            return this;
        }

        /**
         * @param createdAt Timestamp (GMT) when the subscription was created.
         * 
         * @return builder
         * 
         */
        public Builder createdAt(String createdAt) {
            return createdAt(Output.of(createdAt));
        }

        /**
         * @param domains List of domains on which to enable TLS.
         * 
         * @return builder
         * 
         */
        public Builder domains(@Nullable Output<List<String>> domains) {
            $.domains = domains;
            return this;
        }

        /**
         * @param domains List of domains on which to enable TLS.
         * 
         * @return builder
         * 
         */
        public Builder domains(List<String> domains) {
            return domains(Output.of(domains));
        }

        /**
         * @param domains List of domains on which to enable TLS.
         * 
         * @return builder
         * 
         */
        public Builder domains(String... domains) {
            return domains(List.of(domains));
        }

        /**
         * @param forceDestroy Always delete subscription, even when active domains are present. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder forceDestroy(@Nullable Output<Boolean> forceDestroy) {
            $.forceDestroy = forceDestroy;
            return this;
        }

        /**
         * @param forceDestroy Always delete subscription, even when active domains are present. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder forceDestroy(Boolean forceDestroy) {
            return forceDestroy(Output.of(forceDestroy));
        }

        /**
         * @param forceUpdate Always update subscription, even when active domains are present. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder forceUpdate(@Nullable Output<Boolean> forceUpdate) {
            $.forceUpdate = forceUpdate;
            return this;
        }

        /**
         * @param forceUpdate Always update subscription, even when active domains are present. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder forceUpdate(Boolean forceUpdate) {
            return forceUpdate(Output.of(forceUpdate));
        }

        /**
         * @param managedDnsChallenge The details required to configure DNS to respond to ACME DNS challenge in order to verify domain ownership.
         * 
         * @return builder
         * 
         * @deprecated
         * Use &#39;managed_dns_challenges&#39; attribute instead
         * 
         */
        @Deprecated /* Use 'managed_dns_challenges' attribute instead */
        public Builder managedDnsChallenge(@Nullable Output<Map<String,String>> managedDnsChallenge) {
            $.managedDnsChallenge = managedDnsChallenge;
            return this;
        }

        /**
         * @param managedDnsChallenge The details required to configure DNS to respond to ACME DNS challenge in order to verify domain ownership.
         * 
         * @return builder
         * 
         * @deprecated
         * Use &#39;managed_dns_challenges&#39; attribute instead
         * 
         */
        @Deprecated /* Use 'managed_dns_challenges' attribute instead */
        public Builder managedDnsChallenge(Map<String,String> managedDnsChallenge) {
            return managedDnsChallenge(Output.of(managedDnsChallenge));
        }

        /**
         * @param managedDnsChallenges A list of options for configuring DNS to respond to ACME DNS challenge in order to verify domain ownership.
         * 
         * @return builder
         * 
         */
        public Builder managedDnsChallenges(@Nullable Output<List<TlsSubscriptionManagedDnsChallengeArgs>> managedDnsChallenges) {
            $.managedDnsChallenges = managedDnsChallenges;
            return this;
        }

        /**
         * @param managedDnsChallenges A list of options for configuring DNS to respond to ACME DNS challenge in order to verify domain ownership.
         * 
         * @return builder
         * 
         */
        public Builder managedDnsChallenges(List<TlsSubscriptionManagedDnsChallengeArgs> managedDnsChallenges) {
            return managedDnsChallenges(Output.of(managedDnsChallenges));
        }

        /**
         * @param managedDnsChallenges A list of options for configuring DNS to respond to ACME DNS challenge in order to verify domain ownership.
         * 
         * @return builder
         * 
         */
        public Builder managedDnsChallenges(TlsSubscriptionManagedDnsChallengeArgs... managedDnsChallenges) {
            return managedDnsChallenges(List.of(managedDnsChallenges));
        }

        /**
         * @param managedHttpChallenges A list of options for configuring DNS to respond to ACME HTTP challenge in order to verify domain ownership. Best accessed through a `for` expression to filter the relevant record.
         * 
         * @return builder
         * 
         */
        public Builder managedHttpChallenges(@Nullable Output<List<TlsSubscriptionManagedHttpChallengeArgs>> managedHttpChallenges) {
            $.managedHttpChallenges = managedHttpChallenges;
            return this;
        }

        /**
         * @param managedHttpChallenges A list of options for configuring DNS to respond to ACME HTTP challenge in order to verify domain ownership. Best accessed through a `for` expression to filter the relevant record.
         * 
         * @return builder
         * 
         */
        public Builder managedHttpChallenges(List<TlsSubscriptionManagedHttpChallengeArgs> managedHttpChallenges) {
            return managedHttpChallenges(Output.of(managedHttpChallenges));
        }

        /**
         * @param managedHttpChallenges A list of options for configuring DNS to respond to ACME HTTP challenge in order to verify domain ownership. Best accessed through a `for` expression to filter the relevant record.
         * 
         * @return builder
         * 
         */
        public Builder managedHttpChallenges(TlsSubscriptionManagedHttpChallengeArgs... managedHttpChallenges) {
            return managedHttpChallenges(List.of(managedHttpChallenges));
        }

        /**
         * @param state The current state of the subscription. The list of possible states are: `pending`, `processing`, `issued`, and `renewing`.
         * 
         * @return builder
         * 
         */
        public Builder state(@Nullable Output<String> state) {
            $.state = state;
            return this;
        }

        /**
         * @param state The current state of the subscription. The list of possible states are: `pending`, `processing`, `issued`, and `renewing`.
         * 
         * @return builder
         * 
         */
        public Builder state(String state) {
            return state(Output.of(state));
        }

        /**
         * @param updatedAt Timestamp (GMT) when the subscription was updated.
         * 
         * @return builder
         * 
         */
        public Builder updatedAt(@Nullable Output<String> updatedAt) {
            $.updatedAt = updatedAt;
            return this;
        }

        /**
         * @param updatedAt Timestamp (GMT) when the subscription was updated.
         * 
         * @return builder
         * 
         */
        public Builder updatedAt(String updatedAt) {
            return updatedAt(Output.of(updatedAt));
        }

        public TlsSubscriptionState build() {
            return $;
        }
    }

}
