// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fastly

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Enables TLS on a domain using a specified custom TLS certificate.
//
// > **Note:** The Fastly service must be provisioned _prior_ to enabling TLS on it.
//
// ## Example Usage
//
// Basic usage:
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-fastly/sdk/v4/go/fastly"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		demoServiceVcl, err := fastly.NewServiceVcl(ctx, "demoServiceVcl", &fastly.ServiceVclArgs{
// 			Domains: ServiceVclDomainArray{
// 				&ServiceVclDomainArgs{
// 					Name: pulumi.String("example.com"),
// 				},
// 			},
// 			Backends: ServiceVclBackendArray{
// 				&ServiceVclBackendArgs{
// 					Address: pulumi.String("127.0.0.1"),
// 					Name:    pulumi.String("localhost"),
// 				},
// 			},
// 			ForceDestroy: pulumi.Bool(true),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		demoTlsPrivateKey, err := fastly.NewTlsPrivateKey(ctx, "demoTlsPrivateKey", &fastly.TlsPrivateKeyArgs{
// 			KeyPem: pulumi.String("..."),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		demoTlsCertificate, err := fastly.NewTlsCertificate(ctx, "demoTlsCertificate", &fastly.TlsCertificateArgs{
// 			CertificateBody: pulumi.String("..."),
// 		}, pulumi.DependsOn([]pulumi.Resource{
// 			demoTlsPrivateKey,
// 		}))
// 		if err != nil {
// 			return err
// 		}
// 		_, err = fastly.NewTlsActivation(ctx, "test", &fastly.TlsActivationArgs{
// 			CertificateId: demoTlsCertificate.ID(),
// 			Domain:        pulumi.String("example.com"),
// 		}, pulumi.DependsOn([]pulumi.Resource{
// 			demoServiceVcl,
// 		}))
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// A TLS activation can be imported using its ID, e.g.
//
// ```sh
//  $ pulumi import fastly:index/tlsActivation:TlsActivation demo xxxxxxxx
// ```
type TlsActivation struct {
	pulumi.CustomResourceState

	// ID of certificate to use. Must have the `domain` specified in the certificate's Subject Alternative Names.
	CertificateId pulumi.StringOutput `pulumi:"certificateId"`
	// ID of TLS configuration to be used to terminate TLS traffic, or use the default one if missing.
	ConfigurationId pulumi.StringOutput `pulumi:"configurationId"`
	// Time-stamp (GMT) when TLS was enabled.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// Domain to enable TLS on. Must be assigned to an existing Fastly Service.
	Domain pulumi.StringOutput `pulumi:"domain"`
}

// NewTlsActivation registers a new resource with the given unique name, arguments, and options.
func NewTlsActivation(ctx *pulumi.Context,
	name string, args *TlsActivationArgs, opts ...pulumi.ResourceOption) (*TlsActivation, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CertificateId == nil {
		return nil, errors.New("invalid value for required argument 'CertificateId'")
	}
	if args.Domain == nil {
		return nil, errors.New("invalid value for required argument 'Domain'")
	}
	var resource TlsActivation
	err := ctx.RegisterResource("fastly:index/tlsActivation:TlsActivation", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTlsActivation gets an existing TlsActivation resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTlsActivation(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TlsActivationState, opts ...pulumi.ResourceOption) (*TlsActivation, error) {
	var resource TlsActivation
	err := ctx.ReadResource("fastly:index/tlsActivation:TlsActivation", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TlsActivation resources.
type tlsActivationState struct {
	// ID of certificate to use. Must have the `domain` specified in the certificate's Subject Alternative Names.
	CertificateId *string `pulumi:"certificateId"`
	// ID of TLS configuration to be used to terminate TLS traffic, or use the default one if missing.
	ConfigurationId *string `pulumi:"configurationId"`
	// Time-stamp (GMT) when TLS was enabled.
	CreatedAt *string `pulumi:"createdAt"`
	// Domain to enable TLS on. Must be assigned to an existing Fastly Service.
	Domain *string `pulumi:"domain"`
}

type TlsActivationState struct {
	// ID of certificate to use. Must have the `domain` specified in the certificate's Subject Alternative Names.
	CertificateId pulumi.StringPtrInput
	// ID of TLS configuration to be used to terminate TLS traffic, or use the default one if missing.
	ConfigurationId pulumi.StringPtrInput
	// Time-stamp (GMT) when TLS was enabled.
	CreatedAt pulumi.StringPtrInput
	// Domain to enable TLS on. Must be assigned to an existing Fastly Service.
	Domain pulumi.StringPtrInput
}

func (TlsActivationState) ElementType() reflect.Type {
	return reflect.TypeOf((*tlsActivationState)(nil)).Elem()
}

type tlsActivationArgs struct {
	// ID of certificate to use. Must have the `domain` specified in the certificate's Subject Alternative Names.
	CertificateId string `pulumi:"certificateId"`
	// ID of TLS configuration to be used to terminate TLS traffic, or use the default one if missing.
	ConfigurationId *string `pulumi:"configurationId"`
	// Domain to enable TLS on. Must be assigned to an existing Fastly Service.
	Domain string `pulumi:"domain"`
}

// The set of arguments for constructing a TlsActivation resource.
type TlsActivationArgs struct {
	// ID of certificate to use. Must have the `domain` specified in the certificate's Subject Alternative Names.
	CertificateId pulumi.StringInput
	// ID of TLS configuration to be used to terminate TLS traffic, or use the default one if missing.
	ConfigurationId pulumi.StringPtrInput
	// Domain to enable TLS on. Must be assigned to an existing Fastly Service.
	Domain pulumi.StringInput
}

func (TlsActivationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*tlsActivationArgs)(nil)).Elem()
}

type TlsActivationInput interface {
	pulumi.Input

	ToTlsActivationOutput() TlsActivationOutput
	ToTlsActivationOutputWithContext(ctx context.Context) TlsActivationOutput
}

func (*TlsActivation) ElementType() reflect.Type {
	return reflect.TypeOf((**TlsActivation)(nil)).Elem()
}

func (i *TlsActivation) ToTlsActivationOutput() TlsActivationOutput {
	return i.ToTlsActivationOutputWithContext(context.Background())
}

func (i *TlsActivation) ToTlsActivationOutputWithContext(ctx context.Context) TlsActivationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsActivationOutput)
}

// TlsActivationArrayInput is an input type that accepts TlsActivationArray and TlsActivationArrayOutput values.
// You can construct a concrete instance of `TlsActivationArrayInput` via:
//
//          TlsActivationArray{ TlsActivationArgs{...} }
type TlsActivationArrayInput interface {
	pulumi.Input

	ToTlsActivationArrayOutput() TlsActivationArrayOutput
	ToTlsActivationArrayOutputWithContext(context.Context) TlsActivationArrayOutput
}

type TlsActivationArray []TlsActivationInput

func (TlsActivationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TlsActivation)(nil)).Elem()
}

func (i TlsActivationArray) ToTlsActivationArrayOutput() TlsActivationArrayOutput {
	return i.ToTlsActivationArrayOutputWithContext(context.Background())
}

func (i TlsActivationArray) ToTlsActivationArrayOutputWithContext(ctx context.Context) TlsActivationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsActivationArrayOutput)
}

// TlsActivationMapInput is an input type that accepts TlsActivationMap and TlsActivationMapOutput values.
// You can construct a concrete instance of `TlsActivationMapInput` via:
//
//          TlsActivationMap{ "key": TlsActivationArgs{...} }
type TlsActivationMapInput interface {
	pulumi.Input

	ToTlsActivationMapOutput() TlsActivationMapOutput
	ToTlsActivationMapOutputWithContext(context.Context) TlsActivationMapOutput
}

type TlsActivationMap map[string]TlsActivationInput

func (TlsActivationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TlsActivation)(nil)).Elem()
}

func (i TlsActivationMap) ToTlsActivationMapOutput() TlsActivationMapOutput {
	return i.ToTlsActivationMapOutputWithContext(context.Background())
}

func (i TlsActivationMap) ToTlsActivationMapOutputWithContext(ctx context.Context) TlsActivationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsActivationMapOutput)
}

type TlsActivationOutput struct{ *pulumi.OutputState }

func (TlsActivationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TlsActivation)(nil)).Elem()
}

func (o TlsActivationOutput) ToTlsActivationOutput() TlsActivationOutput {
	return o
}

func (o TlsActivationOutput) ToTlsActivationOutputWithContext(ctx context.Context) TlsActivationOutput {
	return o
}

type TlsActivationArrayOutput struct{ *pulumi.OutputState }

func (TlsActivationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TlsActivation)(nil)).Elem()
}

func (o TlsActivationArrayOutput) ToTlsActivationArrayOutput() TlsActivationArrayOutput {
	return o
}

func (o TlsActivationArrayOutput) ToTlsActivationArrayOutputWithContext(ctx context.Context) TlsActivationArrayOutput {
	return o
}

func (o TlsActivationArrayOutput) Index(i pulumi.IntInput) TlsActivationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TlsActivation {
		return vs[0].([]*TlsActivation)[vs[1].(int)]
	}).(TlsActivationOutput)
}

type TlsActivationMapOutput struct{ *pulumi.OutputState }

func (TlsActivationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TlsActivation)(nil)).Elem()
}

func (o TlsActivationMapOutput) ToTlsActivationMapOutput() TlsActivationMapOutput {
	return o
}

func (o TlsActivationMapOutput) ToTlsActivationMapOutputWithContext(ctx context.Context) TlsActivationMapOutput {
	return o
}

func (o TlsActivationMapOutput) MapIndex(k pulumi.StringInput) TlsActivationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TlsActivation {
		return vs[0].(map[string]*TlsActivation)[vs[1].(string)]
	}).(TlsActivationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TlsActivationInput)(nil)).Elem(), &TlsActivation{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsActivationArrayInput)(nil)).Elem(), TlsActivationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsActivationMapInput)(nil)).Elem(), TlsActivationMap{})
	pulumi.RegisterOutputType(TlsActivationOutput{})
	pulumi.RegisterOutputType(TlsActivationArrayOutput{})
	pulumi.RegisterOutputType(TlsActivationMapOutput{})
}
