// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fastly

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-fastly/sdk/v8/go/fastly/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a container that lets you store data in key-value pairs that are accessible to Compute services during request processing.
//
// In order for a Config Store (`Configstore`) to be accessible to a [Compute](https://developer.fastly.com/learning/compute/) service you'll first need to define a Compute service (`ServiceCompute`) in your configuration, and then create a link to the Config Store from within the service using the `resourceLink` block (shown in the below examples).
//
// ## Example Usage
//
// Basic usage:
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-fastly/sdk/v8/go/fastly"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// IMPORTANT: Deleting a Config Store requires first deleting its resource_link.
//			// This requires a two-step `pulumi up` as we can't guarantee deletion order.
//			// e.g. resource_link deletion within fastly_service_compute might not finish first.
//			exampleConfigstore, err := fastly.NewConfigstore(ctx, "exampleConfigstore", nil)
//			if err != nil {
//				return err
//			}
//			examplePackageHash, err := fastly.GetPackageHash(ctx, &fastly.GetPackageHashArgs{
//				Filename: pulumi.StringRef("package.tar.gz"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = fastly.NewServiceCompute(ctx, "exampleServiceCompute", &fastly.ServiceComputeArgs{
//				Domains: fastly.ServiceComputeDomainArray{
//					&fastly.ServiceComputeDomainArgs{
//						Name: pulumi.String("demo.example.com"),
//					},
//				},
//				Package: &fastly.ServiceComputePackageArgs{
//					Filename:       pulumi.String("package.tar.gz"),
//					SourceCodeHash: pulumi.String(examplePackageHash.Hash),
//				},
//				ResourceLinks: fastly.ServiceComputeResourceLinkArray{
//					&fastly.ServiceComputeResourceLinkArgs{
//						Name:       pulumi.String("my_resource_link"),
//						ResourceId: exampleConfigstore.ID(),
//					},
//				},
//				ForceDestroy: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ## Import
//
// Fastly Config Stores can be imported using their Store ID, e.g.
//
// ```sh
// $ pulumi import fastly:index/configstore:Configstore example xxxxxxxxxxxxxxxxxxxx
// ```
type Configstore struct {
	pulumi.CustomResourceState

	// Allow the Config Store to be deleted, even if it contains entries. Defaults to false.
	ForceDestroy pulumi.BoolPtrOutput `pulumi:"forceDestroy"`
	// A unique name to identify the Config Store. It is important to note that changing this attribute will delete and recreate the Config Store, and discard the current entries. You MUST first delete the associated resourceLink block from your service before modifying this field.
	Name pulumi.StringOutput `pulumi:"name"`
}

// NewConfigstore registers a new resource with the given unique name, arguments, and options.
func NewConfigstore(ctx *pulumi.Context,
	name string, args *ConfigstoreArgs, opts ...pulumi.ResourceOption) (*Configstore, error) {
	if args == nil {
		args = &ConfigstoreArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Configstore
	err := ctx.RegisterResource("fastly:index/configstore:Configstore", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetConfigstore gets an existing Configstore resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetConfigstore(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ConfigstoreState, opts ...pulumi.ResourceOption) (*Configstore, error) {
	var resource Configstore
	err := ctx.ReadResource("fastly:index/configstore:Configstore", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Configstore resources.
type configstoreState struct {
	// Allow the Config Store to be deleted, even if it contains entries. Defaults to false.
	ForceDestroy *bool `pulumi:"forceDestroy"`
	// A unique name to identify the Config Store. It is important to note that changing this attribute will delete and recreate the Config Store, and discard the current entries. You MUST first delete the associated resourceLink block from your service before modifying this field.
	Name *string `pulumi:"name"`
}

type ConfigstoreState struct {
	// Allow the Config Store to be deleted, even if it contains entries. Defaults to false.
	ForceDestroy pulumi.BoolPtrInput
	// A unique name to identify the Config Store. It is important to note that changing this attribute will delete and recreate the Config Store, and discard the current entries. You MUST first delete the associated resourceLink block from your service before modifying this field.
	Name pulumi.StringPtrInput
}

func (ConfigstoreState) ElementType() reflect.Type {
	return reflect.TypeOf((*configstoreState)(nil)).Elem()
}

type configstoreArgs struct {
	// Allow the Config Store to be deleted, even if it contains entries. Defaults to false.
	ForceDestroy *bool `pulumi:"forceDestroy"`
	// A unique name to identify the Config Store. It is important to note that changing this attribute will delete and recreate the Config Store, and discard the current entries. You MUST first delete the associated resourceLink block from your service before modifying this field.
	Name *string `pulumi:"name"`
}

// The set of arguments for constructing a Configstore resource.
type ConfigstoreArgs struct {
	// Allow the Config Store to be deleted, even if it contains entries. Defaults to false.
	ForceDestroy pulumi.BoolPtrInput
	// A unique name to identify the Config Store. It is important to note that changing this attribute will delete and recreate the Config Store, and discard the current entries. You MUST first delete the associated resourceLink block from your service before modifying this field.
	Name pulumi.StringPtrInput
}

func (ConfigstoreArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*configstoreArgs)(nil)).Elem()
}

type ConfigstoreInput interface {
	pulumi.Input

	ToConfigstoreOutput() ConfigstoreOutput
	ToConfigstoreOutputWithContext(ctx context.Context) ConfigstoreOutput
}

func (*Configstore) ElementType() reflect.Type {
	return reflect.TypeOf((**Configstore)(nil)).Elem()
}

func (i *Configstore) ToConfigstoreOutput() ConfigstoreOutput {
	return i.ToConfigstoreOutputWithContext(context.Background())
}

func (i *Configstore) ToConfigstoreOutputWithContext(ctx context.Context) ConfigstoreOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigstoreOutput)
}

// ConfigstoreArrayInput is an input type that accepts ConfigstoreArray and ConfigstoreArrayOutput values.
// You can construct a concrete instance of `ConfigstoreArrayInput` via:
//
//	ConfigstoreArray{ ConfigstoreArgs{...} }
type ConfigstoreArrayInput interface {
	pulumi.Input

	ToConfigstoreArrayOutput() ConfigstoreArrayOutput
	ToConfigstoreArrayOutputWithContext(context.Context) ConfigstoreArrayOutput
}

type ConfigstoreArray []ConfigstoreInput

func (ConfigstoreArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Configstore)(nil)).Elem()
}

func (i ConfigstoreArray) ToConfigstoreArrayOutput() ConfigstoreArrayOutput {
	return i.ToConfigstoreArrayOutputWithContext(context.Background())
}

func (i ConfigstoreArray) ToConfigstoreArrayOutputWithContext(ctx context.Context) ConfigstoreArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigstoreArrayOutput)
}

// ConfigstoreMapInput is an input type that accepts ConfigstoreMap and ConfigstoreMapOutput values.
// You can construct a concrete instance of `ConfigstoreMapInput` via:
//
//	ConfigstoreMap{ "key": ConfigstoreArgs{...} }
type ConfigstoreMapInput interface {
	pulumi.Input

	ToConfigstoreMapOutput() ConfigstoreMapOutput
	ToConfigstoreMapOutputWithContext(context.Context) ConfigstoreMapOutput
}

type ConfigstoreMap map[string]ConfigstoreInput

func (ConfigstoreMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Configstore)(nil)).Elem()
}

func (i ConfigstoreMap) ToConfigstoreMapOutput() ConfigstoreMapOutput {
	return i.ToConfigstoreMapOutputWithContext(context.Background())
}

func (i ConfigstoreMap) ToConfigstoreMapOutputWithContext(ctx context.Context) ConfigstoreMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ConfigstoreMapOutput)
}

type ConfigstoreOutput struct{ *pulumi.OutputState }

func (ConfigstoreOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Configstore)(nil)).Elem()
}

func (o ConfigstoreOutput) ToConfigstoreOutput() ConfigstoreOutput {
	return o
}

func (o ConfigstoreOutput) ToConfigstoreOutputWithContext(ctx context.Context) ConfigstoreOutput {
	return o
}

// Allow the Config Store to be deleted, even if it contains entries. Defaults to false.
func (o ConfigstoreOutput) ForceDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Configstore) pulumi.BoolPtrOutput { return v.ForceDestroy }).(pulumi.BoolPtrOutput)
}

// A unique name to identify the Config Store. It is important to note that changing this attribute will delete and recreate the Config Store, and discard the current entries. You MUST first delete the associated resourceLink block from your service before modifying this field.
func (o ConfigstoreOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Configstore) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type ConfigstoreArrayOutput struct{ *pulumi.OutputState }

func (ConfigstoreArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Configstore)(nil)).Elem()
}

func (o ConfigstoreArrayOutput) ToConfigstoreArrayOutput() ConfigstoreArrayOutput {
	return o
}

func (o ConfigstoreArrayOutput) ToConfigstoreArrayOutputWithContext(ctx context.Context) ConfigstoreArrayOutput {
	return o
}

func (o ConfigstoreArrayOutput) Index(i pulumi.IntInput) ConfigstoreOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Configstore {
		return vs[0].([]*Configstore)[vs[1].(int)]
	}).(ConfigstoreOutput)
}

type ConfigstoreMapOutput struct{ *pulumi.OutputState }

func (ConfigstoreMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Configstore)(nil)).Elem()
}

func (o ConfigstoreMapOutput) ToConfigstoreMapOutput() ConfigstoreMapOutput {
	return o
}

func (o ConfigstoreMapOutput) ToConfigstoreMapOutputWithContext(ctx context.Context) ConfigstoreMapOutput {
	return o
}

func (o ConfigstoreMapOutput) MapIndex(k pulumi.StringInput) ConfigstoreOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Configstore {
		return vs[0].(map[string]*Configstore)[vs[1].(string)]
	}).(ConfigstoreOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ConfigstoreInput)(nil)).Elem(), &Configstore{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConfigstoreArrayInput)(nil)).Elem(), ConfigstoreArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ConfigstoreMapInput)(nil)).Elem(), ConfigstoreMap{})
	pulumi.RegisterOutputType(ConfigstoreOutput{})
	pulumi.RegisterOutputType(ConfigstoreArrayOutput{})
	pulumi.RegisterOutputType(ConfigstoreMapOutput{})
}
