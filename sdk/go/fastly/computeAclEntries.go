// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fastly

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-fastly/sdk/v11/go/fastly/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// The `ComputeAclEntries` resource allows you to manage CIDR-based allow/block rules (ACL entries) inside a Fastly Compute ACL.
//
// By default, Terraform does not continue to manage the entries after the initial `pulumi up`. This allows you to make changes to ACL entries outside of Terraform using the [Fastly API](https://developer.fastly.com/reference/api/) or [Fastly CLI](https://developer.fastly.com/learning/tools/cli/)) without Terraform resetting them.
//
// To have Terraform continue managing the entries after creation (e.g., deleting any entries not defined in the config), set `manageEntries = true`.
//
// > **Note:** Use `manageEntries = true` cautiously. Terraform will overwrite external changes and delete any unmanaged entries.
//
// ## Example Usage
//
// Basic usage (with seeded values, unmanaged after initial apply):
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-fastly/sdk/v11/go/fastly"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// IMPORTANT: Deleting a Compute ACL requires first deleting its resource_link.
//			// This requires a two-step `pulumi up` as we can't guarantee deletion order.
//			exampleComputeAcl, err := fastly.NewComputeAcl(ctx, "example", &fastly.ComputeAclArgs{
//				Name: pulumi.String("my_compute_acl"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = fastly.NewComputeAclEntries(ctx, "example", &fastly.ComputeAclEntriesArgs{
//				ComputeAclId: exampleComputeAcl.ID(),
//				Entries: pulumi.StringMap{
//					"192.0.2.0/24":    pulumi.String("ALLOW"),
//					"198.51.100.0/24": pulumi.String("BLOCK"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			example, err := fastly.GetPackageHash(ctx, &fastly.GetPackageHashArgs{
//				Filename: pulumi.StringRef("package.tar.gz"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = fastly.NewServiceCompute(ctx, "example", &fastly.ServiceComputeArgs{
//				Name: pulumi.String("my_compute_service"),
//				Domains: fastly.ServiceComputeDomainArray{
//					&fastly.ServiceComputeDomainArgs{
//						Name: pulumi.String("demo.example.com"),
//					},
//				},
//				Package: &fastly.ServiceComputePackageArgs{
//					Filename:       pulumi.String("package.tar.gz"),
//					SourceCodeHash: pulumi.String(example.Hash),
//				},
//				ResourceLinks: fastly.ServiceComputeResourceLinkArray{
//					&fastly.ServiceComputeResourceLinkArgs{
//						Name:       pulumi.String("my_acl_link"),
//						ResourceId: exampleComputeAcl.ID(),
//					},
//				},
//				ForceDestroy: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// Terraform-managed usage (where Terraform controls entries long-term):
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-fastly/sdk/v11/go/fastly"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// IMPORTANT: Deleting a Compute ACL requires first deleting its resource_link.
//			// This requires a two-step `pulumi up` as we can't guarantee deletion order.
//			exampleComputeAcl, err := fastly.NewComputeAcl(ctx, "example", &fastly.ComputeAclArgs{
//				Name: pulumi.String("my_compute_acl"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = fastly.NewComputeAclEntries(ctx, "example", &fastly.ComputeAclEntriesArgs{
//				ComputeAclId: exampleComputeAcl.ID(),
//				Entries: pulumi.StringMap{
//					"203.0.113.0/24":  pulumi.String("BLOCK"),
//					"198.51.100.0/24": pulumi.String("ALLOW"),
//				},
//				ManageEntries: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			example, err := fastly.GetPackageHash(ctx, &fastly.GetPackageHashArgs{
//				Filename: pulumi.StringRef("package.tar.gz"),
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = fastly.NewServiceCompute(ctx, "example", &fastly.ServiceComputeArgs{
//				Name: pulumi.String("my_compute_service"),
//				Domains: fastly.ServiceComputeDomainArray{
//					&fastly.ServiceComputeDomainArgs{
//						Name: pulumi.String("demo.example.com"),
//					},
//				},
//				Package: &fastly.ServiceComputePackageArgs{
//					Filename:       pulumi.String("package.tar.gz"),
//					SourceCodeHash: pulumi.String(example.Hash),
//				},
//				ResourceLinks: fastly.ServiceComputeResourceLinkArray{
//					&fastly.ServiceComputeResourceLinkArgs{
//						Name:       pulumi.String("my_acl_link"),
//						ResourceId: exampleComputeAcl.ID(),
//					},
//				},
//				ForceDestroy: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Fastly Compute ACL entries can be imported using the format `<compute_acl_id>/entries`, e.g.
//
// ```sh
// $ pulumi import fastly:index/computeAclEntries:ComputeAclEntries example <compute_acl_id>/entries
// ```
type ComputeAclEntries struct {
	pulumi.CustomResourceState

	// Manages entries for a Fastly Compute Access Control List (ACL). To import, use the format \n\n/entries.
	ComputeAclId pulumi.StringOutput `pulumi:"computeAclId"`
	// A map representing the entries in the Compute ACL, where the keys are the prefixes and the values are the actions (ALLOW or BLOCK).
	Entries pulumi.StringMapOutput `pulumi:"entries"`
	// Manage the ACL entries in Terraform (default: false). If true, Terraform will ensure that the ACL's entries match the entries in the Terraform configuration.
	ManageEntries pulumi.BoolPtrOutput `pulumi:"manageEntries"`
}

// NewComputeAclEntries registers a new resource with the given unique name, arguments, and options.
func NewComputeAclEntries(ctx *pulumi.Context,
	name string, args *ComputeAclEntriesArgs, opts ...pulumi.ResourceOption) (*ComputeAclEntries, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ComputeAclId == nil {
		return nil, errors.New("invalid value for required argument 'ComputeAclId'")
	}
	if args.Entries == nil {
		return nil, errors.New("invalid value for required argument 'Entries'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ComputeAclEntries
	err := ctx.RegisterResource("fastly:index/computeAclEntries:ComputeAclEntries", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetComputeAclEntries gets an existing ComputeAclEntries resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetComputeAclEntries(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ComputeAclEntriesState, opts ...pulumi.ResourceOption) (*ComputeAclEntries, error) {
	var resource ComputeAclEntries
	err := ctx.ReadResource("fastly:index/computeAclEntries:ComputeAclEntries", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ComputeAclEntries resources.
type computeAclEntriesState struct {
	// Manages entries for a Fastly Compute Access Control List (ACL). To import, use the format \n\n/entries.
	ComputeAclId *string `pulumi:"computeAclId"`
	// A map representing the entries in the Compute ACL, where the keys are the prefixes and the values are the actions (ALLOW or BLOCK).
	Entries map[string]string `pulumi:"entries"`
	// Manage the ACL entries in Terraform (default: false). If true, Terraform will ensure that the ACL's entries match the entries in the Terraform configuration.
	ManageEntries *bool `pulumi:"manageEntries"`
}

type ComputeAclEntriesState struct {
	// Manages entries for a Fastly Compute Access Control List (ACL). To import, use the format \n\n/entries.
	ComputeAclId pulumi.StringPtrInput
	// A map representing the entries in the Compute ACL, where the keys are the prefixes and the values are the actions (ALLOW or BLOCK).
	Entries pulumi.StringMapInput
	// Manage the ACL entries in Terraform (default: false). If true, Terraform will ensure that the ACL's entries match the entries in the Terraform configuration.
	ManageEntries pulumi.BoolPtrInput
}

func (ComputeAclEntriesState) ElementType() reflect.Type {
	return reflect.TypeOf((*computeAclEntriesState)(nil)).Elem()
}

type computeAclEntriesArgs struct {
	// Manages entries for a Fastly Compute Access Control List (ACL). To import, use the format \n\n/entries.
	ComputeAclId string `pulumi:"computeAclId"`
	// A map representing the entries in the Compute ACL, where the keys are the prefixes and the values are the actions (ALLOW or BLOCK).
	Entries map[string]string `pulumi:"entries"`
	// Manage the ACL entries in Terraform (default: false). If true, Terraform will ensure that the ACL's entries match the entries in the Terraform configuration.
	ManageEntries *bool `pulumi:"manageEntries"`
}

// The set of arguments for constructing a ComputeAclEntries resource.
type ComputeAclEntriesArgs struct {
	// Manages entries for a Fastly Compute Access Control List (ACL). To import, use the format \n\n/entries.
	ComputeAclId pulumi.StringInput
	// A map representing the entries in the Compute ACL, where the keys are the prefixes and the values are the actions (ALLOW or BLOCK).
	Entries pulumi.StringMapInput
	// Manage the ACL entries in Terraform (default: false). If true, Terraform will ensure that the ACL's entries match the entries in the Terraform configuration.
	ManageEntries pulumi.BoolPtrInput
}

func (ComputeAclEntriesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*computeAclEntriesArgs)(nil)).Elem()
}

type ComputeAclEntriesInput interface {
	pulumi.Input

	ToComputeAclEntriesOutput() ComputeAclEntriesOutput
	ToComputeAclEntriesOutputWithContext(ctx context.Context) ComputeAclEntriesOutput
}

func (*ComputeAclEntries) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeAclEntries)(nil)).Elem()
}

func (i *ComputeAclEntries) ToComputeAclEntriesOutput() ComputeAclEntriesOutput {
	return i.ToComputeAclEntriesOutputWithContext(context.Background())
}

func (i *ComputeAclEntries) ToComputeAclEntriesOutputWithContext(ctx context.Context) ComputeAclEntriesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeAclEntriesOutput)
}

// ComputeAclEntriesArrayInput is an input type that accepts ComputeAclEntriesArray and ComputeAclEntriesArrayOutput values.
// You can construct a concrete instance of `ComputeAclEntriesArrayInput` via:
//
//	ComputeAclEntriesArray{ ComputeAclEntriesArgs{...} }
type ComputeAclEntriesArrayInput interface {
	pulumi.Input

	ToComputeAclEntriesArrayOutput() ComputeAclEntriesArrayOutput
	ToComputeAclEntriesArrayOutputWithContext(context.Context) ComputeAclEntriesArrayOutput
}

type ComputeAclEntriesArray []ComputeAclEntriesInput

func (ComputeAclEntriesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ComputeAclEntries)(nil)).Elem()
}

func (i ComputeAclEntriesArray) ToComputeAclEntriesArrayOutput() ComputeAclEntriesArrayOutput {
	return i.ToComputeAclEntriesArrayOutputWithContext(context.Background())
}

func (i ComputeAclEntriesArray) ToComputeAclEntriesArrayOutputWithContext(ctx context.Context) ComputeAclEntriesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeAclEntriesArrayOutput)
}

// ComputeAclEntriesMapInput is an input type that accepts ComputeAclEntriesMap and ComputeAclEntriesMapOutput values.
// You can construct a concrete instance of `ComputeAclEntriesMapInput` via:
//
//	ComputeAclEntriesMap{ "key": ComputeAclEntriesArgs{...} }
type ComputeAclEntriesMapInput interface {
	pulumi.Input

	ToComputeAclEntriesMapOutput() ComputeAclEntriesMapOutput
	ToComputeAclEntriesMapOutputWithContext(context.Context) ComputeAclEntriesMapOutput
}

type ComputeAclEntriesMap map[string]ComputeAclEntriesInput

func (ComputeAclEntriesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ComputeAclEntries)(nil)).Elem()
}

func (i ComputeAclEntriesMap) ToComputeAclEntriesMapOutput() ComputeAclEntriesMapOutput {
	return i.ToComputeAclEntriesMapOutputWithContext(context.Background())
}

func (i ComputeAclEntriesMap) ToComputeAclEntriesMapOutputWithContext(ctx context.Context) ComputeAclEntriesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ComputeAclEntriesMapOutput)
}

type ComputeAclEntriesOutput struct{ *pulumi.OutputState }

func (ComputeAclEntriesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ComputeAclEntries)(nil)).Elem()
}

func (o ComputeAclEntriesOutput) ToComputeAclEntriesOutput() ComputeAclEntriesOutput {
	return o
}

func (o ComputeAclEntriesOutput) ToComputeAclEntriesOutputWithContext(ctx context.Context) ComputeAclEntriesOutput {
	return o
}

// Manages entries for a Fastly Compute Access Control List (ACL). To import, use the format \n\n/entries.
func (o ComputeAclEntriesOutput) ComputeAclId() pulumi.StringOutput {
	return o.ApplyT(func(v *ComputeAclEntries) pulumi.StringOutput { return v.ComputeAclId }).(pulumi.StringOutput)
}

// A map representing the entries in the Compute ACL, where the keys are the prefixes and the values are the actions (ALLOW or BLOCK).
func (o ComputeAclEntriesOutput) Entries() pulumi.StringMapOutput {
	return o.ApplyT(func(v *ComputeAclEntries) pulumi.StringMapOutput { return v.Entries }).(pulumi.StringMapOutput)
}

// Manage the ACL entries in Terraform (default: false). If true, Terraform will ensure that the ACL's entries match the entries in the Terraform configuration.
func (o ComputeAclEntriesOutput) ManageEntries() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ComputeAclEntries) pulumi.BoolPtrOutput { return v.ManageEntries }).(pulumi.BoolPtrOutput)
}

type ComputeAclEntriesArrayOutput struct{ *pulumi.OutputState }

func (ComputeAclEntriesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ComputeAclEntries)(nil)).Elem()
}

func (o ComputeAclEntriesArrayOutput) ToComputeAclEntriesArrayOutput() ComputeAclEntriesArrayOutput {
	return o
}

func (o ComputeAclEntriesArrayOutput) ToComputeAclEntriesArrayOutputWithContext(ctx context.Context) ComputeAclEntriesArrayOutput {
	return o
}

func (o ComputeAclEntriesArrayOutput) Index(i pulumi.IntInput) ComputeAclEntriesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ComputeAclEntries {
		return vs[0].([]*ComputeAclEntries)[vs[1].(int)]
	}).(ComputeAclEntriesOutput)
}

type ComputeAclEntriesMapOutput struct{ *pulumi.OutputState }

func (ComputeAclEntriesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ComputeAclEntries)(nil)).Elem()
}

func (o ComputeAclEntriesMapOutput) ToComputeAclEntriesMapOutput() ComputeAclEntriesMapOutput {
	return o
}

func (o ComputeAclEntriesMapOutput) ToComputeAclEntriesMapOutputWithContext(ctx context.Context) ComputeAclEntriesMapOutput {
	return o
}

func (o ComputeAclEntriesMapOutput) MapIndex(k pulumi.StringInput) ComputeAclEntriesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ComputeAclEntries {
		return vs[0].(map[string]*ComputeAclEntries)[vs[1].(string)]
	}).(ComputeAclEntriesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ComputeAclEntriesInput)(nil)).Elem(), &ComputeAclEntries{})
	pulumi.RegisterInputType(reflect.TypeOf((*ComputeAclEntriesArrayInput)(nil)).Elem(), ComputeAclEntriesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ComputeAclEntriesMapInput)(nil)).Elem(), ComputeAclEntriesMap{})
	pulumi.RegisterOutputType(ComputeAclEntriesOutput{})
	pulumi.RegisterOutputType(ComputeAclEntriesArrayOutput{})
	pulumi.RegisterOutputType(ComputeAclEntriesMapOutput{})
}
