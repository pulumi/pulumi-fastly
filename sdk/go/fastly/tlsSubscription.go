// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fastly

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-fastly/sdk/v9/go/fastly/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Enables TLS on a domain using a certificate managed by Fastly.
//
// DNS records need to be modified on the domain being secured, in order to respond to the ACME domain ownership challenge.
//
// There are two options for doing this: the `managedDnsChallenges`, which is the default method; and the `managedHttpChallenges`, which points production traffic to Fastly.
//
// > See the [Fastly documentation](https://docs.fastly.com/en/guides/serving-https-traffic-using-fastly-managed-certificates#verifying-domain-ownership) for more information on verifying domain ownership.
//
// The examples below demonstrate usage with AWS Route53 to configure DNS, and the `TlsSubscriptionValidation` resource to wait for validation to complete.
//
// ## Import
//
// A subscription can be imported using its Fastly subscription ID, e.g.
//
// ```sh
// $ pulumi import fastly:index/tlsSubscription:TlsSubscription demo xxxxxxxxxxx
// ```
type TlsSubscription struct {
	pulumi.CustomResourceState

	// The entity that issues and certifies the TLS certificates for your subscription. Valid values are `lets-encrypt` or `globalsign`.
	CertificateAuthority pulumi.StringOutput `pulumi:"certificateAuthority"`
	// The certificate ID associated with the subscription.
	CertificateId pulumi.StringOutput `pulumi:"certificateId"`
	// The common name associated with the subscription generated by Fastly TLS. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
	CommonName pulumi.StringOutput `pulumi:"commonName"`
	// The ID of the set of TLS configuration options that apply to the enabled domains on this subscription.
	ConfigurationId pulumi.StringOutput `pulumi:"configurationId"`
	// Timestamp (GMT) when the subscription was created.
	CreatedAt pulumi.StringOutput `pulumi:"createdAt"`
	// List of domains on which to enable TLS.
	Domains pulumi.StringArrayOutput `pulumi:"domains"`
	// Always delete subscription, even when active domains are present. Defaults to false.
	//
	// !> **Warning:** by default, the Fastly API protects you from disabling production traffic by preventing updating or deleting subscriptions with active domains. The use of `forceUpdate` and `forceDestroy` will override these protections. Take extra care using these options if you are handling production traffic.
	ForceDestroy pulumi.BoolPtrOutput `pulumi:"forceDestroy"`
	// Always update subscription, even when active domains are present. Defaults to false.
	ForceUpdate pulumi.BoolPtrOutput `pulumi:"forceUpdate"`
	// The details required to configure DNS to respond to ACME DNS challenge in order to verify domain ownership.
	//
	// Deprecated: Use 'managed_dns_challenges' attribute instead
	ManagedDnsChallenge pulumi.StringMapOutput `pulumi:"managedDnsChallenge"`
	// A list of options for configuring DNS to respond to ACME DNS challenge in order to verify domain ownership.
	ManagedDnsChallenges TlsSubscriptionManagedDnsChallengeArrayOutput `pulumi:"managedDnsChallenges"`
	// A list of options for configuring DNS to respond to ACME HTTP challenge in order to verify domain ownership. Best accessed through a `for` expression to filter the relevant record.
	ManagedHttpChallenges TlsSubscriptionManagedHttpChallengeArrayOutput `pulumi:"managedHttpChallenges"`
	// The current state of the subscription. The list of possible states are: `pending`, `processing`, `issued`, and `renewing`.
	State pulumi.StringOutput `pulumi:"state"`
	// Timestamp (GMT) when the subscription was updated.
	UpdatedAt pulumi.StringOutput `pulumi:"updatedAt"`
}

// NewTlsSubscription registers a new resource with the given unique name, arguments, and options.
func NewTlsSubscription(ctx *pulumi.Context,
	name string, args *TlsSubscriptionArgs, opts ...pulumi.ResourceOption) (*TlsSubscription, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CertificateAuthority == nil {
		return nil, errors.New("invalid value for required argument 'CertificateAuthority'")
	}
	if args.Domains == nil {
		return nil, errors.New("invalid value for required argument 'Domains'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource TlsSubscription
	err := ctx.RegisterResource("fastly:index/tlsSubscription:TlsSubscription", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTlsSubscription gets an existing TlsSubscription resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTlsSubscription(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TlsSubscriptionState, opts ...pulumi.ResourceOption) (*TlsSubscription, error) {
	var resource TlsSubscription
	err := ctx.ReadResource("fastly:index/tlsSubscription:TlsSubscription", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering TlsSubscription resources.
type tlsSubscriptionState struct {
	// The entity that issues and certifies the TLS certificates for your subscription. Valid values are `lets-encrypt` or `globalsign`.
	CertificateAuthority *string `pulumi:"certificateAuthority"`
	// The certificate ID associated with the subscription.
	CertificateId *string `pulumi:"certificateId"`
	// The common name associated with the subscription generated by Fastly TLS. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
	CommonName *string `pulumi:"commonName"`
	// The ID of the set of TLS configuration options that apply to the enabled domains on this subscription.
	ConfigurationId *string `pulumi:"configurationId"`
	// Timestamp (GMT) when the subscription was created.
	CreatedAt *string `pulumi:"createdAt"`
	// List of domains on which to enable TLS.
	Domains []string `pulumi:"domains"`
	// Always delete subscription, even when active domains are present. Defaults to false.
	//
	// !> **Warning:** by default, the Fastly API protects you from disabling production traffic by preventing updating or deleting subscriptions with active domains. The use of `forceUpdate` and `forceDestroy` will override these protections. Take extra care using these options if you are handling production traffic.
	ForceDestroy *bool `pulumi:"forceDestroy"`
	// Always update subscription, even when active domains are present. Defaults to false.
	ForceUpdate *bool `pulumi:"forceUpdate"`
	// The details required to configure DNS to respond to ACME DNS challenge in order to verify domain ownership.
	//
	// Deprecated: Use 'managed_dns_challenges' attribute instead
	ManagedDnsChallenge map[string]string `pulumi:"managedDnsChallenge"`
	// A list of options for configuring DNS to respond to ACME DNS challenge in order to verify domain ownership.
	ManagedDnsChallenges []TlsSubscriptionManagedDnsChallenge `pulumi:"managedDnsChallenges"`
	// A list of options for configuring DNS to respond to ACME HTTP challenge in order to verify domain ownership. Best accessed through a `for` expression to filter the relevant record.
	ManagedHttpChallenges []TlsSubscriptionManagedHttpChallenge `pulumi:"managedHttpChallenges"`
	// The current state of the subscription. The list of possible states are: `pending`, `processing`, `issued`, and `renewing`.
	State *string `pulumi:"state"`
	// Timestamp (GMT) when the subscription was updated.
	UpdatedAt *string `pulumi:"updatedAt"`
}

type TlsSubscriptionState struct {
	// The entity that issues and certifies the TLS certificates for your subscription. Valid values are `lets-encrypt` or `globalsign`.
	CertificateAuthority pulumi.StringPtrInput
	// The certificate ID associated with the subscription.
	CertificateId pulumi.StringPtrInput
	// The common name associated with the subscription generated by Fastly TLS. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
	CommonName pulumi.StringPtrInput
	// The ID of the set of TLS configuration options that apply to the enabled domains on this subscription.
	ConfigurationId pulumi.StringPtrInput
	// Timestamp (GMT) when the subscription was created.
	CreatedAt pulumi.StringPtrInput
	// List of domains on which to enable TLS.
	Domains pulumi.StringArrayInput
	// Always delete subscription, even when active domains are present. Defaults to false.
	//
	// !> **Warning:** by default, the Fastly API protects you from disabling production traffic by preventing updating or deleting subscriptions with active domains. The use of `forceUpdate` and `forceDestroy` will override these protections. Take extra care using these options if you are handling production traffic.
	ForceDestroy pulumi.BoolPtrInput
	// Always update subscription, even when active domains are present. Defaults to false.
	ForceUpdate pulumi.BoolPtrInput
	// The details required to configure DNS to respond to ACME DNS challenge in order to verify domain ownership.
	//
	// Deprecated: Use 'managed_dns_challenges' attribute instead
	ManagedDnsChallenge pulumi.StringMapInput
	// A list of options for configuring DNS to respond to ACME DNS challenge in order to verify domain ownership.
	ManagedDnsChallenges TlsSubscriptionManagedDnsChallengeArrayInput
	// A list of options for configuring DNS to respond to ACME HTTP challenge in order to verify domain ownership. Best accessed through a `for` expression to filter the relevant record.
	ManagedHttpChallenges TlsSubscriptionManagedHttpChallengeArrayInput
	// The current state of the subscription. The list of possible states are: `pending`, `processing`, `issued`, and `renewing`.
	State pulumi.StringPtrInput
	// Timestamp (GMT) when the subscription was updated.
	UpdatedAt pulumi.StringPtrInput
}

func (TlsSubscriptionState) ElementType() reflect.Type {
	return reflect.TypeOf((*tlsSubscriptionState)(nil)).Elem()
}

type tlsSubscriptionArgs struct {
	// The entity that issues and certifies the TLS certificates for your subscription. Valid values are `lets-encrypt` or `globalsign`.
	CertificateAuthority string `pulumi:"certificateAuthority"`
	// The common name associated with the subscription generated by Fastly TLS. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
	CommonName *string `pulumi:"commonName"`
	// The ID of the set of TLS configuration options that apply to the enabled domains on this subscription.
	ConfigurationId *string `pulumi:"configurationId"`
	// List of domains on which to enable TLS.
	Domains []string `pulumi:"domains"`
	// Always delete subscription, even when active domains are present. Defaults to false.
	//
	// !> **Warning:** by default, the Fastly API protects you from disabling production traffic by preventing updating or deleting subscriptions with active domains. The use of `forceUpdate` and `forceDestroy` will override these protections. Take extra care using these options if you are handling production traffic.
	ForceDestroy *bool `pulumi:"forceDestroy"`
	// Always update subscription, even when active domains are present. Defaults to false.
	ForceUpdate *bool `pulumi:"forceUpdate"`
}

// The set of arguments for constructing a TlsSubscription resource.
type TlsSubscriptionArgs struct {
	// The entity that issues and certifies the TLS certificates for your subscription. Valid values are `lets-encrypt` or `globalsign`.
	CertificateAuthority pulumi.StringInput
	// The common name associated with the subscription generated by Fastly TLS. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
	CommonName pulumi.StringPtrInput
	// The ID of the set of TLS configuration options that apply to the enabled domains on this subscription.
	ConfigurationId pulumi.StringPtrInput
	// List of domains on which to enable TLS.
	Domains pulumi.StringArrayInput
	// Always delete subscription, even when active domains are present. Defaults to false.
	//
	// !> **Warning:** by default, the Fastly API protects you from disabling production traffic by preventing updating or deleting subscriptions with active domains. The use of `forceUpdate` and `forceDestroy` will override these protections. Take extra care using these options if you are handling production traffic.
	ForceDestroy pulumi.BoolPtrInput
	// Always update subscription, even when active domains are present. Defaults to false.
	ForceUpdate pulumi.BoolPtrInput
}

func (TlsSubscriptionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*tlsSubscriptionArgs)(nil)).Elem()
}

type TlsSubscriptionInput interface {
	pulumi.Input

	ToTlsSubscriptionOutput() TlsSubscriptionOutput
	ToTlsSubscriptionOutputWithContext(ctx context.Context) TlsSubscriptionOutput
}

func (*TlsSubscription) ElementType() reflect.Type {
	return reflect.TypeOf((**TlsSubscription)(nil)).Elem()
}

func (i *TlsSubscription) ToTlsSubscriptionOutput() TlsSubscriptionOutput {
	return i.ToTlsSubscriptionOutputWithContext(context.Background())
}

func (i *TlsSubscription) ToTlsSubscriptionOutputWithContext(ctx context.Context) TlsSubscriptionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsSubscriptionOutput)
}

// TlsSubscriptionArrayInput is an input type that accepts TlsSubscriptionArray and TlsSubscriptionArrayOutput values.
// You can construct a concrete instance of `TlsSubscriptionArrayInput` via:
//
//	TlsSubscriptionArray{ TlsSubscriptionArgs{...} }
type TlsSubscriptionArrayInput interface {
	pulumi.Input

	ToTlsSubscriptionArrayOutput() TlsSubscriptionArrayOutput
	ToTlsSubscriptionArrayOutputWithContext(context.Context) TlsSubscriptionArrayOutput
}

type TlsSubscriptionArray []TlsSubscriptionInput

func (TlsSubscriptionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TlsSubscription)(nil)).Elem()
}

func (i TlsSubscriptionArray) ToTlsSubscriptionArrayOutput() TlsSubscriptionArrayOutput {
	return i.ToTlsSubscriptionArrayOutputWithContext(context.Background())
}

func (i TlsSubscriptionArray) ToTlsSubscriptionArrayOutputWithContext(ctx context.Context) TlsSubscriptionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsSubscriptionArrayOutput)
}

// TlsSubscriptionMapInput is an input type that accepts TlsSubscriptionMap and TlsSubscriptionMapOutput values.
// You can construct a concrete instance of `TlsSubscriptionMapInput` via:
//
//	TlsSubscriptionMap{ "key": TlsSubscriptionArgs{...} }
type TlsSubscriptionMapInput interface {
	pulumi.Input

	ToTlsSubscriptionMapOutput() TlsSubscriptionMapOutput
	ToTlsSubscriptionMapOutputWithContext(context.Context) TlsSubscriptionMapOutput
}

type TlsSubscriptionMap map[string]TlsSubscriptionInput

func (TlsSubscriptionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TlsSubscription)(nil)).Elem()
}

func (i TlsSubscriptionMap) ToTlsSubscriptionMapOutput() TlsSubscriptionMapOutput {
	return i.ToTlsSubscriptionMapOutputWithContext(context.Background())
}

func (i TlsSubscriptionMap) ToTlsSubscriptionMapOutputWithContext(ctx context.Context) TlsSubscriptionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TlsSubscriptionMapOutput)
}

type TlsSubscriptionOutput struct{ *pulumi.OutputState }

func (TlsSubscriptionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TlsSubscription)(nil)).Elem()
}

func (o TlsSubscriptionOutput) ToTlsSubscriptionOutput() TlsSubscriptionOutput {
	return o
}

func (o TlsSubscriptionOutput) ToTlsSubscriptionOutputWithContext(ctx context.Context) TlsSubscriptionOutput {
	return o
}

// The entity that issues and certifies the TLS certificates for your subscription. Valid values are `lets-encrypt` or `globalsign`.
func (o TlsSubscriptionOutput) CertificateAuthority() pulumi.StringOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.StringOutput { return v.CertificateAuthority }).(pulumi.StringOutput)
}

// The certificate ID associated with the subscription.
func (o TlsSubscriptionOutput) CertificateId() pulumi.StringOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.StringOutput { return v.CertificateId }).(pulumi.StringOutput)
}

// The common name associated with the subscription generated by Fastly TLS. If you do not pass a common name on create, we will default to the first TLS domain included. If provided, the domain chosen as the common name must be included in TLS domains.
func (o TlsSubscriptionOutput) CommonName() pulumi.StringOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.StringOutput { return v.CommonName }).(pulumi.StringOutput)
}

// The ID of the set of TLS configuration options that apply to the enabled domains on this subscription.
func (o TlsSubscriptionOutput) ConfigurationId() pulumi.StringOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.StringOutput { return v.ConfigurationId }).(pulumi.StringOutput)
}

// Timestamp (GMT) when the subscription was created.
func (o TlsSubscriptionOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

// List of domains on which to enable TLS.
func (o TlsSubscriptionOutput) Domains() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.StringArrayOutput { return v.Domains }).(pulumi.StringArrayOutput)
}

// Always delete subscription, even when active domains are present. Defaults to false.
//
// !> **Warning:** by default, the Fastly API protects you from disabling production traffic by preventing updating or deleting subscriptions with active domains. The use of `forceUpdate` and `forceDestroy` will override these protections. Take extra care using these options if you are handling production traffic.
func (o TlsSubscriptionOutput) ForceDestroy() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.BoolPtrOutput { return v.ForceDestroy }).(pulumi.BoolPtrOutput)
}

// Always update subscription, even when active domains are present. Defaults to false.
func (o TlsSubscriptionOutput) ForceUpdate() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.BoolPtrOutput { return v.ForceUpdate }).(pulumi.BoolPtrOutput)
}

// The details required to configure DNS to respond to ACME DNS challenge in order to verify domain ownership.
//
// Deprecated: Use 'managed_dns_challenges' attribute instead
func (o TlsSubscriptionOutput) ManagedDnsChallenge() pulumi.StringMapOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.StringMapOutput { return v.ManagedDnsChallenge }).(pulumi.StringMapOutput)
}

// A list of options for configuring DNS to respond to ACME DNS challenge in order to verify domain ownership.
func (o TlsSubscriptionOutput) ManagedDnsChallenges() TlsSubscriptionManagedDnsChallengeArrayOutput {
	return o.ApplyT(func(v *TlsSubscription) TlsSubscriptionManagedDnsChallengeArrayOutput { return v.ManagedDnsChallenges }).(TlsSubscriptionManagedDnsChallengeArrayOutput)
}

// A list of options for configuring DNS to respond to ACME HTTP challenge in order to verify domain ownership. Best accessed through a `for` expression to filter the relevant record.
func (o TlsSubscriptionOutput) ManagedHttpChallenges() TlsSubscriptionManagedHttpChallengeArrayOutput {
	return o.ApplyT(func(v *TlsSubscription) TlsSubscriptionManagedHttpChallengeArrayOutput {
		return v.ManagedHttpChallenges
	}).(TlsSubscriptionManagedHttpChallengeArrayOutput)
}

// The current state of the subscription. The list of possible states are: `pending`, `processing`, `issued`, and `renewing`.
func (o TlsSubscriptionOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

// Timestamp (GMT) when the subscription was updated.
func (o TlsSubscriptionOutput) UpdatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *TlsSubscription) pulumi.StringOutput { return v.UpdatedAt }).(pulumi.StringOutput)
}

type TlsSubscriptionArrayOutput struct{ *pulumi.OutputState }

func (TlsSubscriptionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*TlsSubscription)(nil)).Elem()
}

func (o TlsSubscriptionArrayOutput) ToTlsSubscriptionArrayOutput() TlsSubscriptionArrayOutput {
	return o
}

func (o TlsSubscriptionArrayOutput) ToTlsSubscriptionArrayOutputWithContext(ctx context.Context) TlsSubscriptionArrayOutput {
	return o
}

func (o TlsSubscriptionArrayOutput) Index(i pulumi.IntInput) TlsSubscriptionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *TlsSubscription {
		return vs[0].([]*TlsSubscription)[vs[1].(int)]
	}).(TlsSubscriptionOutput)
}

type TlsSubscriptionMapOutput struct{ *pulumi.OutputState }

func (TlsSubscriptionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*TlsSubscription)(nil)).Elem()
}

func (o TlsSubscriptionMapOutput) ToTlsSubscriptionMapOutput() TlsSubscriptionMapOutput {
	return o
}

func (o TlsSubscriptionMapOutput) ToTlsSubscriptionMapOutputWithContext(ctx context.Context) TlsSubscriptionMapOutput {
	return o
}

func (o TlsSubscriptionMapOutput) MapIndex(k pulumi.StringInput) TlsSubscriptionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *TlsSubscription {
		return vs[0].(map[string]*TlsSubscription)[vs[1].(string)]
	}).(TlsSubscriptionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TlsSubscriptionInput)(nil)).Elem(), &TlsSubscription{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsSubscriptionArrayInput)(nil)).Elem(), TlsSubscriptionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TlsSubscriptionMapInput)(nil)).Elem(), TlsSubscriptionMap{})
	pulumi.RegisterOutputType(TlsSubscriptionOutput{})
	pulumi.RegisterOutputType(TlsSubscriptionArrayOutput{})
	pulumi.RegisterOutputType(TlsSubscriptionMapOutput{})
}
