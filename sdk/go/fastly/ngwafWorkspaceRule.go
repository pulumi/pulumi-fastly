// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package fastly

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-fastly/sdk/v11/go/fastly/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Fastly Next-Gen WAF Workspace Rule, scoped to a specific NGWAF workspace.\
// These rules define conditions and actions that trigger WAF enforcement at the workspace level.
//
// ## Example Usage
//
// Basic usage:
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-fastly/sdk/v11/go/fastly"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			example, err := fastly.NewNgwafWorkspace(ctx, "example", &fastly.NgwafWorkspaceArgs{
//				Name:            pulumi.String("example"),
//				Description:     pulumi.String("Test NGWAF Workspace"),
//				Mode:            pulumi.String("block"),
//				IpAnonymization: pulumi.String("hashed"),
//				ClientIpHeaders: pulumi.StringArray{
//					pulumi.String("X-Forwarded-For"),
//					pulumi.String("X-Real-IP"),
//				},
//				DefaultBlockingResponseCode: pulumi.Int(429),
//				AttackSignalThresholds:      &fastly.NgwafWorkspaceAttackSignalThresholdsArgs{},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = fastly.NewNgwafWorkspaceRule(ctx, "example", &fastly.NgwafWorkspaceRuleArgs{
//				WorkspaceId:    example.ID(),
//				Type:           pulumi.String("request"),
//				Description:    pulumi.String("example"),
//				Enabled:        pulumi.Bool(true),
//				RequestLogging: pulumi.String("sampled"),
//				GroupOperator:  pulumi.String("all"),
//				Actions: fastly.NgwafWorkspaceRuleActionArray{
//					&fastly.NgwafWorkspaceRuleActionArgs{
//						Type: pulumi.String("block"),
//					},
//				},
//				Conditions: fastly.NgwafWorkspaceRuleConditionArray{
//					&fastly.NgwafWorkspaceRuleConditionArgs{
//						Field:    pulumi.String("ip"),
//						Operator: pulumi.String("equals"),
//						Value:    pulumi.String("127.0.0.1"),
//					},
//					&fastly.NgwafWorkspaceRuleConditionArgs{
//						Field:    pulumi.String("path"),
//						Operator: pulumi.String("equals"),
//						Value:    pulumi.String("/login"),
//					},
//					&fastly.NgwafWorkspaceRuleConditionArgs{
//						Field:    pulumi.String("agent_name"),
//						Operator: pulumi.String("equals"),
//						Value:    pulumi.String("host-001"),
//					},
//				},
//				GroupConditions: fastly.NgwafWorkspaceRuleGroupConditionArray{
//					&fastly.NgwafWorkspaceRuleGroupConditionArgs{
//						GroupOperator: pulumi.String("all"),
//						Conditions: fastly.NgwafWorkspaceRuleGroupConditionConditionArray{
//							&fastly.NgwafWorkspaceRuleGroupConditionConditionArgs{
//								Field:    pulumi.String("country"),
//								Operator: pulumi.String("equals"),
//								Value:    pulumi.String("AD"),
//							},
//							&fastly.NgwafWorkspaceRuleGroupConditionConditionArgs{
//								Field:    pulumi.String("method"),
//								Operator: pulumi.String("equals"),
//								Value:    pulumi.String("POST"),
//							},
//						},
//					},
//					&fastly.NgwafWorkspaceRuleGroupConditionArgs{
//						GroupOperator: pulumi.String("any"),
//						Conditions: fastly.NgwafWorkspaceRuleGroupConditionConditionArray{
//							&fastly.NgwafWorkspaceRuleGroupConditionConditionArgs{
//								Field:    pulumi.String("protocol_version"),
//								Operator: pulumi.String("equals"),
//								Value:    pulumi.String("HTTP/1.0"),
//							},
//							&fastly.NgwafWorkspaceRuleGroupConditionConditionArgs{
//								Field:    pulumi.String("method"),
//								Operator: pulumi.String("equals"),
//								Value:    pulumi.String("HEAD"),
//							},
//							&fastly.NgwafWorkspaceRuleGroupConditionConditionArgs{
//								Field:    pulumi.String("domain"),
//								Operator: pulumi.String("equals"),
//								Value:    pulumi.String("example.com"),
//							},
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Fastly Next-Gen WAF workspace rules can be imported using the format `<workspaceID>/<ruleID>`, e.g.:
//
// ```sh
// $ pulumi import fastly:index/ngwafWorkspaceRule:NgwafWorkspaceRule demo <workspaceID>/<ruleID>
// ```
type NgwafWorkspaceRule struct {
	pulumi.CustomResourceState

	// List of actions to perform when the rule matches.
	Actions NgwafWorkspaceRuleActionArrayOutput `pulumi:"actions"`
	// Flat list of individual conditions. Each must include `field`, `operator`, and `value`.
	Conditions NgwafWorkspaceRuleConditionArrayOutput `pulumi:"conditions"`
	// The description of the rule.
	Description pulumi.StringOutput `pulumi:"description"`
	// Whether the rule is currently enabled.
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// List of grouped conditions with nested logic. Each group must define a `groupOperator` and at least one condition.
	GroupConditions NgwafWorkspaceRuleGroupConditionArrayOutput `pulumi:"groupConditions"`
	// Logical operator to apply to group conditions. Accepted values are `any` and `all`.
	GroupOperator pulumi.StringPtrOutput `pulumi:"groupOperator"`
	// Block specifically for rate*limit rules.
	RateLimit NgwafWorkspaceRuleRateLimitPtrOutput `pulumi:"rateLimit"`
	// Logging behavior for matching requests. Accepted values are `sampled` and `none`.
	RequestLogging pulumi.StringPtrOutput `pulumi:"requestLogging"`
	// The type of the rule. Accepted values are `request`, `signal`, `rateLimit`, and `templatedSignal`.
	Type pulumi.StringOutput `pulumi:"type"`
	// The ID of the workspace.
	WorkspaceId pulumi.StringOutput `pulumi:"workspaceId"`
}

// NewNgwafWorkspaceRule registers a new resource with the given unique name, arguments, and options.
func NewNgwafWorkspaceRule(ctx *pulumi.Context,
	name string, args *NgwafWorkspaceRuleArgs, opts ...pulumi.ResourceOption) (*NgwafWorkspaceRule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Actions == nil {
		return nil, errors.New("invalid value for required argument 'Actions'")
	}
	if args.Description == nil {
		return nil, errors.New("invalid value for required argument 'Description'")
	}
	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Type == nil {
		return nil, errors.New("invalid value for required argument 'Type'")
	}
	if args.WorkspaceId == nil {
		return nil, errors.New("invalid value for required argument 'WorkspaceId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NgwafWorkspaceRule
	err := ctx.RegisterResource("fastly:index/ngwafWorkspaceRule:NgwafWorkspaceRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNgwafWorkspaceRule gets an existing NgwafWorkspaceRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNgwafWorkspaceRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NgwafWorkspaceRuleState, opts ...pulumi.ResourceOption) (*NgwafWorkspaceRule, error) {
	var resource NgwafWorkspaceRule
	err := ctx.ReadResource("fastly:index/ngwafWorkspaceRule:NgwafWorkspaceRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NgwafWorkspaceRule resources.
type ngwafWorkspaceRuleState struct {
	// List of actions to perform when the rule matches.
	Actions []NgwafWorkspaceRuleAction `pulumi:"actions"`
	// Flat list of individual conditions. Each must include `field`, `operator`, and `value`.
	Conditions []NgwafWorkspaceRuleCondition `pulumi:"conditions"`
	// The description of the rule.
	Description *string `pulumi:"description"`
	// Whether the rule is currently enabled.
	Enabled *bool `pulumi:"enabled"`
	// List of grouped conditions with nested logic. Each group must define a `groupOperator` and at least one condition.
	GroupConditions []NgwafWorkspaceRuleGroupCondition `pulumi:"groupConditions"`
	// Logical operator to apply to group conditions. Accepted values are `any` and `all`.
	GroupOperator *string `pulumi:"groupOperator"`
	// Block specifically for rate*limit rules.
	RateLimit *NgwafWorkspaceRuleRateLimit `pulumi:"rateLimit"`
	// Logging behavior for matching requests. Accepted values are `sampled` and `none`.
	RequestLogging *string `pulumi:"requestLogging"`
	// The type of the rule. Accepted values are `request`, `signal`, `rateLimit`, and `templatedSignal`.
	Type *string `pulumi:"type"`
	// The ID of the workspace.
	WorkspaceId *string `pulumi:"workspaceId"`
}

type NgwafWorkspaceRuleState struct {
	// List of actions to perform when the rule matches.
	Actions NgwafWorkspaceRuleActionArrayInput
	// Flat list of individual conditions. Each must include `field`, `operator`, and `value`.
	Conditions NgwafWorkspaceRuleConditionArrayInput
	// The description of the rule.
	Description pulumi.StringPtrInput
	// Whether the rule is currently enabled.
	Enabled pulumi.BoolPtrInput
	// List of grouped conditions with nested logic. Each group must define a `groupOperator` and at least one condition.
	GroupConditions NgwafWorkspaceRuleGroupConditionArrayInput
	// Logical operator to apply to group conditions. Accepted values are `any` and `all`.
	GroupOperator pulumi.StringPtrInput
	// Block specifically for rate*limit rules.
	RateLimit NgwafWorkspaceRuleRateLimitPtrInput
	// Logging behavior for matching requests. Accepted values are `sampled` and `none`.
	RequestLogging pulumi.StringPtrInput
	// The type of the rule. Accepted values are `request`, `signal`, `rateLimit`, and `templatedSignal`.
	Type pulumi.StringPtrInput
	// The ID of the workspace.
	WorkspaceId pulumi.StringPtrInput
}

func (NgwafWorkspaceRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*ngwafWorkspaceRuleState)(nil)).Elem()
}

type ngwafWorkspaceRuleArgs struct {
	// List of actions to perform when the rule matches.
	Actions []NgwafWorkspaceRuleAction `pulumi:"actions"`
	// Flat list of individual conditions. Each must include `field`, `operator`, and `value`.
	Conditions []NgwafWorkspaceRuleCondition `pulumi:"conditions"`
	// The description of the rule.
	Description string `pulumi:"description"`
	// Whether the rule is currently enabled.
	Enabled bool `pulumi:"enabled"`
	// List of grouped conditions with nested logic. Each group must define a `groupOperator` and at least one condition.
	GroupConditions []NgwafWorkspaceRuleGroupCondition `pulumi:"groupConditions"`
	// Logical operator to apply to group conditions. Accepted values are `any` and `all`.
	GroupOperator *string `pulumi:"groupOperator"`
	// Block specifically for rate*limit rules.
	RateLimit *NgwafWorkspaceRuleRateLimit `pulumi:"rateLimit"`
	// Logging behavior for matching requests. Accepted values are `sampled` and `none`.
	RequestLogging *string `pulumi:"requestLogging"`
	// The type of the rule. Accepted values are `request`, `signal`, `rateLimit`, and `templatedSignal`.
	Type string `pulumi:"type"`
	// The ID of the workspace.
	WorkspaceId string `pulumi:"workspaceId"`
}

// The set of arguments for constructing a NgwafWorkspaceRule resource.
type NgwafWorkspaceRuleArgs struct {
	// List of actions to perform when the rule matches.
	Actions NgwafWorkspaceRuleActionArrayInput
	// Flat list of individual conditions. Each must include `field`, `operator`, and `value`.
	Conditions NgwafWorkspaceRuleConditionArrayInput
	// The description of the rule.
	Description pulumi.StringInput
	// Whether the rule is currently enabled.
	Enabled pulumi.BoolInput
	// List of grouped conditions with nested logic. Each group must define a `groupOperator` and at least one condition.
	GroupConditions NgwafWorkspaceRuleGroupConditionArrayInput
	// Logical operator to apply to group conditions. Accepted values are `any` and `all`.
	GroupOperator pulumi.StringPtrInput
	// Block specifically for rate*limit rules.
	RateLimit NgwafWorkspaceRuleRateLimitPtrInput
	// Logging behavior for matching requests. Accepted values are `sampled` and `none`.
	RequestLogging pulumi.StringPtrInput
	// The type of the rule. Accepted values are `request`, `signal`, `rateLimit`, and `templatedSignal`.
	Type pulumi.StringInput
	// The ID of the workspace.
	WorkspaceId pulumi.StringInput
}

func (NgwafWorkspaceRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ngwafWorkspaceRuleArgs)(nil)).Elem()
}

type NgwafWorkspaceRuleInput interface {
	pulumi.Input

	ToNgwafWorkspaceRuleOutput() NgwafWorkspaceRuleOutput
	ToNgwafWorkspaceRuleOutputWithContext(ctx context.Context) NgwafWorkspaceRuleOutput
}

func (*NgwafWorkspaceRule) ElementType() reflect.Type {
	return reflect.TypeOf((**NgwafWorkspaceRule)(nil)).Elem()
}

func (i *NgwafWorkspaceRule) ToNgwafWorkspaceRuleOutput() NgwafWorkspaceRuleOutput {
	return i.ToNgwafWorkspaceRuleOutputWithContext(context.Background())
}

func (i *NgwafWorkspaceRule) ToNgwafWorkspaceRuleOutputWithContext(ctx context.Context) NgwafWorkspaceRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NgwafWorkspaceRuleOutput)
}

// NgwafWorkspaceRuleArrayInput is an input type that accepts NgwafWorkspaceRuleArray and NgwafWorkspaceRuleArrayOutput values.
// You can construct a concrete instance of `NgwafWorkspaceRuleArrayInput` via:
//
//	NgwafWorkspaceRuleArray{ NgwafWorkspaceRuleArgs{...} }
type NgwafWorkspaceRuleArrayInput interface {
	pulumi.Input

	ToNgwafWorkspaceRuleArrayOutput() NgwafWorkspaceRuleArrayOutput
	ToNgwafWorkspaceRuleArrayOutputWithContext(context.Context) NgwafWorkspaceRuleArrayOutput
}

type NgwafWorkspaceRuleArray []NgwafWorkspaceRuleInput

func (NgwafWorkspaceRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NgwafWorkspaceRule)(nil)).Elem()
}

func (i NgwafWorkspaceRuleArray) ToNgwafWorkspaceRuleArrayOutput() NgwafWorkspaceRuleArrayOutput {
	return i.ToNgwafWorkspaceRuleArrayOutputWithContext(context.Background())
}

func (i NgwafWorkspaceRuleArray) ToNgwafWorkspaceRuleArrayOutputWithContext(ctx context.Context) NgwafWorkspaceRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NgwafWorkspaceRuleArrayOutput)
}

// NgwafWorkspaceRuleMapInput is an input type that accepts NgwafWorkspaceRuleMap and NgwafWorkspaceRuleMapOutput values.
// You can construct a concrete instance of `NgwafWorkspaceRuleMapInput` via:
//
//	NgwafWorkspaceRuleMap{ "key": NgwafWorkspaceRuleArgs{...} }
type NgwafWorkspaceRuleMapInput interface {
	pulumi.Input

	ToNgwafWorkspaceRuleMapOutput() NgwafWorkspaceRuleMapOutput
	ToNgwafWorkspaceRuleMapOutputWithContext(context.Context) NgwafWorkspaceRuleMapOutput
}

type NgwafWorkspaceRuleMap map[string]NgwafWorkspaceRuleInput

func (NgwafWorkspaceRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NgwafWorkspaceRule)(nil)).Elem()
}

func (i NgwafWorkspaceRuleMap) ToNgwafWorkspaceRuleMapOutput() NgwafWorkspaceRuleMapOutput {
	return i.ToNgwafWorkspaceRuleMapOutputWithContext(context.Background())
}

func (i NgwafWorkspaceRuleMap) ToNgwafWorkspaceRuleMapOutputWithContext(ctx context.Context) NgwafWorkspaceRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NgwafWorkspaceRuleMapOutput)
}

type NgwafWorkspaceRuleOutput struct{ *pulumi.OutputState }

func (NgwafWorkspaceRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NgwafWorkspaceRule)(nil)).Elem()
}

func (o NgwafWorkspaceRuleOutput) ToNgwafWorkspaceRuleOutput() NgwafWorkspaceRuleOutput {
	return o
}

func (o NgwafWorkspaceRuleOutput) ToNgwafWorkspaceRuleOutputWithContext(ctx context.Context) NgwafWorkspaceRuleOutput {
	return o
}

// List of actions to perform when the rule matches.
func (o NgwafWorkspaceRuleOutput) Actions() NgwafWorkspaceRuleActionArrayOutput {
	return o.ApplyT(func(v *NgwafWorkspaceRule) NgwafWorkspaceRuleActionArrayOutput { return v.Actions }).(NgwafWorkspaceRuleActionArrayOutput)
}

// Flat list of individual conditions. Each must include `field`, `operator`, and `value`.
func (o NgwafWorkspaceRuleOutput) Conditions() NgwafWorkspaceRuleConditionArrayOutput {
	return o.ApplyT(func(v *NgwafWorkspaceRule) NgwafWorkspaceRuleConditionArrayOutput { return v.Conditions }).(NgwafWorkspaceRuleConditionArrayOutput)
}

// The description of the rule.
func (o NgwafWorkspaceRuleOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *NgwafWorkspaceRule) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// Whether the rule is currently enabled.
func (o NgwafWorkspaceRuleOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *NgwafWorkspaceRule) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// List of grouped conditions with nested logic. Each group must define a `groupOperator` and at least one condition.
func (o NgwafWorkspaceRuleOutput) GroupConditions() NgwafWorkspaceRuleGroupConditionArrayOutput {
	return o.ApplyT(func(v *NgwafWorkspaceRule) NgwafWorkspaceRuleGroupConditionArrayOutput { return v.GroupConditions }).(NgwafWorkspaceRuleGroupConditionArrayOutput)
}

// Logical operator to apply to group conditions. Accepted values are `any` and `all`.
func (o NgwafWorkspaceRuleOutput) GroupOperator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NgwafWorkspaceRule) pulumi.StringPtrOutput { return v.GroupOperator }).(pulumi.StringPtrOutput)
}

// Block specifically for rate*limit rules.
func (o NgwafWorkspaceRuleOutput) RateLimit() NgwafWorkspaceRuleRateLimitPtrOutput {
	return o.ApplyT(func(v *NgwafWorkspaceRule) NgwafWorkspaceRuleRateLimitPtrOutput { return v.RateLimit }).(NgwafWorkspaceRuleRateLimitPtrOutput)
}

// Logging behavior for matching requests. Accepted values are `sampled` and `none`.
func (o NgwafWorkspaceRuleOutput) RequestLogging() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *NgwafWorkspaceRule) pulumi.StringPtrOutput { return v.RequestLogging }).(pulumi.StringPtrOutput)
}

// The type of the rule. Accepted values are `request`, `signal`, `rateLimit`, and `templatedSignal`.
func (o NgwafWorkspaceRuleOutput) Type() pulumi.StringOutput {
	return o.ApplyT(func(v *NgwafWorkspaceRule) pulumi.StringOutput { return v.Type }).(pulumi.StringOutput)
}

// The ID of the workspace.
func (o NgwafWorkspaceRuleOutput) WorkspaceId() pulumi.StringOutput {
	return o.ApplyT(func(v *NgwafWorkspaceRule) pulumi.StringOutput { return v.WorkspaceId }).(pulumi.StringOutput)
}

type NgwafWorkspaceRuleArrayOutput struct{ *pulumi.OutputState }

func (NgwafWorkspaceRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NgwafWorkspaceRule)(nil)).Elem()
}

func (o NgwafWorkspaceRuleArrayOutput) ToNgwafWorkspaceRuleArrayOutput() NgwafWorkspaceRuleArrayOutput {
	return o
}

func (o NgwafWorkspaceRuleArrayOutput) ToNgwafWorkspaceRuleArrayOutputWithContext(ctx context.Context) NgwafWorkspaceRuleArrayOutput {
	return o
}

func (o NgwafWorkspaceRuleArrayOutput) Index(i pulumi.IntInput) NgwafWorkspaceRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NgwafWorkspaceRule {
		return vs[0].([]*NgwafWorkspaceRule)[vs[1].(int)]
	}).(NgwafWorkspaceRuleOutput)
}

type NgwafWorkspaceRuleMapOutput struct{ *pulumi.OutputState }

func (NgwafWorkspaceRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NgwafWorkspaceRule)(nil)).Elem()
}

func (o NgwafWorkspaceRuleMapOutput) ToNgwafWorkspaceRuleMapOutput() NgwafWorkspaceRuleMapOutput {
	return o
}

func (o NgwafWorkspaceRuleMapOutput) ToNgwafWorkspaceRuleMapOutputWithContext(ctx context.Context) NgwafWorkspaceRuleMapOutput {
	return o
}

func (o NgwafWorkspaceRuleMapOutput) MapIndex(k pulumi.StringInput) NgwafWorkspaceRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NgwafWorkspaceRule {
		return vs[0].(map[string]*NgwafWorkspaceRule)[vs[1].(string)]
	}).(NgwafWorkspaceRuleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NgwafWorkspaceRuleInput)(nil)).Elem(), &NgwafWorkspaceRule{})
	pulumi.RegisterInputType(reflect.TypeOf((*NgwafWorkspaceRuleArrayInput)(nil)).Elem(), NgwafWorkspaceRuleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NgwafWorkspaceRuleMapInput)(nil)).Elem(), NgwafWorkspaceRuleMap{})
	pulumi.RegisterOutputType(NgwafWorkspaceRuleOutput{})
	pulumi.RegisterOutputType(NgwafWorkspaceRuleArrayOutput{})
	pulumi.RegisterOutputType(NgwafWorkspaceRuleMapOutput{})
}
