# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['ServiceComputeArgs', 'ServiceCompute']

@pulumi.input_type
class ServiceComputeArgs:
    def __init__(__self__, *,
                 domains: pulumi.Input[Sequence[pulumi.Input['ServiceComputeDomainArgs']]],
                 activate: Optional[pulumi.Input[bool]] = None,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeBackendArgs']]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 dictionaries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDictionaryArgs']]]] = None,
                 force_destroy: Optional[pulumi.Input[bool]] = None,
                 logging_bigqueries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBigqueryArgs']]]] = None,
                 logging_blobstorages: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBlobstorageArgs']]]] = None,
                 logging_cloudfiles: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingCloudfileArgs']]]] = None,
                 logging_datadogs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDatadogArgs']]]] = None,
                 logging_digitaloceans: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDigitaloceanArgs']]]] = None,
                 logging_elasticsearches: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingElasticsearchArgs']]]] = None,
                 logging_ftps: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingFtpArgs']]]] = None,
                 logging_gcs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGcArgs']]]] = None,
                 logging_googlepubsubs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGooglepubsubArgs']]]] = None,
                 logging_heroku: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHerokuArgs']]]] = None,
                 logging_honeycombs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHoneycombArgs']]]] = None,
                 logging_https: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHttpArgs']]]] = None,
                 logging_kafkas: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKafkaArgs']]]] = None,
                 logging_kineses: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKineseArgs']]]] = None,
                 logging_logentries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogentryArgs']]]] = None,
                 logging_logglies: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogglyArgs']]]] = None,
                 logging_logshuttles: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogshuttleArgs']]]] = None,
                 logging_newrelics: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingNewrelicArgs']]]] = None,
                 logging_openstacks: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingOpenstackArgs']]]] = None,
                 logging_papertrails: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingPapertrailArgs']]]] = None,
                 logging_s3s: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingS3Args']]]] = None,
                 logging_scalyrs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingScalyrArgs']]]] = None,
                 logging_sftps: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSftpArgs']]]] = None,
                 logging_splunks: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSplunkArgs']]]] = None,
                 logging_sumologics: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSumologicArgs']]]] = None,
                 logging_syslogs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSyslogArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 package: Optional[pulumi.Input['ServiceComputePackageArgs']] = None,
                 product_enablement: Optional[pulumi.Input['ServiceComputeProductEnablementArgs']] = None,
                 resource_links: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeResourceLinkArgs']]]] = None,
                 reuse: Optional[pulumi.Input[bool]] = None,
                 version_comment: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a ServiceCompute resource.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceComputeDomainArgs']]] domains: The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        :param pulumi.Input[bool] activate: Conditionally prevents the Service from being activated. The apply step will continue to create a new draft version but will not activate it if this is set to `false`. Default `true`
        :param pulumi.Input[str] comment: An optional comment about the Domain.
        :param pulumi.Input[bool] force_destroy: Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        :param pulumi.Input[str] name: Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input['ServiceComputePackageArgs'] package: The `package` block supports uploading or modifying Wasm packages for use in a Fastly Compute@Edge service (if omitted, ensure `activate = false` is set on `ServiceCompute` to avoid service validation errors). See Fastly's documentation on [Compute@Edge](https://developer.fastly.com/learning/compute/)
        :param pulumi.Input[Sequence[pulumi.Input['ServiceComputeResourceLinkArgs']]] resource_links: A resource link represents a link between a shared resource (such as an KV Store or Config Store) and a service version.
        :param pulumi.Input[bool] reuse: Services that are active cannot be destroyed. If set to `true` a service Terraform intends to destroy will instead be
               deactivated (allowing it to be reused by importing it into another Terraform project). If `false`, attempting to destroy
               an active service will cause an error. Default `false`
        :param pulumi.Input[str] version_comment: Description field for the version
        """
        ServiceComputeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domains=domains,
            activate=activate,
            backends=backends,
            comment=comment,
            dictionaries=dictionaries,
            force_destroy=force_destroy,
            logging_bigqueries=logging_bigqueries,
            logging_blobstorages=logging_blobstorages,
            logging_cloudfiles=logging_cloudfiles,
            logging_datadogs=logging_datadogs,
            logging_digitaloceans=logging_digitaloceans,
            logging_elasticsearches=logging_elasticsearches,
            logging_ftps=logging_ftps,
            logging_gcs=logging_gcs,
            logging_googlepubsubs=logging_googlepubsubs,
            logging_heroku=logging_heroku,
            logging_honeycombs=logging_honeycombs,
            logging_https=logging_https,
            logging_kafkas=logging_kafkas,
            logging_kineses=logging_kineses,
            logging_logentries=logging_logentries,
            logging_logglies=logging_logglies,
            logging_logshuttles=logging_logshuttles,
            logging_newrelics=logging_newrelics,
            logging_openstacks=logging_openstacks,
            logging_papertrails=logging_papertrails,
            logging_s3s=logging_s3s,
            logging_scalyrs=logging_scalyrs,
            logging_sftps=logging_sftps,
            logging_splunks=logging_splunks,
            logging_sumologics=logging_sumologics,
            logging_syslogs=logging_syslogs,
            name=name,
            package=package,
            product_enablement=product_enablement,
            resource_links=resource_links,
            reuse=reuse,
            version_comment=version_comment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domains: pulumi.Input[Sequence[pulumi.Input['ServiceComputeDomainArgs']]],
             activate: Optional[pulumi.Input[bool]] = None,
             backends: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeBackendArgs']]]] = None,
             comment: Optional[pulumi.Input[str]] = None,
             dictionaries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDictionaryArgs']]]] = None,
             force_destroy: Optional[pulumi.Input[bool]] = None,
             logging_bigqueries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBigqueryArgs']]]] = None,
             logging_blobstorages: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBlobstorageArgs']]]] = None,
             logging_cloudfiles: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingCloudfileArgs']]]] = None,
             logging_datadogs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDatadogArgs']]]] = None,
             logging_digitaloceans: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDigitaloceanArgs']]]] = None,
             logging_elasticsearches: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingElasticsearchArgs']]]] = None,
             logging_ftps: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingFtpArgs']]]] = None,
             logging_gcs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGcArgs']]]] = None,
             logging_googlepubsubs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGooglepubsubArgs']]]] = None,
             logging_heroku: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHerokuArgs']]]] = None,
             logging_honeycombs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHoneycombArgs']]]] = None,
             logging_https: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHttpArgs']]]] = None,
             logging_kafkas: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKafkaArgs']]]] = None,
             logging_kineses: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKineseArgs']]]] = None,
             logging_logentries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogentryArgs']]]] = None,
             logging_logglies: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogglyArgs']]]] = None,
             logging_logshuttles: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogshuttleArgs']]]] = None,
             logging_newrelics: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingNewrelicArgs']]]] = None,
             logging_openstacks: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingOpenstackArgs']]]] = None,
             logging_papertrails: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingPapertrailArgs']]]] = None,
             logging_s3s: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingS3Args']]]] = None,
             logging_scalyrs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingScalyrArgs']]]] = None,
             logging_sftps: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSftpArgs']]]] = None,
             logging_splunks: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSplunkArgs']]]] = None,
             logging_sumologics: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSumologicArgs']]]] = None,
             logging_syslogs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSyslogArgs']]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             package: Optional[pulumi.Input['ServiceComputePackageArgs']] = None,
             product_enablement: Optional[pulumi.Input['ServiceComputeProductEnablementArgs']] = None,
             resource_links: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeResourceLinkArgs']]]] = None,
             reuse: Optional[pulumi.Input[bool]] = None,
             version_comment: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("domains", domains)
        if activate is not None:
            _setter("activate", activate)
        if backends is not None:
            _setter("backends", backends)
        if comment is not None:
            _setter("comment", comment)
        if dictionaries is not None:
            _setter("dictionaries", dictionaries)
        if force_destroy is not None:
            _setter("force_destroy", force_destroy)
        if logging_bigqueries is not None:
            _setter("logging_bigqueries", logging_bigqueries)
        if logging_blobstorages is not None:
            _setter("logging_blobstorages", logging_blobstorages)
        if logging_cloudfiles is not None:
            _setter("logging_cloudfiles", logging_cloudfiles)
        if logging_datadogs is not None:
            _setter("logging_datadogs", logging_datadogs)
        if logging_digitaloceans is not None:
            _setter("logging_digitaloceans", logging_digitaloceans)
        if logging_elasticsearches is not None:
            _setter("logging_elasticsearches", logging_elasticsearches)
        if logging_ftps is not None:
            _setter("logging_ftps", logging_ftps)
        if logging_gcs is not None:
            _setter("logging_gcs", logging_gcs)
        if logging_googlepubsubs is not None:
            _setter("logging_googlepubsubs", logging_googlepubsubs)
        if logging_heroku is not None:
            _setter("logging_heroku", logging_heroku)
        if logging_honeycombs is not None:
            _setter("logging_honeycombs", logging_honeycombs)
        if logging_https is not None:
            _setter("logging_https", logging_https)
        if logging_kafkas is not None:
            _setter("logging_kafkas", logging_kafkas)
        if logging_kineses is not None:
            _setter("logging_kineses", logging_kineses)
        if logging_logentries is not None:
            _setter("logging_logentries", logging_logentries)
        if logging_logglies is not None:
            _setter("logging_logglies", logging_logglies)
        if logging_logshuttles is not None:
            _setter("logging_logshuttles", logging_logshuttles)
        if logging_newrelics is not None:
            _setter("logging_newrelics", logging_newrelics)
        if logging_openstacks is not None:
            _setter("logging_openstacks", logging_openstacks)
        if logging_papertrails is not None:
            _setter("logging_papertrails", logging_papertrails)
        if logging_s3s is not None:
            _setter("logging_s3s", logging_s3s)
        if logging_scalyrs is not None:
            _setter("logging_scalyrs", logging_scalyrs)
        if logging_sftps is not None:
            _setter("logging_sftps", logging_sftps)
        if logging_splunks is not None:
            _setter("logging_splunks", logging_splunks)
        if logging_sumologics is not None:
            _setter("logging_sumologics", logging_sumologics)
        if logging_syslogs is not None:
            _setter("logging_syslogs", logging_syslogs)
        if name is not None:
            _setter("name", name)
        if package is not None:
            _setter("package", package)
        if product_enablement is not None:
            _setter("product_enablement", product_enablement)
        if resource_links is not None:
            _setter("resource_links", resource_links)
        if reuse is not None:
            _setter("reuse", reuse)
        if version_comment is not None:
            _setter("version_comment", version_comment)

    @property
    @pulumi.getter
    def domains(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceComputeDomainArgs']]]:
        """
        The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceComputeDomainArgs']]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter
    def activate(self) -> Optional[pulumi.Input[bool]]:
        """
        Conditionally prevents the Service from being activated. The apply step will continue to create a new draft version but will not activate it if this is set to `false`. Default `true`
        """
        return pulumi.get(self, "activate")

    @activate.setter
    def activate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "activate", value)

    @property
    @pulumi.getter
    def backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeBackendArgs']]]]:
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeBackendArgs']]]]):
        pulumi.set(self, "backends", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        An optional comment about the Domain.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def dictionaries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDictionaryArgs']]]]:
        return pulumi.get(self, "dictionaries")

    @dictionaries.setter
    def dictionaries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDictionaryArgs']]]]):
        pulumi.set(self, "dictionaries", value)

    @property
    @pulumi.getter(name="forceDestroy")
    def force_destroy(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        """
        return pulumi.get(self, "force_destroy")

    @force_destroy.setter
    def force_destroy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_destroy", value)

    @property
    @pulumi.getter(name="loggingBigqueries")
    def logging_bigqueries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBigqueryArgs']]]]:
        return pulumi.get(self, "logging_bigqueries")

    @logging_bigqueries.setter
    def logging_bigqueries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBigqueryArgs']]]]):
        pulumi.set(self, "logging_bigqueries", value)

    @property
    @pulumi.getter(name="loggingBlobstorages")
    def logging_blobstorages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBlobstorageArgs']]]]:
        return pulumi.get(self, "logging_blobstorages")

    @logging_blobstorages.setter
    def logging_blobstorages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBlobstorageArgs']]]]):
        pulumi.set(self, "logging_blobstorages", value)

    @property
    @pulumi.getter(name="loggingCloudfiles")
    def logging_cloudfiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingCloudfileArgs']]]]:
        return pulumi.get(self, "logging_cloudfiles")

    @logging_cloudfiles.setter
    def logging_cloudfiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingCloudfileArgs']]]]):
        pulumi.set(self, "logging_cloudfiles", value)

    @property
    @pulumi.getter(name="loggingDatadogs")
    def logging_datadogs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDatadogArgs']]]]:
        return pulumi.get(self, "logging_datadogs")

    @logging_datadogs.setter
    def logging_datadogs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDatadogArgs']]]]):
        pulumi.set(self, "logging_datadogs", value)

    @property
    @pulumi.getter(name="loggingDigitaloceans")
    def logging_digitaloceans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDigitaloceanArgs']]]]:
        return pulumi.get(self, "logging_digitaloceans")

    @logging_digitaloceans.setter
    def logging_digitaloceans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDigitaloceanArgs']]]]):
        pulumi.set(self, "logging_digitaloceans", value)

    @property
    @pulumi.getter(name="loggingElasticsearches")
    def logging_elasticsearches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingElasticsearchArgs']]]]:
        return pulumi.get(self, "logging_elasticsearches")

    @logging_elasticsearches.setter
    def logging_elasticsearches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingElasticsearchArgs']]]]):
        pulumi.set(self, "logging_elasticsearches", value)

    @property
    @pulumi.getter(name="loggingFtps")
    def logging_ftps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingFtpArgs']]]]:
        return pulumi.get(self, "logging_ftps")

    @logging_ftps.setter
    def logging_ftps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingFtpArgs']]]]):
        pulumi.set(self, "logging_ftps", value)

    @property
    @pulumi.getter(name="loggingGcs")
    def logging_gcs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGcArgs']]]]:
        return pulumi.get(self, "logging_gcs")

    @logging_gcs.setter
    def logging_gcs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGcArgs']]]]):
        pulumi.set(self, "logging_gcs", value)

    @property
    @pulumi.getter(name="loggingGooglepubsubs")
    def logging_googlepubsubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGooglepubsubArgs']]]]:
        return pulumi.get(self, "logging_googlepubsubs")

    @logging_googlepubsubs.setter
    def logging_googlepubsubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGooglepubsubArgs']]]]):
        pulumi.set(self, "logging_googlepubsubs", value)

    @property
    @pulumi.getter(name="loggingHeroku")
    def logging_heroku(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHerokuArgs']]]]:
        return pulumi.get(self, "logging_heroku")

    @logging_heroku.setter
    def logging_heroku(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHerokuArgs']]]]):
        pulumi.set(self, "logging_heroku", value)

    @property
    @pulumi.getter(name="loggingHoneycombs")
    def logging_honeycombs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHoneycombArgs']]]]:
        return pulumi.get(self, "logging_honeycombs")

    @logging_honeycombs.setter
    def logging_honeycombs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHoneycombArgs']]]]):
        pulumi.set(self, "logging_honeycombs", value)

    @property
    @pulumi.getter(name="loggingHttps")
    def logging_https(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHttpArgs']]]]:
        return pulumi.get(self, "logging_https")

    @logging_https.setter
    def logging_https(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHttpArgs']]]]):
        pulumi.set(self, "logging_https", value)

    @property
    @pulumi.getter(name="loggingKafkas")
    def logging_kafkas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKafkaArgs']]]]:
        return pulumi.get(self, "logging_kafkas")

    @logging_kafkas.setter
    def logging_kafkas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKafkaArgs']]]]):
        pulumi.set(self, "logging_kafkas", value)

    @property
    @pulumi.getter(name="loggingKineses")
    def logging_kineses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKineseArgs']]]]:
        return pulumi.get(self, "logging_kineses")

    @logging_kineses.setter
    def logging_kineses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKineseArgs']]]]):
        pulumi.set(self, "logging_kineses", value)

    @property
    @pulumi.getter(name="loggingLogentries")
    def logging_logentries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogentryArgs']]]]:
        return pulumi.get(self, "logging_logentries")

    @logging_logentries.setter
    def logging_logentries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogentryArgs']]]]):
        pulumi.set(self, "logging_logentries", value)

    @property
    @pulumi.getter(name="loggingLogglies")
    def logging_logglies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogglyArgs']]]]:
        return pulumi.get(self, "logging_logglies")

    @logging_logglies.setter
    def logging_logglies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogglyArgs']]]]):
        pulumi.set(self, "logging_logglies", value)

    @property
    @pulumi.getter(name="loggingLogshuttles")
    def logging_logshuttles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogshuttleArgs']]]]:
        return pulumi.get(self, "logging_logshuttles")

    @logging_logshuttles.setter
    def logging_logshuttles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogshuttleArgs']]]]):
        pulumi.set(self, "logging_logshuttles", value)

    @property
    @pulumi.getter(name="loggingNewrelics")
    def logging_newrelics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingNewrelicArgs']]]]:
        return pulumi.get(self, "logging_newrelics")

    @logging_newrelics.setter
    def logging_newrelics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingNewrelicArgs']]]]):
        pulumi.set(self, "logging_newrelics", value)

    @property
    @pulumi.getter(name="loggingOpenstacks")
    def logging_openstacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingOpenstackArgs']]]]:
        return pulumi.get(self, "logging_openstacks")

    @logging_openstacks.setter
    def logging_openstacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingOpenstackArgs']]]]):
        pulumi.set(self, "logging_openstacks", value)

    @property
    @pulumi.getter(name="loggingPapertrails")
    def logging_papertrails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingPapertrailArgs']]]]:
        return pulumi.get(self, "logging_papertrails")

    @logging_papertrails.setter
    def logging_papertrails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingPapertrailArgs']]]]):
        pulumi.set(self, "logging_papertrails", value)

    @property
    @pulumi.getter(name="loggingS3s")
    def logging_s3s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingS3Args']]]]:
        return pulumi.get(self, "logging_s3s")

    @logging_s3s.setter
    def logging_s3s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingS3Args']]]]):
        pulumi.set(self, "logging_s3s", value)

    @property
    @pulumi.getter(name="loggingScalyrs")
    def logging_scalyrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingScalyrArgs']]]]:
        return pulumi.get(self, "logging_scalyrs")

    @logging_scalyrs.setter
    def logging_scalyrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingScalyrArgs']]]]):
        pulumi.set(self, "logging_scalyrs", value)

    @property
    @pulumi.getter(name="loggingSftps")
    def logging_sftps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSftpArgs']]]]:
        return pulumi.get(self, "logging_sftps")

    @logging_sftps.setter
    def logging_sftps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSftpArgs']]]]):
        pulumi.set(self, "logging_sftps", value)

    @property
    @pulumi.getter(name="loggingSplunks")
    def logging_splunks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSplunkArgs']]]]:
        return pulumi.get(self, "logging_splunks")

    @logging_splunks.setter
    def logging_splunks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSplunkArgs']]]]):
        pulumi.set(self, "logging_splunks", value)

    @property
    @pulumi.getter(name="loggingSumologics")
    def logging_sumologics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSumologicArgs']]]]:
        return pulumi.get(self, "logging_sumologics")

    @logging_sumologics.setter
    def logging_sumologics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSumologicArgs']]]]):
        pulumi.set(self, "logging_sumologics", value)

    @property
    @pulumi.getter(name="loggingSyslogs")
    def logging_syslogs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSyslogArgs']]]]:
        return pulumi.get(self, "logging_syslogs")

    @logging_syslogs.setter
    def logging_syslogs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSyslogArgs']]]]):
        pulumi.set(self, "logging_syslogs", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def package(self) -> Optional[pulumi.Input['ServiceComputePackageArgs']]:
        """
        The `package` block supports uploading or modifying Wasm packages for use in a Fastly Compute@Edge service (if omitted, ensure `activate = false` is set on `ServiceCompute` to avoid service validation errors). See Fastly's documentation on [Compute@Edge](https://developer.fastly.com/learning/compute/)
        """
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: Optional[pulumi.Input['ServiceComputePackageArgs']]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter(name="productEnablement")
    def product_enablement(self) -> Optional[pulumi.Input['ServiceComputeProductEnablementArgs']]:
        return pulumi.get(self, "product_enablement")

    @product_enablement.setter
    def product_enablement(self, value: Optional[pulumi.Input['ServiceComputeProductEnablementArgs']]):
        pulumi.set(self, "product_enablement", value)

    @property
    @pulumi.getter(name="resourceLinks")
    def resource_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeResourceLinkArgs']]]]:
        """
        A resource link represents a link between a shared resource (such as an KV Store or Config Store) and a service version.
        """
        return pulumi.get(self, "resource_links")

    @resource_links.setter
    def resource_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeResourceLinkArgs']]]]):
        pulumi.set(self, "resource_links", value)

    @property
    @pulumi.getter
    def reuse(self) -> Optional[pulumi.Input[bool]]:
        """
        Services that are active cannot be destroyed. If set to `true` a service Terraform intends to destroy will instead be
        deactivated (allowing it to be reused by importing it into another Terraform project). If `false`, attempting to destroy
        an active service will cause an error. Default `false`
        """
        return pulumi.get(self, "reuse")

    @reuse.setter
    def reuse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reuse", value)

    @property
    @pulumi.getter(name="versionComment")
    def version_comment(self) -> Optional[pulumi.Input[str]]:
        """
        Description field for the version
        """
        return pulumi.get(self, "version_comment")

    @version_comment.setter
    def version_comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_comment", value)


@pulumi.input_type
class _ServiceComputeState:
    def __init__(__self__, *,
                 activate: Optional[pulumi.Input[bool]] = None,
                 active_version: Optional[pulumi.Input[int]] = None,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeBackendArgs']]]] = None,
                 cloned_version: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 dictionaries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDictionaryArgs']]]] = None,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDomainArgs']]]] = None,
                 force_destroy: Optional[pulumi.Input[bool]] = None,
                 force_refresh: Optional[pulumi.Input[bool]] = None,
                 imported: Optional[pulumi.Input[bool]] = None,
                 logging_bigqueries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBigqueryArgs']]]] = None,
                 logging_blobstorages: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBlobstorageArgs']]]] = None,
                 logging_cloudfiles: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingCloudfileArgs']]]] = None,
                 logging_datadogs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDatadogArgs']]]] = None,
                 logging_digitaloceans: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDigitaloceanArgs']]]] = None,
                 logging_elasticsearches: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingElasticsearchArgs']]]] = None,
                 logging_ftps: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingFtpArgs']]]] = None,
                 logging_gcs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGcArgs']]]] = None,
                 logging_googlepubsubs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGooglepubsubArgs']]]] = None,
                 logging_heroku: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHerokuArgs']]]] = None,
                 logging_honeycombs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHoneycombArgs']]]] = None,
                 logging_https: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHttpArgs']]]] = None,
                 logging_kafkas: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKafkaArgs']]]] = None,
                 logging_kineses: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKineseArgs']]]] = None,
                 logging_logentries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogentryArgs']]]] = None,
                 logging_logglies: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogglyArgs']]]] = None,
                 logging_logshuttles: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogshuttleArgs']]]] = None,
                 logging_newrelics: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingNewrelicArgs']]]] = None,
                 logging_openstacks: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingOpenstackArgs']]]] = None,
                 logging_papertrails: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingPapertrailArgs']]]] = None,
                 logging_s3s: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingS3Args']]]] = None,
                 logging_scalyrs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingScalyrArgs']]]] = None,
                 logging_sftps: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSftpArgs']]]] = None,
                 logging_splunks: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSplunkArgs']]]] = None,
                 logging_sumologics: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSumologicArgs']]]] = None,
                 logging_syslogs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSyslogArgs']]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 package: Optional[pulumi.Input['ServiceComputePackageArgs']] = None,
                 product_enablement: Optional[pulumi.Input['ServiceComputeProductEnablementArgs']] = None,
                 resource_links: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeResourceLinkArgs']]]] = None,
                 reuse: Optional[pulumi.Input[bool]] = None,
                 version_comment: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering ServiceCompute resources.
        :param pulumi.Input[bool] activate: Conditionally prevents the Service from being activated. The apply step will continue to create a new draft version but will not activate it if this is set to `false`. Default `true`
        :param pulumi.Input[int] active_version: The currently active version of your Fastly Service
        :param pulumi.Input[int] cloned_version: The latest cloned version by the provider
        :param pulumi.Input[str] comment: An optional comment about the Domain.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceComputeDomainArgs']]] domains: The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        :param pulumi.Input[bool] force_destroy: Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        :param pulumi.Input[bool] force_refresh: Used internally by the provider to temporarily indicate if all resources should call their associated API to update the
               local state. This is for scenarios where the service version has been reverted outside of Terraform (e.g. via the Fastly
               UI) and the provider needs to resync the state for a different active version (this is only if `activate` is `true`).
        :param pulumi.Input[bool] imported: Used internally by the provider to temporarily indicate if the service is being imported, and is reset to false once the import is finished
        :param pulumi.Input[str] name: Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input['ServiceComputePackageArgs'] package: The `package` block supports uploading or modifying Wasm packages for use in a Fastly Compute@Edge service (if omitted, ensure `activate = false` is set on `ServiceCompute` to avoid service validation errors). See Fastly's documentation on [Compute@Edge](https://developer.fastly.com/learning/compute/)
        :param pulumi.Input[Sequence[pulumi.Input['ServiceComputeResourceLinkArgs']]] resource_links: A resource link represents a link between a shared resource (such as an KV Store or Config Store) and a service version.
        :param pulumi.Input[bool] reuse: Services that are active cannot be destroyed. If set to `true` a service Terraform intends to destroy will instead be
               deactivated (allowing it to be reused by importing it into another Terraform project). If `false`, attempting to destroy
               an active service will cause an error. Default `false`
        :param pulumi.Input[str] version_comment: Description field for the version
        """
        _ServiceComputeState._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            activate=activate,
            active_version=active_version,
            backends=backends,
            cloned_version=cloned_version,
            comment=comment,
            dictionaries=dictionaries,
            domains=domains,
            force_destroy=force_destroy,
            force_refresh=force_refresh,
            imported=imported,
            logging_bigqueries=logging_bigqueries,
            logging_blobstorages=logging_blobstorages,
            logging_cloudfiles=logging_cloudfiles,
            logging_datadogs=logging_datadogs,
            logging_digitaloceans=logging_digitaloceans,
            logging_elasticsearches=logging_elasticsearches,
            logging_ftps=logging_ftps,
            logging_gcs=logging_gcs,
            logging_googlepubsubs=logging_googlepubsubs,
            logging_heroku=logging_heroku,
            logging_honeycombs=logging_honeycombs,
            logging_https=logging_https,
            logging_kafkas=logging_kafkas,
            logging_kineses=logging_kineses,
            logging_logentries=logging_logentries,
            logging_logglies=logging_logglies,
            logging_logshuttles=logging_logshuttles,
            logging_newrelics=logging_newrelics,
            logging_openstacks=logging_openstacks,
            logging_papertrails=logging_papertrails,
            logging_s3s=logging_s3s,
            logging_scalyrs=logging_scalyrs,
            logging_sftps=logging_sftps,
            logging_splunks=logging_splunks,
            logging_sumologics=logging_sumologics,
            logging_syslogs=logging_syslogs,
            name=name,
            package=package,
            product_enablement=product_enablement,
            resource_links=resource_links,
            reuse=reuse,
            version_comment=version_comment,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             activate: Optional[pulumi.Input[bool]] = None,
             active_version: Optional[pulumi.Input[int]] = None,
             backends: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeBackendArgs']]]] = None,
             cloned_version: Optional[pulumi.Input[int]] = None,
             comment: Optional[pulumi.Input[str]] = None,
             dictionaries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDictionaryArgs']]]] = None,
             domains: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDomainArgs']]]] = None,
             force_destroy: Optional[pulumi.Input[bool]] = None,
             force_refresh: Optional[pulumi.Input[bool]] = None,
             imported: Optional[pulumi.Input[bool]] = None,
             logging_bigqueries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBigqueryArgs']]]] = None,
             logging_blobstorages: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBlobstorageArgs']]]] = None,
             logging_cloudfiles: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingCloudfileArgs']]]] = None,
             logging_datadogs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDatadogArgs']]]] = None,
             logging_digitaloceans: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDigitaloceanArgs']]]] = None,
             logging_elasticsearches: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingElasticsearchArgs']]]] = None,
             logging_ftps: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingFtpArgs']]]] = None,
             logging_gcs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGcArgs']]]] = None,
             logging_googlepubsubs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGooglepubsubArgs']]]] = None,
             logging_heroku: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHerokuArgs']]]] = None,
             logging_honeycombs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHoneycombArgs']]]] = None,
             logging_https: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHttpArgs']]]] = None,
             logging_kafkas: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKafkaArgs']]]] = None,
             logging_kineses: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKineseArgs']]]] = None,
             logging_logentries: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogentryArgs']]]] = None,
             logging_logglies: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogglyArgs']]]] = None,
             logging_logshuttles: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogshuttleArgs']]]] = None,
             logging_newrelics: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingNewrelicArgs']]]] = None,
             logging_openstacks: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingOpenstackArgs']]]] = None,
             logging_papertrails: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingPapertrailArgs']]]] = None,
             logging_s3s: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingS3Args']]]] = None,
             logging_scalyrs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingScalyrArgs']]]] = None,
             logging_sftps: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSftpArgs']]]] = None,
             logging_splunks: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSplunkArgs']]]] = None,
             logging_sumologics: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSumologicArgs']]]] = None,
             logging_syslogs: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSyslogArgs']]]] = None,
             name: Optional[pulumi.Input[str]] = None,
             package: Optional[pulumi.Input['ServiceComputePackageArgs']] = None,
             product_enablement: Optional[pulumi.Input['ServiceComputeProductEnablementArgs']] = None,
             resource_links: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeResourceLinkArgs']]]] = None,
             reuse: Optional[pulumi.Input[bool]] = None,
             version_comment: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if activate is not None:
            _setter("activate", activate)
        if active_version is not None:
            _setter("active_version", active_version)
        if backends is not None:
            _setter("backends", backends)
        if cloned_version is not None:
            _setter("cloned_version", cloned_version)
        if comment is not None:
            _setter("comment", comment)
        if dictionaries is not None:
            _setter("dictionaries", dictionaries)
        if domains is not None:
            _setter("domains", domains)
        if force_destroy is not None:
            _setter("force_destroy", force_destroy)
        if force_refresh is not None:
            _setter("force_refresh", force_refresh)
        if imported is not None:
            _setter("imported", imported)
        if logging_bigqueries is not None:
            _setter("logging_bigqueries", logging_bigqueries)
        if logging_blobstorages is not None:
            _setter("logging_blobstorages", logging_blobstorages)
        if logging_cloudfiles is not None:
            _setter("logging_cloudfiles", logging_cloudfiles)
        if logging_datadogs is not None:
            _setter("logging_datadogs", logging_datadogs)
        if logging_digitaloceans is not None:
            _setter("logging_digitaloceans", logging_digitaloceans)
        if logging_elasticsearches is not None:
            _setter("logging_elasticsearches", logging_elasticsearches)
        if logging_ftps is not None:
            _setter("logging_ftps", logging_ftps)
        if logging_gcs is not None:
            _setter("logging_gcs", logging_gcs)
        if logging_googlepubsubs is not None:
            _setter("logging_googlepubsubs", logging_googlepubsubs)
        if logging_heroku is not None:
            _setter("logging_heroku", logging_heroku)
        if logging_honeycombs is not None:
            _setter("logging_honeycombs", logging_honeycombs)
        if logging_https is not None:
            _setter("logging_https", logging_https)
        if logging_kafkas is not None:
            _setter("logging_kafkas", logging_kafkas)
        if logging_kineses is not None:
            _setter("logging_kineses", logging_kineses)
        if logging_logentries is not None:
            _setter("logging_logentries", logging_logentries)
        if logging_logglies is not None:
            _setter("logging_logglies", logging_logglies)
        if logging_logshuttles is not None:
            _setter("logging_logshuttles", logging_logshuttles)
        if logging_newrelics is not None:
            _setter("logging_newrelics", logging_newrelics)
        if logging_openstacks is not None:
            _setter("logging_openstacks", logging_openstacks)
        if logging_papertrails is not None:
            _setter("logging_papertrails", logging_papertrails)
        if logging_s3s is not None:
            _setter("logging_s3s", logging_s3s)
        if logging_scalyrs is not None:
            _setter("logging_scalyrs", logging_scalyrs)
        if logging_sftps is not None:
            _setter("logging_sftps", logging_sftps)
        if logging_splunks is not None:
            _setter("logging_splunks", logging_splunks)
        if logging_sumologics is not None:
            _setter("logging_sumologics", logging_sumologics)
        if logging_syslogs is not None:
            _setter("logging_syslogs", logging_syslogs)
        if name is not None:
            _setter("name", name)
        if package is not None:
            _setter("package", package)
        if product_enablement is not None:
            _setter("product_enablement", product_enablement)
        if resource_links is not None:
            _setter("resource_links", resource_links)
        if reuse is not None:
            _setter("reuse", reuse)
        if version_comment is not None:
            _setter("version_comment", version_comment)

    @property
    @pulumi.getter
    def activate(self) -> Optional[pulumi.Input[bool]]:
        """
        Conditionally prevents the Service from being activated. The apply step will continue to create a new draft version but will not activate it if this is set to `false`. Default `true`
        """
        return pulumi.get(self, "activate")

    @activate.setter
    def activate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "activate", value)

    @property
    @pulumi.getter(name="activeVersion")
    def active_version(self) -> Optional[pulumi.Input[int]]:
        """
        The currently active version of your Fastly Service
        """
        return pulumi.get(self, "active_version")

    @active_version.setter
    def active_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "active_version", value)

    @property
    @pulumi.getter
    def backends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeBackendArgs']]]]:
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeBackendArgs']]]]):
        pulumi.set(self, "backends", value)

    @property
    @pulumi.getter(name="clonedVersion")
    def cloned_version(self) -> Optional[pulumi.Input[int]]:
        """
        The latest cloned version by the provider
        """
        return pulumi.get(self, "cloned_version")

    @cloned_version.setter
    def cloned_version(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cloned_version", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        """
        An optional comment about the Domain.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def dictionaries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDictionaryArgs']]]]:
        return pulumi.get(self, "dictionaries")

    @dictionaries.setter
    def dictionaries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDictionaryArgs']]]]):
        pulumi.set(self, "dictionaries", value)

    @property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDomainArgs']]]]:
        """
        The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeDomainArgs']]]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter(name="forceDestroy")
    def force_destroy(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        """
        return pulumi.get(self, "force_destroy")

    @force_destroy.setter
    def force_destroy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_destroy", value)

    @property
    @pulumi.getter(name="forceRefresh")
    def force_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        Used internally by the provider to temporarily indicate if all resources should call their associated API to update the
        local state. This is for scenarios where the service version has been reverted outside of Terraform (e.g. via the Fastly
        UI) and the provider needs to resync the state for a different active version (this is only if `activate` is `true`).
        """
        return pulumi.get(self, "force_refresh")

    @force_refresh.setter
    def force_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_refresh", value)

    @property
    @pulumi.getter
    def imported(self) -> Optional[pulumi.Input[bool]]:
        """
        Used internally by the provider to temporarily indicate if the service is being imported, and is reset to false once the import is finished
        """
        return pulumi.get(self, "imported")

    @imported.setter
    def imported(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "imported", value)

    @property
    @pulumi.getter(name="loggingBigqueries")
    def logging_bigqueries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBigqueryArgs']]]]:
        return pulumi.get(self, "logging_bigqueries")

    @logging_bigqueries.setter
    def logging_bigqueries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBigqueryArgs']]]]):
        pulumi.set(self, "logging_bigqueries", value)

    @property
    @pulumi.getter(name="loggingBlobstorages")
    def logging_blobstorages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBlobstorageArgs']]]]:
        return pulumi.get(self, "logging_blobstorages")

    @logging_blobstorages.setter
    def logging_blobstorages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingBlobstorageArgs']]]]):
        pulumi.set(self, "logging_blobstorages", value)

    @property
    @pulumi.getter(name="loggingCloudfiles")
    def logging_cloudfiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingCloudfileArgs']]]]:
        return pulumi.get(self, "logging_cloudfiles")

    @logging_cloudfiles.setter
    def logging_cloudfiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingCloudfileArgs']]]]):
        pulumi.set(self, "logging_cloudfiles", value)

    @property
    @pulumi.getter(name="loggingDatadogs")
    def logging_datadogs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDatadogArgs']]]]:
        return pulumi.get(self, "logging_datadogs")

    @logging_datadogs.setter
    def logging_datadogs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDatadogArgs']]]]):
        pulumi.set(self, "logging_datadogs", value)

    @property
    @pulumi.getter(name="loggingDigitaloceans")
    def logging_digitaloceans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDigitaloceanArgs']]]]:
        return pulumi.get(self, "logging_digitaloceans")

    @logging_digitaloceans.setter
    def logging_digitaloceans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingDigitaloceanArgs']]]]):
        pulumi.set(self, "logging_digitaloceans", value)

    @property
    @pulumi.getter(name="loggingElasticsearches")
    def logging_elasticsearches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingElasticsearchArgs']]]]:
        return pulumi.get(self, "logging_elasticsearches")

    @logging_elasticsearches.setter
    def logging_elasticsearches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingElasticsearchArgs']]]]):
        pulumi.set(self, "logging_elasticsearches", value)

    @property
    @pulumi.getter(name="loggingFtps")
    def logging_ftps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingFtpArgs']]]]:
        return pulumi.get(self, "logging_ftps")

    @logging_ftps.setter
    def logging_ftps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingFtpArgs']]]]):
        pulumi.set(self, "logging_ftps", value)

    @property
    @pulumi.getter(name="loggingGcs")
    def logging_gcs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGcArgs']]]]:
        return pulumi.get(self, "logging_gcs")

    @logging_gcs.setter
    def logging_gcs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGcArgs']]]]):
        pulumi.set(self, "logging_gcs", value)

    @property
    @pulumi.getter(name="loggingGooglepubsubs")
    def logging_googlepubsubs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGooglepubsubArgs']]]]:
        return pulumi.get(self, "logging_googlepubsubs")

    @logging_googlepubsubs.setter
    def logging_googlepubsubs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingGooglepubsubArgs']]]]):
        pulumi.set(self, "logging_googlepubsubs", value)

    @property
    @pulumi.getter(name="loggingHeroku")
    def logging_heroku(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHerokuArgs']]]]:
        return pulumi.get(self, "logging_heroku")

    @logging_heroku.setter
    def logging_heroku(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHerokuArgs']]]]):
        pulumi.set(self, "logging_heroku", value)

    @property
    @pulumi.getter(name="loggingHoneycombs")
    def logging_honeycombs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHoneycombArgs']]]]:
        return pulumi.get(self, "logging_honeycombs")

    @logging_honeycombs.setter
    def logging_honeycombs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHoneycombArgs']]]]):
        pulumi.set(self, "logging_honeycombs", value)

    @property
    @pulumi.getter(name="loggingHttps")
    def logging_https(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHttpArgs']]]]:
        return pulumi.get(self, "logging_https")

    @logging_https.setter
    def logging_https(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingHttpArgs']]]]):
        pulumi.set(self, "logging_https", value)

    @property
    @pulumi.getter(name="loggingKafkas")
    def logging_kafkas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKafkaArgs']]]]:
        return pulumi.get(self, "logging_kafkas")

    @logging_kafkas.setter
    def logging_kafkas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKafkaArgs']]]]):
        pulumi.set(self, "logging_kafkas", value)

    @property
    @pulumi.getter(name="loggingKineses")
    def logging_kineses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKineseArgs']]]]:
        return pulumi.get(self, "logging_kineses")

    @logging_kineses.setter
    def logging_kineses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingKineseArgs']]]]):
        pulumi.set(self, "logging_kineses", value)

    @property
    @pulumi.getter(name="loggingLogentries")
    def logging_logentries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogentryArgs']]]]:
        return pulumi.get(self, "logging_logentries")

    @logging_logentries.setter
    def logging_logentries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogentryArgs']]]]):
        pulumi.set(self, "logging_logentries", value)

    @property
    @pulumi.getter(name="loggingLogglies")
    def logging_logglies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogglyArgs']]]]:
        return pulumi.get(self, "logging_logglies")

    @logging_logglies.setter
    def logging_logglies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogglyArgs']]]]):
        pulumi.set(self, "logging_logglies", value)

    @property
    @pulumi.getter(name="loggingLogshuttles")
    def logging_logshuttles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogshuttleArgs']]]]:
        return pulumi.get(self, "logging_logshuttles")

    @logging_logshuttles.setter
    def logging_logshuttles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingLogshuttleArgs']]]]):
        pulumi.set(self, "logging_logshuttles", value)

    @property
    @pulumi.getter(name="loggingNewrelics")
    def logging_newrelics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingNewrelicArgs']]]]:
        return pulumi.get(self, "logging_newrelics")

    @logging_newrelics.setter
    def logging_newrelics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingNewrelicArgs']]]]):
        pulumi.set(self, "logging_newrelics", value)

    @property
    @pulumi.getter(name="loggingOpenstacks")
    def logging_openstacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingOpenstackArgs']]]]:
        return pulumi.get(self, "logging_openstacks")

    @logging_openstacks.setter
    def logging_openstacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingOpenstackArgs']]]]):
        pulumi.set(self, "logging_openstacks", value)

    @property
    @pulumi.getter(name="loggingPapertrails")
    def logging_papertrails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingPapertrailArgs']]]]:
        return pulumi.get(self, "logging_papertrails")

    @logging_papertrails.setter
    def logging_papertrails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingPapertrailArgs']]]]):
        pulumi.set(self, "logging_papertrails", value)

    @property
    @pulumi.getter(name="loggingS3s")
    def logging_s3s(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingS3Args']]]]:
        return pulumi.get(self, "logging_s3s")

    @logging_s3s.setter
    def logging_s3s(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingS3Args']]]]):
        pulumi.set(self, "logging_s3s", value)

    @property
    @pulumi.getter(name="loggingScalyrs")
    def logging_scalyrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingScalyrArgs']]]]:
        return pulumi.get(self, "logging_scalyrs")

    @logging_scalyrs.setter
    def logging_scalyrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingScalyrArgs']]]]):
        pulumi.set(self, "logging_scalyrs", value)

    @property
    @pulumi.getter(name="loggingSftps")
    def logging_sftps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSftpArgs']]]]:
        return pulumi.get(self, "logging_sftps")

    @logging_sftps.setter
    def logging_sftps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSftpArgs']]]]):
        pulumi.set(self, "logging_sftps", value)

    @property
    @pulumi.getter(name="loggingSplunks")
    def logging_splunks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSplunkArgs']]]]:
        return pulumi.get(self, "logging_splunks")

    @logging_splunks.setter
    def logging_splunks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSplunkArgs']]]]):
        pulumi.set(self, "logging_splunks", value)

    @property
    @pulumi.getter(name="loggingSumologics")
    def logging_sumologics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSumologicArgs']]]]:
        return pulumi.get(self, "logging_sumologics")

    @logging_sumologics.setter
    def logging_sumologics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSumologicArgs']]]]):
        pulumi.set(self, "logging_sumologics", value)

    @property
    @pulumi.getter(name="loggingSyslogs")
    def logging_syslogs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSyslogArgs']]]]:
        return pulumi.get(self, "logging_syslogs")

    @logging_syslogs.setter
    def logging_syslogs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeLoggingSyslogArgs']]]]):
        pulumi.set(self, "logging_syslogs", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def package(self) -> Optional[pulumi.Input['ServiceComputePackageArgs']]:
        """
        The `package` block supports uploading or modifying Wasm packages for use in a Fastly Compute@Edge service (if omitted, ensure `activate = false` is set on `ServiceCompute` to avoid service validation errors). See Fastly's documentation on [Compute@Edge](https://developer.fastly.com/learning/compute/)
        """
        return pulumi.get(self, "package")

    @package.setter
    def package(self, value: Optional[pulumi.Input['ServiceComputePackageArgs']]):
        pulumi.set(self, "package", value)

    @property
    @pulumi.getter(name="productEnablement")
    def product_enablement(self) -> Optional[pulumi.Input['ServiceComputeProductEnablementArgs']]:
        return pulumi.get(self, "product_enablement")

    @product_enablement.setter
    def product_enablement(self, value: Optional[pulumi.Input['ServiceComputeProductEnablementArgs']]):
        pulumi.set(self, "product_enablement", value)

    @property
    @pulumi.getter(name="resourceLinks")
    def resource_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeResourceLinkArgs']]]]:
        """
        A resource link represents a link between a shared resource (such as an KV Store or Config Store) and a service version.
        """
        return pulumi.get(self, "resource_links")

    @resource_links.setter
    def resource_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceComputeResourceLinkArgs']]]]):
        pulumi.set(self, "resource_links", value)

    @property
    @pulumi.getter
    def reuse(self) -> Optional[pulumi.Input[bool]]:
        """
        Services that are active cannot be destroyed. If set to `true` a service Terraform intends to destroy will instead be
        deactivated (allowing it to be reused by importing it into another Terraform project). If `false`, attempting to destroy
        an active service will cause an error. Default `false`
        """
        return pulumi.get(self, "reuse")

    @reuse.setter
    def reuse(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reuse", value)

    @property
    @pulumi.getter(name="versionComment")
    def version_comment(self) -> Optional[pulumi.Input[str]]:
        """
        Description field for the version
        """
        return pulumi.get(self, "version_comment")

    @version_comment.setter
    def version_comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version_comment", value)


class ServiceCompute(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 activate: Optional[pulumi.Input[bool]] = None,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeBackendArgs']]]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 dictionaries: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeDictionaryArgs']]]]] = None,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeDomainArgs']]]]] = None,
                 force_destroy: Optional[pulumi.Input[bool]] = None,
                 logging_bigqueries: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingBigqueryArgs']]]]] = None,
                 logging_blobstorages: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingBlobstorageArgs']]]]] = None,
                 logging_cloudfiles: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingCloudfileArgs']]]]] = None,
                 logging_datadogs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingDatadogArgs']]]]] = None,
                 logging_digitaloceans: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingDigitaloceanArgs']]]]] = None,
                 logging_elasticsearches: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingElasticsearchArgs']]]]] = None,
                 logging_ftps: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingFtpArgs']]]]] = None,
                 logging_gcs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingGcArgs']]]]] = None,
                 logging_googlepubsubs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingGooglepubsubArgs']]]]] = None,
                 logging_heroku: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingHerokuArgs']]]]] = None,
                 logging_honeycombs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingHoneycombArgs']]]]] = None,
                 logging_https: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingHttpArgs']]]]] = None,
                 logging_kafkas: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingKafkaArgs']]]]] = None,
                 logging_kineses: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingKineseArgs']]]]] = None,
                 logging_logentries: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingLogentryArgs']]]]] = None,
                 logging_logglies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingLogglyArgs']]]]] = None,
                 logging_logshuttles: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingLogshuttleArgs']]]]] = None,
                 logging_newrelics: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingNewrelicArgs']]]]] = None,
                 logging_openstacks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingOpenstackArgs']]]]] = None,
                 logging_papertrails: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingPapertrailArgs']]]]] = None,
                 logging_s3s: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingS3Args']]]]] = None,
                 logging_scalyrs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingScalyrArgs']]]]] = None,
                 logging_sftps: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSftpArgs']]]]] = None,
                 logging_splunks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSplunkArgs']]]]] = None,
                 logging_sumologics: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSumologicArgs']]]]] = None,
                 logging_syslogs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSyslogArgs']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 package: Optional[pulumi.Input[pulumi.InputType['ServiceComputePackageArgs']]] = None,
                 product_enablement: Optional[pulumi.Input[pulumi.InputType['ServiceComputeProductEnablementArgs']]] = None,
                 resource_links: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeResourceLinkArgs']]]]] = None,
                 reuse: Optional[pulumi.Input[bool]] = None,
                 version_comment: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        ## Import

        Fastly Services can be imported using their service ID, e.g.

        ```sh
         $ pulumi import fastly:index/serviceCompute:ServiceCompute demo xxxxxxxxxxxxxxxxxxxx
        ```

         By default, either the active version will be imported, or the latest version if no version is active. Alternatively, a specific version of the service can be selected by appending an `@` followed by the version number to the service ID, e.g.

        ```sh
         $ pulumi import fastly:index/serviceCompute:ServiceCompute demo xxxxxxxxxxxxxxxxxxxx@2
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] activate: Conditionally prevents the Service from being activated. The apply step will continue to create a new draft version but will not activate it if this is set to `false`. Default `true`
        :param pulumi.Input[str] comment: An optional comment about the Domain.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeDomainArgs']]]] domains: The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        :param pulumi.Input[bool] force_destroy: Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        :param pulumi.Input[str] name: Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[pulumi.InputType['ServiceComputePackageArgs']] package: The `package` block supports uploading or modifying Wasm packages for use in a Fastly Compute@Edge service (if omitted, ensure `activate = false` is set on `ServiceCompute` to avoid service validation errors). See Fastly's documentation on [Compute@Edge](https://developer.fastly.com/learning/compute/)
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeResourceLinkArgs']]]] resource_links: A resource link represents a link between a shared resource (such as an KV Store or Config Store) and a service version.
        :param pulumi.Input[bool] reuse: Services that are active cannot be destroyed. If set to `true` a service Terraform intends to destroy will instead be
               deactivated (allowing it to be reused by importing it into another Terraform project). If `false`, attempting to destroy
               an active service will cause an error. Default `false`
        :param pulumi.Input[str] version_comment: Description field for the version
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ServiceComputeArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Import

        Fastly Services can be imported using their service ID, e.g.

        ```sh
         $ pulumi import fastly:index/serviceCompute:ServiceCompute demo xxxxxxxxxxxxxxxxxxxx
        ```

         By default, either the active version will be imported, or the latest version if no version is active. Alternatively, a specific version of the service can be selected by appending an `@` followed by the version number to the service ID, e.g.

        ```sh
         $ pulumi import fastly:index/serviceCompute:ServiceCompute demo xxxxxxxxxxxxxxxxxxxx@2
        ```

        :param str resource_name: The name of the resource.
        :param ServiceComputeArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ServiceComputeArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            kwargs = kwargs or {}
            def _setter(key, value):
                kwargs[key] = value
            ServiceComputeArgs._configure(_setter, **kwargs)
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 activate: Optional[pulumi.Input[bool]] = None,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeBackendArgs']]]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 dictionaries: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeDictionaryArgs']]]]] = None,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeDomainArgs']]]]] = None,
                 force_destroy: Optional[pulumi.Input[bool]] = None,
                 logging_bigqueries: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingBigqueryArgs']]]]] = None,
                 logging_blobstorages: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingBlobstorageArgs']]]]] = None,
                 logging_cloudfiles: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingCloudfileArgs']]]]] = None,
                 logging_datadogs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingDatadogArgs']]]]] = None,
                 logging_digitaloceans: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingDigitaloceanArgs']]]]] = None,
                 logging_elasticsearches: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingElasticsearchArgs']]]]] = None,
                 logging_ftps: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingFtpArgs']]]]] = None,
                 logging_gcs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingGcArgs']]]]] = None,
                 logging_googlepubsubs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingGooglepubsubArgs']]]]] = None,
                 logging_heroku: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingHerokuArgs']]]]] = None,
                 logging_honeycombs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingHoneycombArgs']]]]] = None,
                 logging_https: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingHttpArgs']]]]] = None,
                 logging_kafkas: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingKafkaArgs']]]]] = None,
                 logging_kineses: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingKineseArgs']]]]] = None,
                 logging_logentries: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingLogentryArgs']]]]] = None,
                 logging_logglies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingLogglyArgs']]]]] = None,
                 logging_logshuttles: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingLogshuttleArgs']]]]] = None,
                 logging_newrelics: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingNewrelicArgs']]]]] = None,
                 logging_openstacks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingOpenstackArgs']]]]] = None,
                 logging_papertrails: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingPapertrailArgs']]]]] = None,
                 logging_s3s: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingS3Args']]]]] = None,
                 logging_scalyrs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingScalyrArgs']]]]] = None,
                 logging_sftps: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSftpArgs']]]]] = None,
                 logging_splunks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSplunkArgs']]]]] = None,
                 logging_sumologics: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSumologicArgs']]]]] = None,
                 logging_syslogs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSyslogArgs']]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 package: Optional[pulumi.Input[pulumi.InputType['ServiceComputePackageArgs']]] = None,
                 product_enablement: Optional[pulumi.Input[pulumi.InputType['ServiceComputeProductEnablementArgs']]] = None,
                 resource_links: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeResourceLinkArgs']]]]] = None,
                 reuse: Optional[pulumi.Input[bool]] = None,
                 version_comment: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ServiceComputeArgs.__new__(ServiceComputeArgs)

            __props__.__dict__["activate"] = activate
            __props__.__dict__["backends"] = backends
            __props__.__dict__["comment"] = comment
            __props__.__dict__["dictionaries"] = dictionaries
            if domains is None and not opts.urn:
                raise TypeError("Missing required property 'domains'")
            __props__.__dict__["domains"] = domains
            __props__.__dict__["force_destroy"] = force_destroy
            __props__.__dict__["logging_bigqueries"] = logging_bigqueries
            __props__.__dict__["logging_blobstorages"] = logging_blobstorages
            __props__.__dict__["logging_cloudfiles"] = logging_cloudfiles
            __props__.__dict__["logging_datadogs"] = logging_datadogs
            __props__.__dict__["logging_digitaloceans"] = logging_digitaloceans
            __props__.__dict__["logging_elasticsearches"] = logging_elasticsearches
            __props__.__dict__["logging_ftps"] = logging_ftps
            __props__.__dict__["logging_gcs"] = logging_gcs
            __props__.__dict__["logging_googlepubsubs"] = logging_googlepubsubs
            __props__.__dict__["logging_heroku"] = logging_heroku
            __props__.__dict__["logging_honeycombs"] = logging_honeycombs
            __props__.__dict__["logging_https"] = logging_https
            __props__.__dict__["logging_kafkas"] = logging_kafkas
            __props__.__dict__["logging_kineses"] = logging_kineses
            __props__.__dict__["logging_logentries"] = logging_logentries
            __props__.__dict__["logging_logglies"] = logging_logglies
            __props__.__dict__["logging_logshuttles"] = logging_logshuttles
            __props__.__dict__["logging_newrelics"] = logging_newrelics
            __props__.__dict__["logging_openstacks"] = logging_openstacks
            __props__.__dict__["logging_papertrails"] = logging_papertrails
            __props__.__dict__["logging_s3s"] = logging_s3s
            __props__.__dict__["logging_scalyrs"] = logging_scalyrs
            __props__.__dict__["logging_sftps"] = logging_sftps
            __props__.__dict__["logging_splunks"] = logging_splunks
            __props__.__dict__["logging_sumologics"] = logging_sumologics
            __props__.__dict__["logging_syslogs"] = logging_syslogs
            __props__.__dict__["name"] = name
            if package is not None and not isinstance(package, ServiceComputePackageArgs):
                package = package or {}
                def _setter(key, value):
                    package[key] = value
                ServiceComputePackageArgs._configure(_setter, **package)
            __props__.__dict__["package"] = package
            if product_enablement is not None and not isinstance(product_enablement, ServiceComputeProductEnablementArgs):
                product_enablement = product_enablement or {}
                def _setter(key, value):
                    product_enablement[key] = value
                ServiceComputeProductEnablementArgs._configure(_setter, **product_enablement)
            __props__.__dict__["product_enablement"] = product_enablement
            __props__.__dict__["resource_links"] = resource_links
            __props__.__dict__["reuse"] = reuse
            __props__.__dict__["version_comment"] = version_comment
            __props__.__dict__["active_version"] = None
            __props__.__dict__["cloned_version"] = None
            __props__.__dict__["force_refresh"] = None
            __props__.__dict__["imported"] = None
        super(ServiceCompute, __self__).__init__(
            'fastly:index/serviceCompute:ServiceCompute',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            activate: Optional[pulumi.Input[bool]] = None,
            active_version: Optional[pulumi.Input[int]] = None,
            backends: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeBackendArgs']]]]] = None,
            cloned_version: Optional[pulumi.Input[int]] = None,
            comment: Optional[pulumi.Input[str]] = None,
            dictionaries: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeDictionaryArgs']]]]] = None,
            domains: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeDomainArgs']]]]] = None,
            force_destroy: Optional[pulumi.Input[bool]] = None,
            force_refresh: Optional[pulumi.Input[bool]] = None,
            imported: Optional[pulumi.Input[bool]] = None,
            logging_bigqueries: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingBigqueryArgs']]]]] = None,
            logging_blobstorages: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingBlobstorageArgs']]]]] = None,
            logging_cloudfiles: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingCloudfileArgs']]]]] = None,
            logging_datadogs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingDatadogArgs']]]]] = None,
            logging_digitaloceans: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingDigitaloceanArgs']]]]] = None,
            logging_elasticsearches: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingElasticsearchArgs']]]]] = None,
            logging_ftps: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingFtpArgs']]]]] = None,
            logging_gcs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingGcArgs']]]]] = None,
            logging_googlepubsubs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingGooglepubsubArgs']]]]] = None,
            logging_heroku: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingHerokuArgs']]]]] = None,
            logging_honeycombs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingHoneycombArgs']]]]] = None,
            logging_https: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingHttpArgs']]]]] = None,
            logging_kafkas: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingKafkaArgs']]]]] = None,
            logging_kineses: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingKineseArgs']]]]] = None,
            logging_logentries: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingLogentryArgs']]]]] = None,
            logging_logglies: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingLogglyArgs']]]]] = None,
            logging_logshuttles: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingLogshuttleArgs']]]]] = None,
            logging_newrelics: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingNewrelicArgs']]]]] = None,
            logging_openstacks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingOpenstackArgs']]]]] = None,
            logging_papertrails: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingPapertrailArgs']]]]] = None,
            logging_s3s: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingS3Args']]]]] = None,
            logging_scalyrs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingScalyrArgs']]]]] = None,
            logging_sftps: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSftpArgs']]]]] = None,
            logging_splunks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSplunkArgs']]]]] = None,
            logging_sumologics: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSumologicArgs']]]]] = None,
            logging_syslogs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeLoggingSyslogArgs']]]]] = None,
            name: Optional[pulumi.Input[str]] = None,
            package: Optional[pulumi.Input[pulumi.InputType['ServiceComputePackageArgs']]] = None,
            product_enablement: Optional[pulumi.Input[pulumi.InputType['ServiceComputeProductEnablementArgs']]] = None,
            resource_links: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeResourceLinkArgs']]]]] = None,
            reuse: Optional[pulumi.Input[bool]] = None,
            version_comment: Optional[pulumi.Input[str]] = None) -> 'ServiceCompute':
        """
        Get an existing ServiceCompute resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[bool] activate: Conditionally prevents the Service from being activated. The apply step will continue to create a new draft version but will not activate it if this is set to `false`. Default `true`
        :param pulumi.Input[int] active_version: The currently active version of your Fastly Service
        :param pulumi.Input[int] cloned_version: The latest cloned version by the provider
        :param pulumi.Input[str] comment: An optional comment about the Domain.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeDomainArgs']]]] domains: The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        :param pulumi.Input[bool] force_destroy: Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        :param pulumi.Input[bool] force_refresh: Used internally by the provider to temporarily indicate if all resources should call their associated API to update the
               local state. This is for scenarios where the service version has been reverted outside of Terraform (e.g. via the Fastly
               UI) and the provider needs to resync the state for a different active version (this is only if `activate` is `true`).
        :param pulumi.Input[bool] imported: Used internally by the provider to temporarily indicate if the service is being imported, and is reset to false once the import is finished
        :param pulumi.Input[str] name: Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[pulumi.InputType['ServiceComputePackageArgs']] package: The `package` block supports uploading or modifying Wasm packages for use in a Fastly Compute@Edge service (if omitted, ensure `activate = false` is set on `ServiceCompute` to avoid service validation errors). See Fastly's documentation on [Compute@Edge](https://developer.fastly.com/learning/compute/)
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ServiceComputeResourceLinkArgs']]]] resource_links: A resource link represents a link between a shared resource (such as an KV Store or Config Store) and a service version.
        :param pulumi.Input[bool] reuse: Services that are active cannot be destroyed. If set to `true` a service Terraform intends to destroy will instead be
               deactivated (allowing it to be reused by importing it into another Terraform project). If `false`, attempting to destroy
               an active service will cause an error. Default `false`
        :param pulumi.Input[str] version_comment: Description field for the version
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ServiceComputeState.__new__(_ServiceComputeState)

        __props__.__dict__["activate"] = activate
        __props__.__dict__["active_version"] = active_version
        __props__.__dict__["backends"] = backends
        __props__.__dict__["cloned_version"] = cloned_version
        __props__.__dict__["comment"] = comment
        __props__.__dict__["dictionaries"] = dictionaries
        __props__.__dict__["domains"] = domains
        __props__.__dict__["force_destroy"] = force_destroy
        __props__.__dict__["force_refresh"] = force_refresh
        __props__.__dict__["imported"] = imported
        __props__.__dict__["logging_bigqueries"] = logging_bigqueries
        __props__.__dict__["logging_blobstorages"] = logging_blobstorages
        __props__.__dict__["logging_cloudfiles"] = logging_cloudfiles
        __props__.__dict__["logging_datadogs"] = logging_datadogs
        __props__.__dict__["logging_digitaloceans"] = logging_digitaloceans
        __props__.__dict__["logging_elasticsearches"] = logging_elasticsearches
        __props__.__dict__["logging_ftps"] = logging_ftps
        __props__.__dict__["logging_gcs"] = logging_gcs
        __props__.__dict__["logging_googlepubsubs"] = logging_googlepubsubs
        __props__.__dict__["logging_heroku"] = logging_heroku
        __props__.__dict__["logging_honeycombs"] = logging_honeycombs
        __props__.__dict__["logging_https"] = logging_https
        __props__.__dict__["logging_kafkas"] = logging_kafkas
        __props__.__dict__["logging_kineses"] = logging_kineses
        __props__.__dict__["logging_logentries"] = logging_logentries
        __props__.__dict__["logging_logglies"] = logging_logglies
        __props__.__dict__["logging_logshuttles"] = logging_logshuttles
        __props__.__dict__["logging_newrelics"] = logging_newrelics
        __props__.__dict__["logging_openstacks"] = logging_openstacks
        __props__.__dict__["logging_papertrails"] = logging_papertrails
        __props__.__dict__["logging_s3s"] = logging_s3s
        __props__.__dict__["logging_scalyrs"] = logging_scalyrs
        __props__.__dict__["logging_sftps"] = logging_sftps
        __props__.__dict__["logging_splunks"] = logging_splunks
        __props__.__dict__["logging_sumologics"] = logging_sumologics
        __props__.__dict__["logging_syslogs"] = logging_syslogs
        __props__.__dict__["name"] = name
        __props__.__dict__["package"] = package
        __props__.__dict__["product_enablement"] = product_enablement
        __props__.__dict__["resource_links"] = resource_links
        __props__.__dict__["reuse"] = reuse
        __props__.__dict__["version_comment"] = version_comment
        return ServiceCompute(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def activate(self) -> pulumi.Output[Optional[bool]]:
        """
        Conditionally prevents the Service from being activated. The apply step will continue to create a new draft version but will not activate it if this is set to `false`. Default `true`
        """
        return pulumi.get(self, "activate")

    @property
    @pulumi.getter(name="activeVersion")
    def active_version(self) -> pulumi.Output[int]:
        """
        The currently active version of your Fastly Service
        """
        return pulumi.get(self, "active_version")

    @property
    @pulumi.getter
    def backends(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeBackend']]]:
        return pulumi.get(self, "backends")

    @property
    @pulumi.getter(name="clonedVersion")
    def cloned_version(self) -> pulumi.Output[int]:
        """
        The latest cloned version by the provider
        """
        return pulumi.get(self, "cloned_version")

    @property
    @pulumi.getter
    def comment(self) -> pulumi.Output[Optional[str]]:
        """
        An optional comment about the Domain.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def dictionaries(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeDictionary']]]:
        return pulumi.get(self, "dictionaries")

    @property
    @pulumi.getter
    def domains(self) -> pulumi.Output[Sequence['outputs.ServiceComputeDomain']]:
        """
        The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter(name="forceDestroy")
    def force_destroy(self) -> pulumi.Output[Optional[bool]]:
        """
        Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        """
        return pulumi.get(self, "force_destroy")

    @property
    @pulumi.getter(name="forceRefresh")
    def force_refresh(self) -> pulumi.Output[bool]:
        """
        Used internally by the provider to temporarily indicate if all resources should call their associated API to update the
        local state. This is for scenarios where the service version has been reverted outside of Terraform (e.g. via the Fastly
        UI) and the provider needs to resync the state for a different active version (this is only if `activate` is `true`).
        """
        return pulumi.get(self, "force_refresh")

    @property
    @pulumi.getter
    def imported(self) -> pulumi.Output[bool]:
        """
        Used internally by the provider to temporarily indicate if the service is being imported, and is reset to false once the import is finished
        """
        return pulumi.get(self, "imported")

    @property
    @pulumi.getter(name="loggingBigqueries")
    def logging_bigqueries(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingBigquery']]]:
        return pulumi.get(self, "logging_bigqueries")

    @property
    @pulumi.getter(name="loggingBlobstorages")
    def logging_blobstorages(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingBlobstorage']]]:
        return pulumi.get(self, "logging_blobstorages")

    @property
    @pulumi.getter(name="loggingCloudfiles")
    def logging_cloudfiles(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingCloudfile']]]:
        return pulumi.get(self, "logging_cloudfiles")

    @property
    @pulumi.getter(name="loggingDatadogs")
    def logging_datadogs(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingDatadog']]]:
        return pulumi.get(self, "logging_datadogs")

    @property
    @pulumi.getter(name="loggingDigitaloceans")
    def logging_digitaloceans(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingDigitalocean']]]:
        return pulumi.get(self, "logging_digitaloceans")

    @property
    @pulumi.getter(name="loggingElasticsearches")
    def logging_elasticsearches(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingElasticsearch']]]:
        return pulumi.get(self, "logging_elasticsearches")

    @property
    @pulumi.getter(name="loggingFtps")
    def logging_ftps(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingFtp']]]:
        return pulumi.get(self, "logging_ftps")

    @property
    @pulumi.getter(name="loggingGcs")
    def logging_gcs(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingGc']]]:
        return pulumi.get(self, "logging_gcs")

    @property
    @pulumi.getter(name="loggingGooglepubsubs")
    def logging_googlepubsubs(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingGooglepubsub']]]:
        return pulumi.get(self, "logging_googlepubsubs")

    @property
    @pulumi.getter(name="loggingHeroku")
    def logging_heroku(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingHeroku']]]:
        return pulumi.get(self, "logging_heroku")

    @property
    @pulumi.getter(name="loggingHoneycombs")
    def logging_honeycombs(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingHoneycomb']]]:
        return pulumi.get(self, "logging_honeycombs")

    @property
    @pulumi.getter(name="loggingHttps")
    def logging_https(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingHttp']]]:
        return pulumi.get(self, "logging_https")

    @property
    @pulumi.getter(name="loggingKafkas")
    def logging_kafkas(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingKafka']]]:
        return pulumi.get(self, "logging_kafkas")

    @property
    @pulumi.getter(name="loggingKineses")
    def logging_kineses(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingKinese']]]:
        return pulumi.get(self, "logging_kineses")

    @property
    @pulumi.getter(name="loggingLogentries")
    def logging_logentries(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingLogentry']]]:
        return pulumi.get(self, "logging_logentries")

    @property
    @pulumi.getter(name="loggingLogglies")
    def logging_logglies(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingLoggly']]]:
        return pulumi.get(self, "logging_logglies")

    @property
    @pulumi.getter(name="loggingLogshuttles")
    def logging_logshuttles(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingLogshuttle']]]:
        return pulumi.get(self, "logging_logshuttles")

    @property
    @pulumi.getter(name="loggingNewrelics")
    def logging_newrelics(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingNewrelic']]]:
        return pulumi.get(self, "logging_newrelics")

    @property
    @pulumi.getter(name="loggingOpenstacks")
    def logging_openstacks(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingOpenstack']]]:
        return pulumi.get(self, "logging_openstacks")

    @property
    @pulumi.getter(name="loggingPapertrails")
    def logging_papertrails(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingPapertrail']]]:
        return pulumi.get(self, "logging_papertrails")

    @property
    @pulumi.getter(name="loggingS3s")
    def logging_s3s(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingS3']]]:
        return pulumi.get(self, "logging_s3s")

    @property
    @pulumi.getter(name="loggingScalyrs")
    def logging_scalyrs(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingScalyr']]]:
        return pulumi.get(self, "logging_scalyrs")

    @property
    @pulumi.getter(name="loggingSftps")
    def logging_sftps(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingSftp']]]:
        return pulumi.get(self, "logging_sftps")

    @property
    @pulumi.getter(name="loggingSplunks")
    def logging_splunks(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingSplunk']]]:
        return pulumi.get(self, "logging_splunks")

    @property
    @pulumi.getter(name="loggingSumologics")
    def logging_sumologics(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingSumologic']]]:
        return pulumi.get(self, "logging_sumologics")

    @property
    @pulumi.getter(name="loggingSyslogs")
    def logging_syslogs(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeLoggingSyslog']]]:
        return pulumi.get(self, "logging_syslogs")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def package(self) -> pulumi.Output[Optional['outputs.ServiceComputePackage']]:
        """
        The `package` block supports uploading or modifying Wasm packages for use in a Fastly Compute@Edge service (if omitted, ensure `activate = false` is set on `ServiceCompute` to avoid service validation errors). See Fastly's documentation on [Compute@Edge](https://developer.fastly.com/learning/compute/)
        """
        return pulumi.get(self, "package")

    @property
    @pulumi.getter(name="productEnablement")
    def product_enablement(self) -> pulumi.Output[Optional['outputs.ServiceComputeProductEnablement']]:
        return pulumi.get(self, "product_enablement")

    @property
    @pulumi.getter(name="resourceLinks")
    def resource_links(self) -> pulumi.Output[Optional[Sequence['outputs.ServiceComputeResourceLink']]]:
        """
        A resource link represents a link between a shared resource (such as an KV Store or Config Store) and a service version.
        """
        return pulumi.get(self, "resource_links")

    @property
    @pulumi.getter
    def reuse(self) -> pulumi.Output[Optional[bool]]:
        """
        Services that are active cannot be destroyed. If set to `true` a service Terraform intends to destroy will instead be
        deactivated (allowing it to be reused by importing it into another Terraform project). If `false`, attempting to destroy
        an active service will cause an error. Default `false`
        """
        return pulumi.get(self, "reuse")

    @property
    @pulumi.getter(name="versionComment")
    def version_comment(self) -> pulumi.Output[Optional[str]]:
        """
        Description field for the version
        """
        return pulumi.get(self, "version_comment")

