# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AlertDimensionsArgs',
    'AlertDimensionsArgsDict',
    'AlertEvaluationStrategyArgs',
    'AlertEvaluationStrategyArgsDict',
    'CustomDashboardDashboardItemArgs',
    'CustomDashboardDashboardItemArgsDict',
    'CustomDashboardDashboardItemDataSourceArgs',
    'CustomDashboardDashboardItemDataSourceArgsDict',
    'CustomDashboardDashboardItemDataSourceConfigArgs',
    'CustomDashboardDashboardItemDataSourceConfigArgsDict',
    'CustomDashboardDashboardItemVisualizationArgs',
    'CustomDashboardDashboardItemVisualizationArgsDict',
    'CustomDashboardDashboardItemVisualizationConfigArgs',
    'CustomDashboardDashboardItemVisualizationConfigArgsDict',
    'NgwafAccountRuleActionArgs',
    'NgwafAccountRuleActionArgsDict',
    'NgwafAccountRuleConditionArgs',
    'NgwafAccountRuleConditionArgsDict',
    'NgwafAccountRuleGroupConditionArgs',
    'NgwafAccountRuleGroupConditionArgsDict',
    'NgwafAccountRuleGroupConditionConditionArgs',
    'NgwafAccountRuleGroupConditionConditionArgsDict',
    'NgwafAccountRuleMultivalConditionArgs',
    'NgwafAccountRuleMultivalConditionArgsDict',
    'NgwafAccountRuleMultivalConditionConditionArgs',
    'NgwafAccountRuleMultivalConditionConditionArgsDict',
    'NgwafWorkspaceAttackSignalThresholdsArgs',
    'NgwafWorkspaceAttackSignalThresholdsArgsDict',
    'NgwafWorkspaceRuleActionArgs',
    'NgwafWorkspaceRuleActionArgsDict',
    'NgwafWorkspaceRuleConditionArgs',
    'NgwafWorkspaceRuleConditionArgsDict',
    'NgwafWorkspaceRuleGroupConditionArgs',
    'NgwafWorkspaceRuleGroupConditionArgsDict',
    'NgwafWorkspaceRuleGroupConditionConditionArgs',
    'NgwafWorkspaceRuleGroupConditionConditionArgsDict',
    'NgwafWorkspaceRuleMultivalConditionArgs',
    'NgwafWorkspaceRuleMultivalConditionArgsDict',
    'NgwafWorkspaceRuleMultivalConditionConditionArgs',
    'NgwafWorkspaceRuleMultivalConditionConditionArgsDict',
    'NgwafWorkspaceRuleRateLimitArgs',
    'NgwafWorkspaceRuleRateLimitArgsDict',
    'NgwafWorkspaceRuleRateLimitClientIdentifierArgs',
    'NgwafWorkspaceRuleRateLimitClientIdentifierArgsDict',
    'ServiceACLEntriesEntryArgs',
    'ServiceACLEntriesEntryArgsDict',
    'ServiceComputeBackendArgs',
    'ServiceComputeBackendArgsDict',
    'ServiceComputeDictionaryArgs',
    'ServiceComputeDictionaryArgsDict',
    'ServiceComputeDomainArgs',
    'ServiceComputeDomainArgsDict',
    'ServiceComputeHealthcheckArgs',
    'ServiceComputeHealthcheckArgsDict',
    'ServiceComputeImageOptimizerDefaultSettingsArgs',
    'ServiceComputeImageOptimizerDefaultSettingsArgsDict',
    'ServiceComputeLoggingBigqueryArgs',
    'ServiceComputeLoggingBigqueryArgsDict',
    'ServiceComputeLoggingBlobstorageArgs',
    'ServiceComputeLoggingBlobstorageArgsDict',
    'ServiceComputeLoggingCloudfileArgs',
    'ServiceComputeLoggingCloudfileArgsDict',
    'ServiceComputeLoggingDatadogArgs',
    'ServiceComputeLoggingDatadogArgsDict',
    'ServiceComputeLoggingDigitaloceanArgs',
    'ServiceComputeLoggingDigitaloceanArgsDict',
    'ServiceComputeLoggingElasticsearchArgs',
    'ServiceComputeLoggingElasticsearchArgsDict',
    'ServiceComputeLoggingFtpArgs',
    'ServiceComputeLoggingFtpArgsDict',
    'ServiceComputeLoggingGcArgs',
    'ServiceComputeLoggingGcArgsDict',
    'ServiceComputeLoggingGooglepubsubArgs',
    'ServiceComputeLoggingGooglepubsubArgsDict',
    'ServiceComputeLoggingGrafanacloudlogArgs',
    'ServiceComputeLoggingGrafanacloudlogArgsDict',
    'ServiceComputeLoggingHerokuArgs',
    'ServiceComputeLoggingHerokuArgsDict',
    'ServiceComputeLoggingHoneycombArgs',
    'ServiceComputeLoggingHoneycombArgsDict',
    'ServiceComputeLoggingHttpArgs',
    'ServiceComputeLoggingHttpArgsDict',
    'ServiceComputeLoggingKafkaArgs',
    'ServiceComputeLoggingKafkaArgsDict',
    'ServiceComputeLoggingKineseArgs',
    'ServiceComputeLoggingKineseArgsDict',
    'ServiceComputeLoggingLogentryArgs',
    'ServiceComputeLoggingLogentryArgsDict',
    'ServiceComputeLoggingLogglyArgs',
    'ServiceComputeLoggingLogglyArgsDict',
    'ServiceComputeLoggingLogshuttleArgs',
    'ServiceComputeLoggingLogshuttleArgsDict',
    'ServiceComputeLoggingNewrelicArgs',
    'ServiceComputeLoggingNewrelicArgsDict',
    'ServiceComputeLoggingNewrelicotlpArgs',
    'ServiceComputeLoggingNewrelicotlpArgsDict',
    'ServiceComputeLoggingOpenstackArgs',
    'ServiceComputeLoggingOpenstackArgsDict',
    'ServiceComputeLoggingPapertrailArgs',
    'ServiceComputeLoggingPapertrailArgsDict',
    'ServiceComputeLoggingS3Args',
    'ServiceComputeLoggingS3ArgsDict',
    'ServiceComputeLoggingScalyrArgs',
    'ServiceComputeLoggingScalyrArgsDict',
    'ServiceComputeLoggingSftpArgs',
    'ServiceComputeLoggingSftpArgsDict',
    'ServiceComputeLoggingSplunkArgs',
    'ServiceComputeLoggingSplunkArgsDict',
    'ServiceComputeLoggingSumologicArgs',
    'ServiceComputeLoggingSumologicArgsDict',
    'ServiceComputeLoggingSyslogArgs',
    'ServiceComputeLoggingSyslogArgsDict',
    'ServiceComputePackageArgs',
    'ServiceComputePackageArgsDict',
    'ServiceComputeProductEnablementArgs',
    'ServiceComputeProductEnablementArgsDict',
    'ServiceComputeProductEnablementDdosProtectionArgs',
    'ServiceComputeProductEnablementDdosProtectionArgsDict',
    'ServiceComputeProductEnablementNgwafArgs',
    'ServiceComputeProductEnablementNgwafArgsDict',
    'ServiceComputeResourceLinkArgs',
    'ServiceComputeResourceLinkArgsDict',
    'ServiceVclAclArgs',
    'ServiceVclAclArgsDict',
    'ServiceVclBackendArgs',
    'ServiceVclBackendArgsDict',
    'ServiceVclCacheSettingArgs',
    'ServiceVclCacheSettingArgsDict',
    'ServiceVclConditionArgs',
    'ServiceVclConditionArgsDict',
    'ServiceVclDictionaryArgs',
    'ServiceVclDictionaryArgsDict',
    'ServiceVclDirectorArgs',
    'ServiceVclDirectorArgsDict',
    'ServiceVclDomainArgs',
    'ServiceVclDomainArgsDict',
    'ServiceVclDynamicsnippetArgs',
    'ServiceVclDynamicsnippetArgsDict',
    'ServiceVclGzipArgs',
    'ServiceVclGzipArgsDict',
    'ServiceVclHeaderArgs',
    'ServiceVclHeaderArgsDict',
    'ServiceVclHealthcheckArgs',
    'ServiceVclHealthcheckArgsDict',
    'ServiceVclImageOptimizerDefaultSettingsArgs',
    'ServiceVclImageOptimizerDefaultSettingsArgsDict',
    'ServiceVclLoggingBigqueryArgs',
    'ServiceVclLoggingBigqueryArgsDict',
    'ServiceVclLoggingBlobstorageArgs',
    'ServiceVclLoggingBlobstorageArgsDict',
    'ServiceVclLoggingCloudfileArgs',
    'ServiceVclLoggingCloudfileArgsDict',
    'ServiceVclLoggingDatadogArgs',
    'ServiceVclLoggingDatadogArgsDict',
    'ServiceVclLoggingDigitaloceanArgs',
    'ServiceVclLoggingDigitaloceanArgsDict',
    'ServiceVclLoggingElasticsearchArgs',
    'ServiceVclLoggingElasticsearchArgsDict',
    'ServiceVclLoggingFtpArgs',
    'ServiceVclLoggingFtpArgsDict',
    'ServiceVclLoggingGcArgs',
    'ServiceVclLoggingGcArgsDict',
    'ServiceVclLoggingGooglepubsubArgs',
    'ServiceVclLoggingGooglepubsubArgsDict',
    'ServiceVclLoggingGrafanacloudlogArgs',
    'ServiceVclLoggingGrafanacloudlogArgsDict',
    'ServiceVclLoggingHerokusArgs',
    'ServiceVclLoggingHerokusArgsDict',
    'ServiceVclLoggingHoneycombArgs',
    'ServiceVclLoggingHoneycombArgsDict',
    'ServiceVclLoggingHttpArgs',
    'ServiceVclLoggingHttpArgsDict',
    'ServiceVclLoggingKafkaArgs',
    'ServiceVclLoggingKafkaArgsDict',
    'ServiceVclLoggingKineseArgs',
    'ServiceVclLoggingKineseArgsDict',
    'ServiceVclLoggingLogentryArgs',
    'ServiceVclLoggingLogentryArgsDict',
    'ServiceVclLoggingLogglyArgs',
    'ServiceVclLoggingLogglyArgsDict',
    'ServiceVclLoggingLogshuttleArgs',
    'ServiceVclLoggingLogshuttleArgsDict',
    'ServiceVclLoggingNewrelicArgs',
    'ServiceVclLoggingNewrelicArgsDict',
    'ServiceVclLoggingNewrelicotlpArgs',
    'ServiceVclLoggingNewrelicotlpArgsDict',
    'ServiceVclLoggingOpenstackArgs',
    'ServiceVclLoggingOpenstackArgsDict',
    'ServiceVclLoggingPapertrailArgs',
    'ServiceVclLoggingPapertrailArgsDict',
    'ServiceVclLoggingS3Args',
    'ServiceVclLoggingS3ArgsDict',
    'ServiceVclLoggingScalyrArgs',
    'ServiceVclLoggingScalyrArgsDict',
    'ServiceVclLoggingSftpArgs',
    'ServiceVclLoggingSftpArgsDict',
    'ServiceVclLoggingSplunkArgs',
    'ServiceVclLoggingSplunkArgsDict',
    'ServiceVclLoggingSumologicArgs',
    'ServiceVclLoggingSumologicArgsDict',
    'ServiceVclLoggingSyslogArgs',
    'ServiceVclLoggingSyslogArgsDict',
    'ServiceVclProductEnablementArgs',
    'ServiceVclProductEnablementArgsDict',
    'ServiceVclProductEnablementDdosProtectionArgs',
    'ServiceVclProductEnablementDdosProtectionArgsDict',
    'ServiceVclProductEnablementNgwafArgs',
    'ServiceVclProductEnablementNgwafArgsDict',
    'ServiceVclRateLimiterArgs',
    'ServiceVclRateLimiterArgsDict',
    'ServiceVclRateLimiterResponseArgs',
    'ServiceVclRateLimiterResponseArgsDict',
    'ServiceVclRequestSettingArgs',
    'ServiceVclRequestSettingArgsDict',
    'ServiceVclResponseObjectArgs',
    'ServiceVclResponseObjectArgsDict',
    'ServiceVclSnippetArgs',
    'ServiceVclSnippetArgsDict',
    'ServiceVclVclArgs',
    'ServiceVclVclArgsDict',
    'TlsSubscriptionManagedDnsChallengeArgs',
    'TlsSubscriptionManagedDnsChallengeArgsDict',
    'TlsSubscriptionManagedHttpChallengeArgs',
    'TlsSubscriptionManagedHttpChallengeArgsDict',
]

MYPY = False

if not MYPY:
    class AlertDimensionsArgsDict(TypedDict):
        domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Names of a subset of domains that the alert monitors.
        """
        origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Addresses of a subset of backends that the alert monitors.
        """
elif False:
    AlertDimensionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertDimensionsArgs:
    def __init__(__self__, *,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 origins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] domains: Names of a subset of domains that the alert monitors.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] origins: Addresses of a subset of backends that the alert monitors.
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if origins is not None:
            pulumi.set(__self__, "origins", origins)

    @_builtins.property
    @pulumi.getter
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Names of a subset of domains that the alert monitors.
        """
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "domains", value)

    @_builtins.property
    @pulumi.getter
    def origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Addresses of a subset of backends that the alert monitors.
        """
        return pulumi.get(self, "origins")

    @origins.setter
    def origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "origins", value)


if not MYPY:
    class AlertEvaluationStrategyArgsDict(TypedDict):
        period: pulumi.Input[_builtins.str]
        """
        The length of time to evaluate whether the conditions have been met. The data is polled every minute. One of: `2m`, `3m`, `5m`, `15m`, `30m`.
        """
        threshold: pulumi.Input[_builtins.float]
        """
        Threshold used to alert.
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of strategy to use to evaluate. One of: `above_threshold`, `all_above_threshold`, `below_threshold`, `percent_absolute`, `percent_decrease`, `percent_increase`.
        """
        ignore_below: NotRequired[pulumi.Input[_builtins.float]]
        """
        Threshold for the denominator value used in evaluations that calculate a rate or ratio. Usually used to filter out noise.
        """
elif False:
    AlertEvaluationStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertEvaluationStrategyArgs:
    def __init__(__self__, *,
                 period: pulumi.Input[_builtins.str],
                 threshold: pulumi.Input[_builtins.float],
                 type: pulumi.Input[_builtins.str],
                 ignore_below: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] period: The length of time to evaluate whether the conditions have been met. The data is polled every minute. One of: `2m`, `3m`, `5m`, `15m`, `30m`.
        :param pulumi.Input[_builtins.float] threshold: Threshold used to alert.
        :param pulumi.Input[_builtins.str] type: Type of strategy to use to evaluate. One of: `above_threshold`, `all_above_threshold`, `below_threshold`, `percent_absolute`, `percent_decrease`, `percent_increase`.
        :param pulumi.Input[_builtins.float] ignore_below: Threshold for the denominator value used in evaluations that calculate a rate or ratio. Usually used to filter out noise.
        """
        pulumi.set(__self__, "period", period)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "type", type)
        if ignore_below is not None:
            pulumi.set(__self__, "ignore_below", ignore_below)

    @_builtins.property
    @pulumi.getter
    def period(self) -> pulumi.Input[_builtins.str]:
        """
        The length of time to evaluate whether the conditions have been met. The data is polled every minute. One of: `2m`, `3m`, `5m`, `15m`, `30m`.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.float]:
        """
        Threshold used to alert.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of strategy to use to evaluate. One of: `above_threshold`, `all_above_threshold`, `below_threshold`, `percent_absolute`, `percent_decrease`, `percent_increase`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="ignoreBelow")
    def ignore_below(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Threshold for the denominator value used in evaluations that calculate a rate or ratio. Usually used to filter out noise.
        """
        return pulumi.get(self, "ignore_below")

    @ignore_below.setter
    def ignore_below(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "ignore_below", value)


if not MYPY:
    class CustomDashboardDashboardItemArgsDict(TypedDict):
        data_source: pulumi.Input['CustomDashboardDashboardItemDataSourceArgsDict']
        """
        An object which describes the data to display.
        """
        id: pulumi.Input[_builtins.str]
        """
        Dashboard item identifier (alphanumeric). Must be unique, relative to other items in the same dashboard.
        """
        subtitle: pulumi.Input[_builtins.str]
        """
        A human-readable subtitle for the dashboard item. Often a description of the visualization.
        """
        title: pulumi.Input[_builtins.str]
        """
        A human-readable title for the dashboard item.
        """
        visualization: pulumi.Input['CustomDashboardDashboardItemVisualizationArgsDict']
        """
        An object which describes the data visualization to display.
        """
        span: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of columns for the dashboard item to span. Dashboards are rendered on a 12-column grid on "desktop" screen sizes.
        """
elif False:
    CustomDashboardDashboardItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDashboardDashboardItemArgs:
    def __init__(__self__, *,
                 data_source: pulumi.Input['CustomDashboardDashboardItemDataSourceArgs'],
                 id: pulumi.Input[_builtins.str],
                 subtitle: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 visualization: pulumi.Input['CustomDashboardDashboardItemVisualizationArgs'],
                 span: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['CustomDashboardDashboardItemDataSourceArgs'] data_source: An object which describes the data to display.
        :param pulumi.Input[_builtins.str] id: Dashboard item identifier (alphanumeric). Must be unique, relative to other items in the same dashboard.
        :param pulumi.Input[_builtins.str] subtitle: A human-readable subtitle for the dashboard item. Often a description of the visualization.
        :param pulumi.Input[_builtins.str] title: A human-readable title for the dashboard item.
        :param pulumi.Input['CustomDashboardDashboardItemVisualizationArgs'] visualization: An object which describes the data visualization to display.
        :param pulumi.Input[_builtins.int] span: The number of columns for the dashboard item to span. Dashboards are rendered on a 12-column grid on "desktop" screen sizes.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "subtitle", subtitle)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "visualization", visualization)
        if span is not None:
            pulumi.set(__self__, "span", span)

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> pulumi.Input['CustomDashboardDashboardItemDataSourceArgs']:
        """
        An object which describes the data to display.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: pulumi.Input['CustomDashboardDashboardItemDataSourceArgs']):
        pulumi.set(self, "data_source", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        Dashboard item identifier (alphanumeric). Must be unique, relative to other items in the same dashboard.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def subtitle(self) -> pulumi.Input[_builtins.str]:
        """
        A human-readable subtitle for the dashboard item. Often a description of the visualization.
        """
        return pulumi.get(self, "subtitle")

    @subtitle.setter
    def subtitle(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subtitle", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        A human-readable title for the dashboard item.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def visualization(self) -> pulumi.Input['CustomDashboardDashboardItemVisualizationArgs']:
        """
        An object which describes the data visualization to display.
        """
        return pulumi.get(self, "visualization")

    @visualization.setter
    def visualization(self, value: pulumi.Input['CustomDashboardDashboardItemVisualizationArgs']):
        pulumi.set(self, "visualization", value)

    @_builtins.property
    @pulumi.getter
    def span(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of columns for the dashboard item to span. Dashboards are rendered on a 12-column grid on "desktop" screen sizes.
        """
        return pulumi.get(self, "span")

    @span.setter
    def span(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "span", value)


if not MYPY:
    class CustomDashboardDashboardItemDataSourceArgsDict(TypedDict):
        config: pulumi.Input['CustomDashboardDashboardItemDataSourceConfigArgsDict']
        """
        Configuration options for the selected data source.
        """
        type: pulumi.Input[_builtins.str]
        """
        The source of the data to display. One of: `stats.edge`, `stats.domain`, `stats.origin`.
        """
elif False:
    CustomDashboardDashboardItemDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDashboardDashboardItemDataSourceArgs:
    def __init__(__self__, *,
                 config: pulumi.Input['CustomDashboardDashboardItemDataSourceConfigArgs'],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['CustomDashboardDashboardItemDataSourceConfigArgs'] config: Configuration options for the selected data source.
        :param pulumi.Input[_builtins.str] type: The source of the data to display. One of: `stats.edge`, `stats.domain`, `stats.origin`.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def config(self) -> pulumi.Input['CustomDashboardDashboardItemDataSourceConfigArgs']:
        """
        Configuration options for the selected data source.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input['CustomDashboardDashboardItemDataSourceConfigArgs']):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The source of the data to display. One of: `stats.edge`, `stats.domain`, `stats.origin`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CustomDashboardDashboardItemDataSourceConfigArgsDict(TypedDict):
        metrics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The metrics to visualize. Valid options are defined by the selected data source: [stats.edge](https://www.fastly.com/documentation/reference/api/observability/custom-dashboards/metrics/edge/), [stats.domain](https://www.fastly.com/documentation/reference/api/observability/custom-dashboards/metrics/domain/), [stats.origin](https://www.fastly.com/documentation/reference/api/observability/custom-dashboards/metrics/origin/).
        """
elif False:
    CustomDashboardDashboardItemDataSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDashboardDashboardItemDataSourceConfigArgs:
    def __init__(__self__, *,
                 metrics: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metrics: The metrics to visualize. Valid options are defined by the selected data source: [stats.edge](https://www.fastly.com/documentation/reference/api/observability/custom-dashboards/metrics/edge/), [stats.domain](https://www.fastly.com/documentation/reference/api/observability/custom-dashboards/metrics/domain/), [stats.origin](https://www.fastly.com/documentation/reference/api/observability/custom-dashboards/metrics/origin/).
        """
        pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The metrics to visualize. Valid options are defined by the selected data source: [stats.edge](https://www.fastly.com/documentation/reference/api/observability/custom-dashboards/metrics/edge/), [stats.domain](https://www.fastly.com/documentation/reference/api/observability/custom-dashboards/metrics/domain/), [stats.origin](https://www.fastly.com/documentation/reference/api/observability/custom-dashboards/metrics/origin/).
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class CustomDashboardDashboardItemVisualizationArgsDict(TypedDict):
        config: pulumi.Input['CustomDashboardDashboardItemVisualizationConfigArgsDict']
        """
        Configuration options for the selected data source.
        """
        type: pulumi.Input[_builtins.str]
        """
        The type of visualization to display. One of: `chart`.
        """
elif False:
    CustomDashboardDashboardItemVisualizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDashboardDashboardItemVisualizationArgs:
    def __init__(__self__, *,
                 config: pulumi.Input['CustomDashboardDashboardItemVisualizationConfigArgs'],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input['CustomDashboardDashboardItemVisualizationConfigArgs'] config: Configuration options for the selected data source.
        :param pulumi.Input[_builtins.str] type: The type of visualization to display. One of: `chart`.
        """
        pulumi.set(__self__, "config", config)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def config(self) -> pulumi.Input['CustomDashboardDashboardItemVisualizationConfigArgs']:
        """
        Configuration options for the selected data source.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: pulumi.Input['CustomDashboardDashboardItemVisualizationConfigArgs']):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of visualization to display. One of: `chart`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CustomDashboardDashboardItemVisualizationConfigArgsDict(TypedDict):
        plot_type: pulumi.Input[_builtins.str]
        """
        The type of chart to display. One of: `line`, `bar`, `single-metric`, `donut`.
        """
        calculation_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        The aggregation function to apply to the dataset. One of: `avg`, `sum`, `min`, `max`, `latest`, `p95`.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The units to use to format the data. One of: `number`, `bytes`, `percent`, `requests`, `responses`, `seconds`, `milliseconds`, `ratio`, `bitrate`.
        """
elif False:
    CustomDashboardDashboardItemVisualizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CustomDashboardDashboardItemVisualizationConfigArgs:
    def __init__(__self__, *,
                 plot_type: pulumi.Input[_builtins.str],
                 calculation_method: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] plot_type: The type of chart to display. One of: `line`, `bar`, `single-metric`, `donut`.
        :param pulumi.Input[_builtins.str] calculation_method: The aggregation function to apply to the dataset. One of: `avg`, `sum`, `min`, `max`, `latest`, `p95`.
        :param pulumi.Input[_builtins.str] format: The units to use to format the data. One of: `number`, `bytes`, `percent`, `requests`, `responses`, `seconds`, `milliseconds`, `ratio`, `bitrate`.
        """
        pulumi.set(__self__, "plot_type", plot_type)
        if calculation_method is not None:
            pulumi.set(__self__, "calculation_method", calculation_method)
        if format is not None:
            pulumi.set(__self__, "format", format)

    @_builtins.property
    @pulumi.getter(name="plotType")
    def plot_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of chart to display. One of: `line`, `bar`, `single-metric`, `donut`.
        """
        return pulumi.get(self, "plot_type")

    @plot_type.setter
    def plot_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plot_type", value)

    @_builtins.property
    @pulumi.getter(name="calculationMethod")
    def calculation_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The aggregation function to apply to the dataset. One of: `avg`, `sum`, `min`, `max`, `latest`, `p95`.
        """
        return pulumi.get(self, "calculation_method")

    @calculation_method.setter
    def calculation_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "calculation_method", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The units to use to format the data. One of: `number`, `bytes`, `percent`, `requests`, `responses`, `seconds`, `milliseconds`, `ratio`, `bitrate`.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)


if not MYPY:
    class NgwafAccountRuleActionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The action type. One of: `add_signal`, `allow`, `block`, `browser_challenge`, `dynamic_challenge`, `exclude_signal`, `verify_token` or for rate limit rule valid values: `log_request`, `block_signal`, `browser_challenge`, `verify_token`
        """
        signal: NotRequired[pulumi.Input[_builtins.str]]
        """
        Signal name to exclude (used when `type = exclude_signal`).
        """
elif False:
    NgwafAccountRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafAccountRuleActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 signal: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The action type. One of: `add_signal`, `allow`, `block`, `browser_challenge`, `dynamic_challenge`, `exclude_signal`, `verify_token` or for rate limit rule valid values: `log_request`, `block_signal`, `browser_challenge`, `verify_token`
        :param pulumi.Input[_builtins.str] signal: Signal name to exclude (used when `type = exclude_signal`).
        """
        pulumi.set(__self__, "type", type)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The action type. One of: `add_signal`, `allow`, `block`, `browser_challenge`, `dynamic_challenge`, `exclude_signal`, `verify_token` or for rate limit rule valid values: `log_request`, `block_signal`, `browser_challenge`, `verify_token`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def signal(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Signal name to exclude (used when `type = exclude_signal`).
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "signal", value)


if not MYPY:
    class NgwafAccountRuleConditionArgsDict(TypedDict):
        field: pulumi.Input[_builtins.str]
        """
        Field to inspect (e.g., `ip`, `path`).
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        value: pulumi.Input[_builtins.str]
        """
        The value to test the field against.
        """
elif False:
    NgwafAccountRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafAccountRuleConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] field: Field to inspect (e.g., `ip`, `path`).
        :param pulumi.Input[_builtins.str] operator: Operator to apply (e.g., `equals`, `contains`).
        :param pulumi.Input[_builtins.str] value: The value to test the field against.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Field to inspect (e.g., `ip`, `path`).
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value to test the field against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NgwafAccountRuleGroupConditionArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['NgwafAccountRuleGroupConditionConditionArgsDict']]]
        """
        A list of nested conditions in this group.
        """
        group_operator: pulumi.Input[_builtins.str]
        """
        Logical operator for the group. Accepted values are `any` and `all`.
        """
elif False:
    NgwafAccountRuleGroupConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafAccountRuleGroupConditionArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['NgwafAccountRuleGroupConditionConditionArgs']]],
                 group_operator: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NgwafAccountRuleGroupConditionConditionArgs']]] conditions: A list of nested conditions in this group.
        :param pulumi.Input[_builtins.str] group_operator: Logical operator for the group. Accepted values are `any` and `all`.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "group_operator", group_operator)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['NgwafAccountRuleGroupConditionConditionArgs']]]:
        """
        A list of nested conditions in this group.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['NgwafAccountRuleGroupConditionConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter(name="groupOperator")
    def group_operator(self) -> pulumi.Input[_builtins.str]:
        """
        Logical operator for the group. Accepted values are `any` and `all`.
        """
        return pulumi.get(self, "group_operator")

    @group_operator.setter
    def group_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_operator", value)


if not MYPY:
    class NgwafAccountRuleGroupConditionConditionArgsDict(TypedDict):
        field: pulumi.Input[_builtins.str]
        """
        Field to inspect (e.g., `ip`, `path`).
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        value: pulumi.Input[_builtins.str]
        """
        The value to test the field against.
        """
elif False:
    NgwafAccountRuleGroupConditionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafAccountRuleGroupConditionConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] field: Field to inspect (e.g., `ip`, `path`).
        :param pulumi.Input[_builtins.str] operator: Operator to apply (e.g., `equals`, `contains`).
        :param pulumi.Input[_builtins.str] value: The value to test the field against.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Field to inspect (e.g., `ip`, `path`).
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value to test the field against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NgwafAccountRuleMultivalConditionArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['NgwafAccountRuleMultivalConditionConditionArgsDict']]]
        """
        A list of nested conditions in this list.
        """
        field: pulumi.Input[_builtins.str]
        """
        Enums for multival condition field.. Accepted values are `post_parameter`, `query_parameter`, `request_cookie`, `request_header`, `response_header`, and `signal`.
        """
        group_operator: pulumi.Input[_builtins.str]
        """
        Logical operator for the group. Accepted values are `any` and `all`.
        """
        operator: pulumi.Input[_builtins.str]
        """
        Indicates whether the supplied conditions will check for existence or non-existence of matching field values. Accepted values are `exists` and `does_not_exist`.
        """
elif False:
    NgwafAccountRuleMultivalConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafAccountRuleMultivalConditionArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['NgwafAccountRuleMultivalConditionConditionArgs']]],
                 field: pulumi.Input[_builtins.str],
                 group_operator: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NgwafAccountRuleMultivalConditionConditionArgs']]] conditions: A list of nested conditions in this list.
        :param pulumi.Input[_builtins.str] field: Enums for multival condition field.. Accepted values are `post_parameter`, `query_parameter`, `request_cookie`, `request_header`, `response_header`, and `signal`.
        :param pulumi.Input[_builtins.str] group_operator: Logical operator for the group. Accepted values are `any` and `all`.
        :param pulumi.Input[_builtins.str] operator: Indicates whether the supplied conditions will check for existence or non-existence of matching field values. Accepted values are `exists` and `does_not_exist`.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "group_operator", group_operator)
        pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['NgwafAccountRuleMultivalConditionConditionArgs']]]:
        """
        A list of nested conditions in this list.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['NgwafAccountRuleMultivalConditionConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Enums for multival condition field.. Accepted values are `post_parameter`, `query_parameter`, `request_cookie`, `request_header`, `response_header`, and `signal`.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter(name="groupOperator")
    def group_operator(self) -> pulumi.Input[_builtins.str]:
        """
        Logical operator for the group. Accepted values are `any` and `all`.
        """
        return pulumi.get(self, "group_operator")

    @group_operator.setter
    def group_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_operator", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates whether the supplied conditions will check for existence or non-existence of matching field values. Accepted values are `exists` and `does_not_exist`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class NgwafAccountRuleMultivalConditionConditionArgsDict(TypedDict):
        field: pulumi.Input[_builtins.str]
        """
        Field to inspect (e.g., `name`, `value`, `signal_id`).
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        value: pulumi.Input[_builtins.str]
        """
        The value to test the field against.
        """
elif False:
    NgwafAccountRuleMultivalConditionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafAccountRuleMultivalConditionConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] field: Field to inspect (e.g., `name`, `value`, `signal_id`).
        :param pulumi.Input[_builtins.str] operator: Operator to apply (e.g., `equals`, `contains`).
        :param pulumi.Input[_builtins.str] value: The value to test the field against.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Field to inspect (e.g., `name`, `value`, `signal_id`).
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value to test the field against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NgwafWorkspaceAttackSignalThresholdsArgsDict(TypedDict):
        immediate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Ignore thresholds and block immediately when at least one attack signal is detected. Default value `false`.
        """
        one_hour: NotRequired[pulumi.Input[_builtins.int]]
        """
        The one-hour interval threshold. Minimum 1 and maximum 10,000. Default value 100.
        """
        one_minute: NotRequired[pulumi.Input[_builtins.int]]
        """
        The one-minute interval threshold. Minimum 1 and maximum 10,000. Default value 1.
        """
        ten_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The ten-minute interval threshold. Minimum 1 and maximum 10,000. Default value 60.
        """
elif False:
    NgwafWorkspaceAttackSignalThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafWorkspaceAttackSignalThresholdsArgs:
    def __init__(__self__, *,
                 immediate: Optional[pulumi.Input[_builtins.bool]] = None,
                 one_hour: Optional[pulumi.Input[_builtins.int]] = None,
                 one_minute: Optional[pulumi.Input[_builtins.int]] = None,
                 ten_minutes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] immediate: Ignore thresholds and block immediately when at least one attack signal is detected. Default value `false`.
        :param pulumi.Input[_builtins.int] one_hour: The one-hour interval threshold. Minimum 1 and maximum 10,000. Default value 100.
        :param pulumi.Input[_builtins.int] one_minute: The one-minute interval threshold. Minimum 1 and maximum 10,000. Default value 1.
        :param pulumi.Input[_builtins.int] ten_minutes: The ten-minute interval threshold. Minimum 1 and maximum 10,000. Default value 60.
        """
        if immediate is not None:
            pulumi.set(__self__, "immediate", immediate)
        if one_hour is not None:
            pulumi.set(__self__, "one_hour", one_hour)
        if one_minute is not None:
            pulumi.set(__self__, "one_minute", one_minute)
        if ten_minutes is not None:
            pulumi.set(__self__, "ten_minutes", ten_minutes)

    @_builtins.property
    @pulumi.getter
    def immediate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Ignore thresholds and block immediately when at least one attack signal is detected. Default value `false`.
        """
        return pulumi.get(self, "immediate")

    @immediate.setter
    def immediate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "immediate", value)

    @_builtins.property
    @pulumi.getter(name="oneHour")
    def one_hour(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The one-hour interval threshold. Minimum 1 and maximum 10,000. Default value 100.
        """
        return pulumi.get(self, "one_hour")

    @one_hour.setter
    def one_hour(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "one_hour", value)

    @_builtins.property
    @pulumi.getter(name="oneMinute")
    def one_minute(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The one-minute interval threshold. Minimum 1 and maximum 10,000. Default value 1.
        """
        return pulumi.get(self, "one_minute")

    @one_minute.setter
    def one_minute(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "one_minute", value)

    @_builtins.property
    @pulumi.getter(name="tenMinutes")
    def ten_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The ten-minute interval threshold. Minimum 1 and maximum 10,000. Default value 60.
        """
        return pulumi.get(self, "ten_minutes")

    @ten_minutes.setter
    def ten_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ten_minutes", value)


if not MYPY:
    class NgwafWorkspaceRuleActionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The action type. One of: `add_signal`, `allow`, `block`, `browser_challenge`, `dynamic_challenge`, `exclude_signal`, `verify_token` or for rate limit rule valid values: `log_request`, `block_signal`, `browser_challenge`, `verify_token`
        """
        allow_interactive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Specifies if interaction is allowed (used when `type = browser_challenge`).
        """
        deception_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        specifies the type of deception (used when `type = deception`).
        """
        redirect_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Redirect target (used when `type = redirect`).
        """
        response_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        Response code used with redirect.
        """
        signal: NotRequired[pulumi.Input[_builtins.str]]
        """
        Signal name to exclude (used when `type = exclude_signal`).
        """
elif False:
    NgwafWorkspaceRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafWorkspaceRuleActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 allow_interactive: Optional[pulumi.Input[_builtins.bool]] = None,
                 deception_type: Optional[pulumi.Input[_builtins.str]] = None,
                 redirect_url: Optional[pulumi.Input[_builtins.str]] = None,
                 response_code: Optional[pulumi.Input[_builtins.int]] = None,
                 signal: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The action type. One of: `add_signal`, `allow`, `block`, `browser_challenge`, `dynamic_challenge`, `exclude_signal`, `verify_token` or for rate limit rule valid values: `log_request`, `block_signal`, `browser_challenge`, `verify_token`
        :param pulumi.Input[_builtins.bool] allow_interactive: Specifies if interaction is allowed (used when `type = browser_challenge`).
        :param pulumi.Input[_builtins.str] deception_type: specifies the type of deception (used when `type = deception`).
        :param pulumi.Input[_builtins.str] redirect_url: Redirect target (used when `type = redirect`).
        :param pulumi.Input[_builtins.int] response_code: Response code used with redirect.
        :param pulumi.Input[_builtins.str] signal: Signal name to exclude (used when `type = exclude_signal`).
        """
        pulumi.set(__self__, "type", type)
        if allow_interactive is not None:
            pulumi.set(__self__, "allow_interactive", allow_interactive)
        if deception_type is not None:
            pulumi.set(__self__, "deception_type", deception_type)
        if redirect_url is not None:
            pulumi.set(__self__, "redirect_url", redirect_url)
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)
        if signal is not None:
            pulumi.set(__self__, "signal", signal)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The action type. One of: `add_signal`, `allow`, `block`, `browser_challenge`, `dynamic_challenge`, `exclude_signal`, `verify_token` or for rate limit rule valid values: `log_request`, `block_signal`, `browser_challenge`, `verify_token`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="allowInteractive")
    def allow_interactive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Specifies if interaction is allowed (used when `type = browser_challenge`).
        """
        return pulumi.get(self, "allow_interactive")

    @allow_interactive.setter
    def allow_interactive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_interactive", value)

    @_builtins.property
    @pulumi.getter(name="deceptionType")
    def deception_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        specifies the type of deception (used when `type = deception`).
        """
        return pulumi.get(self, "deception_type")

    @deception_type.setter
    def deception_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deception_type", value)

    @_builtins.property
    @pulumi.getter(name="redirectUrl")
    def redirect_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Redirect target (used when `type = redirect`).
        """
        return pulumi.get(self, "redirect_url")

    @redirect_url.setter
    def redirect_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redirect_url", value)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Response code used with redirect.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "response_code", value)

    @_builtins.property
    @pulumi.getter
    def signal(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Signal name to exclude (used when `type = exclude_signal`).
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "signal", value)


if not MYPY:
    class NgwafWorkspaceRuleConditionArgsDict(TypedDict):
        field: pulumi.Input[_builtins.str]
        """
        Field to inspect (e.g., `ip`, `path`).
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        value: pulumi.Input[_builtins.str]
        """
        The value to test the field against.
        """
elif False:
    NgwafWorkspaceRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafWorkspaceRuleConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] field: Field to inspect (e.g., `ip`, `path`).
        :param pulumi.Input[_builtins.str] operator: Operator to apply (e.g., `equals`, `contains`).
        :param pulumi.Input[_builtins.str] value: The value to test the field against.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Field to inspect (e.g., `ip`, `path`).
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value to test the field against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NgwafWorkspaceRuleGroupConditionArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleGroupConditionConditionArgsDict']]]
        """
        A list of nested conditions in this group.
        """
        group_operator: pulumi.Input[_builtins.str]
        """
        Logical operator for the group. Accepted values are `any` and `all`.
        """
elif False:
    NgwafWorkspaceRuleGroupConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafWorkspaceRuleGroupConditionArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleGroupConditionConditionArgs']]],
                 group_operator: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleGroupConditionConditionArgs']]] conditions: A list of nested conditions in this group.
        :param pulumi.Input[_builtins.str] group_operator: Logical operator for the group. Accepted values are `any` and `all`.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "group_operator", group_operator)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleGroupConditionConditionArgs']]]:
        """
        A list of nested conditions in this group.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleGroupConditionConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter(name="groupOperator")
    def group_operator(self) -> pulumi.Input[_builtins.str]:
        """
        Logical operator for the group. Accepted values are `any` and `all`.
        """
        return pulumi.get(self, "group_operator")

    @group_operator.setter
    def group_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_operator", value)


if not MYPY:
    class NgwafWorkspaceRuleGroupConditionConditionArgsDict(TypedDict):
        field: pulumi.Input[_builtins.str]
        """
        Field to inspect (e.g., `ip`, `path`).
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        value: pulumi.Input[_builtins.str]
        """
        The value to test the field against.
        """
elif False:
    NgwafWorkspaceRuleGroupConditionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafWorkspaceRuleGroupConditionConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] field: Field to inspect (e.g., `ip`, `path`).
        :param pulumi.Input[_builtins.str] operator: Operator to apply (e.g., `equals`, `contains`).
        :param pulumi.Input[_builtins.str] value: The value to test the field against.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Field to inspect (e.g., `ip`, `path`).
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value to test the field against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NgwafWorkspaceRuleMultivalConditionArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleMultivalConditionConditionArgsDict']]]
        """
        A list of nested conditions in this list.
        """
        field: pulumi.Input[_builtins.str]
        """
        Enums for multival condition field.. Accepted values are `post_parameter`, `query_parameter`, `request_cookie`, `request_header`, `response_header`, and `signal`.
        """
        group_operator: pulumi.Input[_builtins.str]
        """
        Logical operator for the group. Accepted values are `any` and `all`.
        """
        operator: pulumi.Input[_builtins.str]
        """
        Indicates whether the supplied conditions will check for existence or non-existence of matching field values. Accepted values are `exists` and `does_not_exist`.
        """
elif False:
    NgwafWorkspaceRuleMultivalConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafWorkspaceRuleMultivalConditionArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleMultivalConditionConditionArgs']]],
                 field: pulumi.Input[_builtins.str],
                 group_operator: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleMultivalConditionConditionArgs']]] conditions: A list of nested conditions in this list.
        :param pulumi.Input[_builtins.str] field: Enums for multival condition field.. Accepted values are `post_parameter`, `query_parameter`, `request_cookie`, `request_header`, `response_header`, and `signal`.
        :param pulumi.Input[_builtins.str] group_operator: Logical operator for the group. Accepted values are `any` and `all`.
        :param pulumi.Input[_builtins.str] operator: Indicates whether the supplied conditions will check for existence or non-existence of matching field values. Accepted values are `exists` and `does_not_exist`.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "group_operator", group_operator)
        pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleMultivalConditionConditionArgs']]]:
        """
        A list of nested conditions in this list.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleMultivalConditionConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Enums for multival condition field.. Accepted values are `post_parameter`, `query_parameter`, `request_cookie`, `request_header`, `response_header`, and `signal`.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter(name="groupOperator")
    def group_operator(self) -> pulumi.Input[_builtins.str]:
        """
        Logical operator for the group. Accepted values are `any` and `all`.
        """
        return pulumi.get(self, "group_operator")

    @group_operator.setter
    def group_operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_operator", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Indicates whether the supplied conditions will check for existence or non-existence of matching field values. Accepted values are `exists` and `does_not_exist`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class NgwafWorkspaceRuleMultivalConditionConditionArgsDict(TypedDict):
        field: pulumi.Input[_builtins.str]
        """
        Field to inspect (e.g., `name`, `value`, `signal_id`).
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        value: pulumi.Input[_builtins.str]
        """
        The value to test the field against.
        """
elif False:
    NgwafWorkspaceRuleMultivalConditionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafWorkspaceRuleMultivalConditionConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] field: Field to inspect (e.g., `name`, `value`, `signal_id`).
        :param pulumi.Input[_builtins.str] operator: Operator to apply (e.g., `equals`, `contains`).
        :param pulumi.Input[_builtins.str] value: The value to test the field against.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def field(self) -> pulumi.Input[_builtins.str]:
        """
        Field to inspect (e.g., `name`, `value`, `signal_id`).
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "field", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator to apply (e.g., `equals`, `contains`).
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value to test the field against.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class NgwafWorkspaceRuleRateLimitArgsDict(TypedDict):
        client_identifiers: pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleRateLimitClientIdentifierArgsDict']]]
        """
        List of client identifiers used for rate limiting. Can only be length 1 or 2.
        """
        duration: pulumi.Input[_builtins.int]
        """
        Duration in seconds for the rate limit.
        """
        interval: pulumi.Input[_builtins.int]
        """
        Time interval for the rate limit in seconds. Accepted values are 60, 600, and 3600.
        """
        signal: pulumi.Input[_builtins.str]
        """
        Reference ID of the custom signal this rule uses to count requests.
        """
        threshold: pulumi.Input[_builtins.int]
        """
        Rate limit threshold. Minimum 1 and maximum 10,000.
        """
elif False:
    NgwafWorkspaceRuleRateLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafWorkspaceRuleRateLimitArgs:
    def __init__(__self__, *,
                 client_identifiers: pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleRateLimitClientIdentifierArgs']]],
                 duration: pulumi.Input[_builtins.int],
                 interval: pulumi.Input[_builtins.int],
                 signal: pulumi.Input[_builtins.str],
                 threshold: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleRateLimitClientIdentifierArgs']]] client_identifiers: List of client identifiers used for rate limiting. Can only be length 1 or 2.
        :param pulumi.Input[_builtins.int] duration: Duration in seconds for the rate limit.
        :param pulumi.Input[_builtins.int] interval: Time interval for the rate limit in seconds. Accepted values are 60, 600, and 3600.
        :param pulumi.Input[_builtins.str] signal: Reference ID of the custom signal this rule uses to count requests.
        :param pulumi.Input[_builtins.int] threshold: Rate limit threshold. Minimum 1 and maximum 10,000.
        """
        pulumi.set(__self__, "client_identifiers", client_identifiers)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "signal", signal)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter(name="clientIdentifiers")
    def client_identifiers(self) -> pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleRateLimitClientIdentifierArgs']]]:
        """
        List of client identifiers used for rate limiting. Can only be length 1 or 2.
        """
        return pulumi.get(self, "client_identifiers")

    @client_identifiers.setter
    def client_identifiers(self, value: pulumi.Input[Sequence[pulumi.Input['NgwafWorkspaceRuleRateLimitClientIdentifierArgs']]]):
        pulumi.set(self, "client_identifiers", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> pulumi.Input[_builtins.int]:
        """
        Duration in seconds for the rate limit.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> pulumi.Input[_builtins.int]:
        """
        Time interval for the rate limit in seconds. Accepted values are 60, 600, and 3600.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def signal(self) -> pulumi.Input[_builtins.str]:
        """
        Reference ID of the custom signal this rule uses to count requests.
        """
        return pulumi.get(self, "signal")

    @signal.setter
    def signal(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "signal", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.int]:
        """
        Rate limit threshold. Minimum 1 and maximum 10,000.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class NgwafWorkspaceRuleRateLimitClientIdentifierArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of the Client Identifier. Accepted values are `ip`, `post_parameter`, `request_cookie`, `request_header`, and `signal_payload`.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key for the Client Identifier.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name for the Client Identifier.
        """
elif False:
    NgwafWorkspaceRuleRateLimitClientIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NgwafWorkspaceRuleRateLimitClientIdentifierArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of the Client Identifier. Accepted values are `ip`, `post_parameter`, `request_cookie`, `request_header`, and `signal_payload`.
        :param pulumi.Input[_builtins.str] key: Key for the Client Identifier.
        :param pulumi.Input[_builtins.str] name: Name for the Client Identifier.
        """
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the Client Identifier. Accepted values are `ip`, `post_parameter`, `request_cookie`, `request_header`, and `signal_payload`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key for the Client Identifier.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name for the Client Identifier.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ServiceACLEntriesEntryArgsDict(TypedDict):
        ip: pulumi.Input[_builtins.str]
        """
        An IP address that is the focus for the ACL
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        A personal freeform descriptive note
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique ID of the entry
        """
        negated: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A boolean that will negate the match if true
        """
        subnet: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional subnet mask applied to the IP address
        """
elif False:
    ServiceACLEntriesEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceACLEntriesEntryArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 negated: Optional[pulumi.Input[_builtins.bool]] = None,
                 subnet: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ip: An IP address that is the focus for the ACL
        :param pulumi.Input[_builtins.str] comment: A personal freeform descriptive note
        :param pulumi.Input[_builtins.str] id: The unique ID of the entry
        :param pulumi.Input[_builtins.bool] negated: A boolean that will negate the match if true
        :param pulumi.Input[_builtins.str] subnet: An optional subnet mask applied to the IP address
        """
        pulumi.set(__self__, "ip", ip)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if negated is not None:
            pulumi.set(__self__, "negated", negated)
        if subnet is not None:
            pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> pulumi.Input[_builtins.str]:
        """
        An IP address that is the focus for the ACL
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A personal freeform descriptive note
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique ID of the entry
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def negated(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A boolean that will negate the match if true
        """
        return pulumi.get(self, "negated")

    @negated.setter
    def negated(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "negated", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional subnet mask applied to the IP address
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subnet", value)


if not MYPY:
    class ServiceComputeBackendArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        An IPv4, hostname, or IPv6 address for the Backend
        """
        name: pulumi.Input[_builtins.str]
        """
        Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        """
        between_bytes_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        How long to wait between bytes in milliseconds. Default `10000`
        """
        connect_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        How long to wait for a timeout in milliseconds. Default `1000`
        """
        error_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of errors to allow before the Backend is marked as down. Default `0`
        """
        first_byte_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        How long to wait for the first bytes in milliseconds. Default `15000`
        """
        healthcheck: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a defined `healthcheck` to assign to this backend
        """
        keepalive_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        How long in seconds to keep a persistent connection to the backend between requests.
        """
        max_conn: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of connections for this Backend. Default `200`
        """
        max_tls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum allowed TLS version on SSL connections to this backend.
        """
        min_tls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum allowed TLS version on SSL connections to this backend.
        """
        override_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname to override the Host header
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number on which the Backend responds. Default `80`
        """
        prefer_ipv6: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Prefer IPv6 connections to origins for hostname backends. Default `true`
        """
        share_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value that when shared across backends will enable those backends to share the same health check.
        """
        shield: NotRequired[pulumi.Input[_builtins.str]]
        """
        The POP of the shield designated to reduce inbound load. Valid values for `shield` are included in the `GET /datacenters` API response
        """
        ssl_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        CA certificate attached to origin.
        """
        ssl_cert_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure certificate validation. Does not affect SNI at all
        """
        ssl_check_cert: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Be strict about checking SSL certs. Default `true`
        """
        ssl_ciphers: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cipher list consisting of one or more cipher strings separated by colons. Commas or spaces are also acceptable separators but colons are normally used.
        """
        ssl_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client certificate attached to origin. Used when connecting to the backend
        """
        ssl_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client key attached to origin. Used when connecting to the backend
        """
        ssl_sni_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure SNI in the TLS handshake. Does not affect cert validation at all
        """
        use_ssl: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to use SSL to reach the Backend. Default `false`
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The [portion of traffic](https://docs.fastly.com/en/guides/load-balancing-configuration#how-weight-affects-load-balancing) to send to this Backend. Each Backend receives weight / total of the traffic. Default `100`
        """
elif False:
    ServiceComputeBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeBackendArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 between_bytes_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 connect_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 error_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 first_byte_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 healthcheck: Optional[pulumi.Input[_builtins.str]] = None,
                 keepalive_time: Optional[pulumi.Input[_builtins.int]] = None,
                 max_conn: Optional[pulumi.Input[_builtins.int]] = None,
                 max_tls_version: Optional[pulumi.Input[_builtins.str]] = None,
                 min_tls_version: Optional[pulumi.Input[_builtins.str]] = None,
                 override_host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 prefer_ipv6: Optional[pulumi.Input[_builtins.bool]] = None,
                 share_key: Optional[pulumi.Input[_builtins.str]] = None,
                 shield: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_cert_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_check_cert: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssl_ciphers: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_sni_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 use_ssl: Optional[pulumi.Input[_builtins.bool]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] address: An IPv4, hostname, or IPv6 address for the Backend
        :param pulumi.Input[_builtins.str] name: Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.int] between_bytes_timeout: How long to wait between bytes in milliseconds. Default `10000`
        :param pulumi.Input[_builtins.int] connect_timeout: How long to wait for a timeout in milliseconds. Default `1000`
        :param pulumi.Input[_builtins.int] error_threshold: Number of errors to allow before the Backend is marked as down. Default `0`
        :param pulumi.Input[_builtins.int] first_byte_timeout: How long to wait for the first bytes in milliseconds. Default `15000`
        :param pulumi.Input[_builtins.str] healthcheck: Name of a defined `healthcheck` to assign to this backend
        :param pulumi.Input[_builtins.int] keepalive_time: How long in seconds to keep a persistent connection to the backend between requests.
        :param pulumi.Input[_builtins.int] max_conn: Maximum number of connections for this Backend. Default `200`
        :param pulumi.Input[_builtins.str] max_tls_version: Maximum allowed TLS version on SSL connections to this backend.
        :param pulumi.Input[_builtins.str] min_tls_version: Minimum allowed TLS version on SSL connections to this backend.
        :param pulumi.Input[_builtins.str] override_host: The hostname to override the Host header
        :param pulumi.Input[_builtins.int] port: The port number on which the Backend responds. Default `80`
        :param pulumi.Input[_builtins.bool] prefer_ipv6: Prefer IPv6 connections to origins for hostname backends. Default `true`
        :param pulumi.Input[_builtins.str] share_key: Value that when shared across backends will enable those backends to share the same health check.
        :param pulumi.Input[_builtins.str] shield: The POP of the shield designated to reduce inbound load. Valid values for `shield` are included in the `GET /datacenters` API response
        :param pulumi.Input[_builtins.str] ssl_ca_cert: CA certificate attached to origin.
        :param pulumi.Input[_builtins.str] ssl_cert_hostname: Configure certificate validation. Does not affect SNI at all
        :param pulumi.Input[_builtins.bool] ssl_check_cert: Be strict about checking SSL certs. Default `true`
        :param pulumi.Input[_builtins.str] ssl_ciphers: Cipher list consisting of one or more cipher strings separated by colons. Commas or spaces are also acceptable separators but colons are normally used.
        :param pulumi.Input[_builtins.str] ssl_client_cert: Client certificate attached to origin. Used when connecting to the backend
        :param pulumi.Input[_builtins.str] ssl_client_key: Client key attached to origin. Used when connecting to the backend
        :param pulumi.Input[_builtins.str] ssl_sni_hostname: Configure SNI in the TLS handshake. Does not affect cert validation at all
        :param pulumi.Input[_builtins.bool] use_ssl: Whether or not to use SSL to reach the Backend. Default `false`
        :param pulumi.Input[_builtins.int] weight: The [portion of traffic](https://docs.fastly.com/en/guides/load-balancing-configuration#how-weight-affects-load-balancing) to send to this Backend. Each Backend receives weight / total of the traffic. Default `100`
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if between_bytes_timeout is not None:
            pulumi.set(__self__, "between_bytes_timeout", between_bytes_timeout)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if error_threshold is not None:
            pulumi.set(__self__, "error_threshold", error_threshold)
        if first_byte_timeout is not None:
            pulumi.set(__self__, "first_byte_timeout", first_byte_timeout)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if keepalive_time is not None:
            pulumi.set(__self__, "keepalive_time", keepalive_time)
        if max_conn is not None:
            pulumi.set(__self__, "max_conn", max_conn)
        if max_tls_version is not None:
            pulumi.set(__self__, "max_tls_version", max_tls_version)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefer_ipv6 is not None:
            pulumi.set(__self__, "prefer_ipv6", prefer_ipv6)
        if share_key is not None:
            pulumi.set(__self__, "share_key", share_key)
        if shield is not None:
            pulumi.set(__self__, "shield", shield)
        if ssl_ca_cert is not None:
            pulumi.set(__self__, "ssl_ca_cert", ssl_ca_cert)
        if ssl_cert_hostname is not None:
            pulumi.set(__self__, "ssl_cert_hostname", ssl_cert_hostname)
        if ssl_check_cert is not None:
            pulumi.set(__self__, "ssl_check_cert", ssl_check_cert)
        if ssl_ciphers is not None:
            pulumi.set(__self__, "ssl_ciphers", ssl_ciphers)
        if ssl_client_cert is not None:
            pulumi.set(__self__, "ssl_client_cert", ssl_client_cert)
        if ssl_client_key is not None:
            pulumi.set(__self__, "ssl_client_key", ssl_client_key)
        if ssl_sni_hostname is not None:
            pulumi.set(__self__, "ssl_sni_hostname", ssl_sni_hostname)
        if use_ssl is not None:
            pulumi.set(__self__, "use_ssl", use_ssl)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4, hostname, or IPv6 address for the Backend
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="betweenBytesTimeout")
    def between_bytes_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How long to wait between bytes in milliseconds. Default `10000`
        """
        return pulumi.get(self, "between_bytes_timeout")

    @between_bytes_timeout.setter
    def between_bytes_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "between_bytes_timeout", value)

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How long to wait for a timeout in milliseconds. Default `1000`
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_timeout", value)

    @_builtins.property
    @pulumi.getter(name="errorThreshold")
    def error_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of errors to allow before the Backend is marked as down. Default `0`
        """
        return pulumi.get(self, "error_threshold")

    @error_threshold.setter
    def error_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "error_threshold", value)

    @_builtins.property
    @pulumi.getter(name="firstByteTimeout")
    def first_byte_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How long to wait for the first bytes in milliseconds. Default `15000`
        """
        return pulumi.get(self, "first_byte_timeout")

    @first_byte_timeout.setter
    def first_byte_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "first_byte_timeout", value)

    @_builtins.property
    @pulumi.getter
    def healthcheck(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a defined `healthcheck` to assign to this backend
        """
        return pulumi.get(self, "healthcheck")

    @healthcheck.setter
    def healthcheck(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck", value)

    @_builtins.property
    @pulumi.getter(name="keepaliveTime")
    def keepalive_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How long in seconds to keep a persistent connection to the backend between requests.
        """
        return pulumi.get(self, "keepalive_time")

    @keepalive_time.setter
    def keepalive_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keepalive_time", value)

    @_builtins.property
    @pulumi.getter(name="maxConn")
    def max_conn(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of connections for this Backend. Default `200`
        """
        return pulumi.get(self, "max_conn")

    @max_conn.setter
    def max_conn(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_conn", value)

    @_builtins.property
    @pulumi.getter(name="maxTlsVersion")
    def max_tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum allowed TLS version on SSL connections to this backend.
        """
        return pulumi.get(self, "max_tls_version")

    @max_tls_version.setter
    def max_tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_tls_version", value)

    @_builtins.property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum allowed TLS version on SSL connections to this backend.
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_tls_version", value)

    @_builtins.property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname to override the Host header
        """
        return pulumi.get(self, "override_host")

    @override_host.setter
    def override_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number on which the Backend responds. Default `80`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="preferIpv6")
    def prefer_ipv6(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Prefer IPv6 connections to origins for hostname backends. Default `true`
        """
        return pulumi.get(self, "prefer_ipv6")

    @prefer_ipv6.setter
    def prefer_ipv6(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "prefer_ipv6", value)

    @_builtins.property
    @pulumi.getter(name="shareKey")
    def share_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value that when shared across backends will enable those backends to share the same health check.
        """
        return pulumi.get(self, "share_key")

    @share_key.setter
    def share_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "share_key", value)

    @_builtins.property
    @pulumi.getter
    def shield(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The POP of the shield designated to reduce inbound load. Valid values for `shield` are included in the `GET /datacenters` API response
        """
        return pulumi.get(self, "shield")

    @shield.setter
    def shield(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shield", value)

    @_builtins.property
    @pulumi.getter(name="sslCaCert")
    def ssl_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CA certificate attached to origin.
        """
        return pulumi.get(self, "ssl_ca_cert")

    @ssl_ca_cert.setter
    def ssl_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="sslCertHostname")
    def ssl_cert_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure certificate validation. Does not affect SNI at all
        """
        return pulumi.get(self, "ssl_cert_hostname")

    @ssl_cert_hostname.setter
    def ssl_cert_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_cert_hostname", value)

    @_builtins.property
    @pulumi.getter(name="sslCheckCert")
    def ssl_check_cert(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Be strict about checking SSL certs. Default `true`
        """
        return pulumi.get(self, "ssl_check_cert")

    @ssl_check_cert.setter
    def ssl_check_cert(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ssl_check_cert", value)

    @_builtins.property
    @pulumi.getter(name="sslCiphers")
    def ssl_ciphers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cipher list consisting of one or more cipher strings separated by colons. Commas or spaces are also acceptable separators but colons are normally used.
        """
        return pulumi.get(self, "ssl_ciphers")

    @ssl_ciphers.setter
    def ssl_ciphers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_ciphers", value)

    @_builtins.property
    @pulumi.getter(name="sslClientCert")
    def ssl_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client certificate attached to origin. Used when connecting to the backend
        """
        return pulumi.get(self, "ssl_client_cert")

    @ssl_client_cert.setter
    def ssl_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="sslClientKey")
    def ssl_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client key attached to origin. Used when connecting to the backend
        """
        return pulumi.get(self, "ssl_client_key")

    @ssl_client_key.setter
    def ssl_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_client_key", value)

    @_builtins.property
    @pulumi.getter(name="sslSniHostname")
    def ssl_sni_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure SNI in the TLS handshake. Does not affect cert validation at all
        """
        return pulumi.get(self, "ssl_sni_hostname")

    @ssl_sni_hostname.setter
    def ssl_sni_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_sni_hostname", value)

    @_builtins.property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to use SSL to reach the Backend. Default `false`
        """
        return pulumi.get(self, "use_ssl")

    @use_ssl.setter
    def use_ssl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_ssl", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The [portion of traffic](https://docs.fastly.com/en/guides/load-balancing-configuration#how-weight-affects-load-balancing) to send to this Backend. Each Backend receives weight / total of the traffic. Default `100`
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ServiceComputeDictionaryArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this dictionary. It is important to note that changing this attribute will delete and recreate the dictionary, and discard the current items in the dictionary
        """
        dictionary_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the dictionary
        """
        force_destroy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        """
        write_only: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ServiceComputeDictionaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeDictionaryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 dictionary_id: Optional[pulumi.Input[_builtins.str]] = None,
                 force_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 write_only: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A unique name to identify this dictionary. It is important to note that changing this attribute will delete and recreate the dictionary, and discard the current items in the dictionary
        :param pulumi.Input[_builtins.str] dictionary_id: The ID of the dictionary
        :param pulumi.Input[_builtins.bool] force_destroy: Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        """
        pulumi.set(__self__, "name", name)
        if dictionary_id is not None:
            pulumi.set(__self__, "dictionary_id", dictionary_id)
        if force_destroy is not None:
            pulumi.set(__self__, "force_destroy", force_destroy)
        if write_only is not None:
            pulumi.set(__self__, "write_only", write_only)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this dictionary. It is important to note that changing this attribute will delete and recreate the dictionary, and discard the current items in the dictionary
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryId")
    def dictionary_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the dictionary
        """
        return pulumi.get(self, "dictionary_id")

    @dictionary_id.setter
    def dictionary_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_id", value)

    @_builtins.property
    @pulumi.getter(name="forceDestroy")
    def force_destroy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        """
        return pulumi.get(self, "force_destroy")

    @force_destroy.setter
    def force_destroy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force_destroy", value)

    @_builtins.property
    @pulumi.getter(name="writeOnly")
    def write_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "write_only")

    @write_only.setter
    def write_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "write_only", value)


if not MYPY:
    class ServiceComputeDomainArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The domain that this Service will respond to. It is important to note that changing this attribute will delete and recreate the resource.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional comment about the Domain.
        """
elif False:
    ServiceComputeDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeDomainArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The domain that this Service will respond to. It is important to note that changing this attribute will delete and recreate the resource.
        :param pulumi.Input[_builtins.str] comment: An optional comment about the Domain.
        """
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The domain that this Service will respond to. It is important to note that changing this attribute will delete and recreate the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional comment about the Domain.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)


if not MYPY:
    class ServiceComputeHealthcheckArgsDict(TypedDict):
        host: pulumi.Input[_builtins.str]
        """
        The Host header to send for this Healthcheck
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this Healthcheck. It is important to note that changing this attribute will delete and recreate the resource
        """
        path: pulumi.Input[_builtins.str]
        """
        The path to check
        """
        check_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        How often to run the Healthcheck in milliseconds. Default `5000`
        """
        expected_response: NotRequired[pulumi.Input[_builtins.int]]
        """
        The status code expected from the host. Default `200`
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom health check HTTP headers (e.g. if your health check requires an API key to be provided).
        """
        http_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to use version 1.0 or 1.1 HTTP. Default `1.1`
        """
        initial: NotRequired[pulumi.Input[_builtins.int]]
        """
        When loading a config, the initial number of probes to be seen as OK. Default `3`
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Which HTTP method to use. Default `HEAD`
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        How many Healthchecks must succeed to be considered healthy. Default `3`
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in milliseconds. Default `5000`
        """
        window: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of most recent Healthcheck queries to keep for this Healthcheck. Default `5`
        """
elif False:
    ServiceComputeHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeHealthcheckArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 check_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 expected_response: Optional[pulumi.Input[_builtins.int]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_version: Optional[pulumi.Input[_builtins.str]] = None,
                 initial: Optional[pulumi.Input[_builtins.int]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 window: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The Host header to send for this Healthcheck
        :param pulumi.Input[_builtins.str] name: A unique name to identify this Healthcheck. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] path: The path to check
        :param pulumi.Input[_builtins.int] check_interval: How often to run the Healthcheck in milliseconds. Default `5000`
        :param pulumi.Input[_builtins.int] expected_response: The status code expected from the host. Default `200`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: Custom health check HTTP headers (e.g. if your health check requires an API key to be provided).
        :param pulumi.Input[_builtins.str] http_version: Whether to use version 1.0 or 1.1 HTTP. Default `1.1`
        :param pulumi.Input[_builtins.int] initial: When loading a config, the initial number of probes to be seen as OK. Default `3`
        :param pulumi.Input[_builtins.str] method: Which HTTP method to use. Default `HEAD`
        :param pulumi.Input[_builtins.int] threshold: How many Healthchecks must succeed to be considered healthy. Default `3`
        :param pulumi.Input[_builtins.int] timeout: Timeout in milliseconds. Default `5000`
        :param pulumi.Input[_builtins.int] window: The number of most recent Healthcheck queries to keep for this Healthcheck. Default `5`
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if expected_response is not None:
            pulumi.set(__self__, "expected_response", expected_response)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if initial is not None:
            pulumi.set(__self__, "initial", initial)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        The Host header to send for this Healthcheck
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this Healthcheck. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to check
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How often to run the Healthcheck in milliseconds. Default `5000`
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "check_interval", value)

    @_builtins.property
    @pulumi.getter(name="expectedResponse")
    def expected_response(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The status code expected from the host. Default `200`
        """
        return pulumi.get(self, "expected_response")

    @expected_response.setter
    def expected_response(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expected_response", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom health check HTTP headers (e.g. if your health check requires an API key to be provided).
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to use version 1.0 or 1.1 HTTP. Default `1.1`
        """
        return pulumi.get(self, "http_version")

    @http_version.setter
    def http_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_version", value)

    @_builtins.property
    @pulumi.getter
    def initial(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        When loading a config, the initial number of probes to be seen as OK. Default `3`
        """
        return pulumi.get(self, "initial")

    @initial.setter
    def initial(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Which HTTP method to use. Default `HEAD`
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How many Healthchecks must succeed to be considered healthy. Default `3`
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in milliseconds. Default `5000`
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def window(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of most recent Healthcheck queries to keep for this Healthcheck. Default `5`
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "window", value)


if not MYPY:
    class ServiceComputeImageOptimizerDefaultSettingsArgsDict(TypedDict):
        allow_video: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables GIF to MP4 transformations on this service.
        """
        jpeg_quality: NotRequired[pulumi.Input[_builtins.int]]
        """
        The default quality to use with JPEG output. This can be overridden with the "quality" parameter on specific image optimizer requests.
        """
        jpeg_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default type of JPEG output to use. This can be overridden with "format=bjpeg" and "format=pjpeg" on specific image optimizer requests. Valid values are `auto`, `baseline` and `progressive`.
        	- auto: Match the input JPEG type, or baseline if transforming from a non-JPEG input.
        	- baseline: Output baseline JPEG images
        	- progressive: Output progressive JPEG images
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used by the provider to identify modified settings. Changing this value will force the entire block to be deleted, then recreated.
        """
        resize_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of filter to use while resizing an image. Valid values are `lanczos3`, `lanczos2`, `bicubic`, `bilinear` and `nearest`.
        	- lanczos3: A Lanczos filter with a kernel size of 3. Lanczos filters can detect edges and linear features within an image, providing the best possible reconstruction.
        	- lanczos2: A Lanczos filter with a kernel size of 2.
        	- bicubic: A filter using an average of a 4x4 environment of pixels, weighing the innermost pixels higher.
        	- bilinear: A filter using an average of a 2x2 environment of pixels.
        	- nearest: A filter using the value of nearby translated pixel values. Preserves hard edges.
        """
        upscale: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not we should allow output images to render at sizes larger than input.
        """
        webp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Controls whether or not to default to WebP output when the client supports it. This is equivalent to adding "auto=webp" to all image optimizer requests.
        """
        webp_quality: NotRequired[pulumi.Input[_builtins.int]]
        """
        The default quality to use with WebP output. This can be overridden with the second option in the "quality" URL parameter on specific image optimizer requests.
        """
elif False:
    ServiceComputeImageOptimizerDefaultSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeImageOptimizerDefaultSettingsArgs:
    def __init__(__self__, *,
                 allow_video: Optional[pulumi.Input[_builtins.bool]] = None,
                 jpeg_quality: Optional[pulumi.Input[_builtins.int]] = None,
                 jpeg_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 resize_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 upscale: Optional[pulumi.Input[_builtins.bool]] = None,
                 webp: Optional[pulumi.Input[_builtins.bool]] = None,
                 webp_quality: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_video: Enables GIF to MP4 transformations on this service.
        :param pulumi.Input[_builtins.int] jpeg_quality: The default quality to use with JPEG output. This can be overridden with the "quality" parameter on specific image optimizer requests.
        :param pulumi.Input[_builtins.str] jpeg_type: The default type of JPEG output to use. This can be overridden with "format=bjpeg" and "format=pjpeg" on specific image optimizer requests. Valid values are `auto`, `baseline` and `progressive`.
               	- auto: Match the input JPEG type, or baseline if transforming from a non-JPEG input.
               	- baseline: Output baseline JPEG images
               	- progressive: Output progressive JPEG images
        :param pulumi.Input[_builtins.str] name: Used by the provider to identify modified settings. Changing this value will force the entire block to be deleted, then recreated.
        :param pulumi.Input[_builtins.str] resize_filter: The type of filter to use while resizing an image. Valid values are `lanczos3`, `lanczos2`, `bicubic`, `bilinear` and `nearest`.
               	- lanczos3: A Lanczos filter with a kernel size of 3. Lanczos filters can detect edges and linear features within an image, providing the best possible reconstruction.
               	- lanczos2: A Lanczos filter with a kernel size of 2.
               	- bicubic: A filter using an average of a 4x4 environment of pixels, weighing the innermost pixels higher.
               	- bilinear: A filter using an average of a 2x2 environment of pixels.
               	- nearest: A filter using the value of nearby translated pixel values. Preserves hard edges.
        :param pulumi.Input[_builtins.bool] upscale: Whether or not we should allow output images to render at sizes larger than input.
        :param pulumi.Input[_builtins.bool] webp: Controls whether or not to default to WebP output when the client supports it. This is equivalent to adding "auto=webp" to all image optimizer requests.
        :param pulumi.Input[_builtins.int] webp_quality: The default quality to use with WebP output. This can be overridden with the second option in the "quality" URL parameter on specific image optimizer requests.
        """
        if allow_video is not None:
            pulumi.set(__self__, "allow_video", allow_video)
        if jpeg_quality is not None:
            pulumi.set(__self__, "jpeg_quality", jpeg_quality)
        if jpeg_type is not None:
            pulumi.set(__self__, "jpeg_type", jpeg_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resize_filter is not None:
            pulumi.set(__self__, "resize_filter", resize_filter)
        if upscale is not None:
            pulumi.set(__self__, "upscale", upscale)
        if webp is not None:
            pulumi.set(__self__, "webp", webp)
        if webp_quality is not None:
            pulumi.set(__self__, "webp_quality", webp_quality)

    @_builtins.property
    @pulumi.getter(name="allowVideo")
    def allow_video(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables GIF to MP4 transformations on this service.
        """
        return pulumi.get(self, "allow_video")

    @allow_video.setter
    def allow_video(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_video", value)

    @_builtins.property
    @pulumi.getter(name="jpegQuality")
    def jpeg_quality(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The default quality to use with JPEG output. This can be overridden with the "quality" parameter on specific image optimizer requests.
        """
        return pulumi.get(self, "jpeg_quality")

    @jpeg_quality.setter
    def jpeg_quality(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "jpeg_quality", value)

    @_builtins.property
    @pulumi.getter(name="jpegType")
    def jpeg_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default type of JPEG output to use. This can be overridden with "format=bjpeg" and "format=pjpeg" on specific image optimizer requests. Valid values are `auto`, `baseline` and `progressive`.
        	- auto: Match the input JPEG type, or baseline if transforming from a non-JPEG input.
        	- baseline: Output baseline JPEG images
        	- progressive: Output progressive JPEG images
        """
        return pulumi.get(self, "jpeg_type")

    @jpeg_type.setter
    def jpeg_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jpeg_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used by the provider to identify modified settings. Changing this value will force the entire block to be deleted, then recreated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="resizeFilter")
    def resize_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of filter to use while resizing an image. Valid values are `lanczos3`, `lanczos2`, `bicubic`, `bilinear` and `nearest`.
        	- lanczos3: A Lanczos filter with a kernel size of 3. Lanczos filters can detect edges and linear features within an image, providing the best possible reconstruction.
        	- lanczos2: A Lanczos filter with a kernel size of 2.
        	- bicubic: A filter using an average of a 4x4 environment of pixels, weighing the innermost pixels higher.
        	- bilinear: A filter using an average of a 2x2 environment of pixels.
        	- nearest: A filter using the value of nearby translated pixel values. Preserves hard edges.
        """
        return pulumi.get(self, "resize_filter")

    @resize_filter.setter
    def resize_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resize_filter", value)

    @_builtins.property
    @pulumi.getter
    def upscale(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not we should allow output images to render at sizes larger than input.
        """
        return pulumi.get(self, "upscale")

    @upscale.setter
    def upscale(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "upscale", value)

    @_builtins.property
    @pulumi.getter
    def webp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Controls whether or not to default to WebP output when the client supports it. This is equivalent to adding "auto=webp" to all image optimizer requests.
        """
        return pulumi.get(self, "webp")

    @webp.setter
    def webp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "webp", value)

    @_builtins.property
    @pulumi.getter(name="webpQuality")
    def webp_quality(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The default quality to use with WebP output. This can be overridden with the second option in the "quality" URL parameter on specific image optimizer requests.
        """
        return pulumi.get(self, "webp_quality")

    @webp_quality.setter
    def webp_quality(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "webp_quality", value)


if not MYPY:
    class ServiceComputeLoggingBigqueryArgsDict(TypedDict):
        dataset: pulumi.Input[_builtins.str]
        """
        The ID of your BigQuery dataset
        """
        email: pulumi.Input[_builtins.str]
        """
        The email for the service account with write access to your BigQuery dataset. If not provided, this will be pulled from a `FASTLY_BQ_EMAIL` environment variable
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this BigQuery logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        project_id: pulumi.Input[_builtins.str]
        """
        The ID of your GCP project
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        The secret key associated with the service account that has write access to your BigQuery table. If not provided, this will be pulled from the `FASTLY_BQ_SECRET_KEY` environment variable. Typical format for this is a private key in a string with newlines
        """
        table: pulumi.Input[_builtins.str]
        """
        The ID of your BigQuery table
        """
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The google account name used to obtain temporary credentials (default none). Not required if 'email' and 'secret_key' are provided. You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        template: NotRequired[pulumi.Input[_builtins.str]]
        """
        BigQuery table name suffix template
        """
elif False:
    ServiceComputeLoggingBigqueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingBigqueryArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input[_builtins.str],
                 email: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 table: pulumi.Input[_builtins.str],
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: The ID of your BigQuery dataset
        :param pulumi.Input[_builtins.str] email: The email for the service account with write access to your BigQuery dataset. If not provided, this will be pulled from a `FASTLY_BQ_EMAIL` environment variable
        :param pulumi.Input[_builtins.str] name: A unique name to identify this BigQuery logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] project_id: The ID of your GCP project
        :param pulumi.Input[_builtins.str] secret_key: The secret key associated with the service account that has write access to your BigQuery table. If not provided, this will be pulled from the `FASTLY_BQ_SECRET_KEY` environment variable. Typical format for this is a private key in a string with newlines
        :param pulumi.Input[_builtins.str] table: The ID of your BigQuery table
        :param pulumi.Input[_builtins.str] account_name: The google account name used to obtain temporary credentials (default none). Not required if 'email' and 'secret_key' are provided. You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] template: BigQuery table name suffix template
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "table", table)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your BigQuery dataset
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email for the service account with write access to your BigQuery dataset. If not provided, this will be pulled from a `FASTLY_BQ_EMAIL` environment variable
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this BigQuery logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your GCP project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        The secret key associated with the service account that has write access to your BigQuery table. If not provided, this will be pulled from the `FASTLY_BQ_SECRET_KEY` environment variable. Typical format for this is a private key in a string with newlines
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def table(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your BigQuery table
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table", value)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The google account name used to obtain temporary credentials (default none). Not required if 'email' and 'secret_key' are provided. You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BigQuery table name suffix template
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class ServiceComputeLoggingBlobstorageArgsDict(TypedDict):
        account_name: pulumi.Input[_builtins.str]
        """
        The unique Azure Blob Storage namespace in which your data objects are stored
        """
        container: pulumi.Input[_builtins.str]
        """
        The name of the Azure Blob Storage container in which to store logs
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify the Azure Blob Storage endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        sas_token: pulumi.Input[_builtins.str]
        """
        The Azure shared access signature providing write access to the blob service objects. Be sure to update your token before it expires or the logging functionality will not work
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        file_max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum size of an uploaded log file, if non-zero.
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to upload logs to. Must end with a trailing slash. If this field is left empty, the files will be saved in the container's root path
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently the logs should be transferred in seconds. Default `3600`
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceComputeLoggingBlobstorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingBlobstorageArgs:
    def __init__(__self__, *,
                 account_name: pulumi.Input[_builtins.str],
                 container: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 sas_token: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 file_max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_name: The unique Azure Blob Storage namespace in which your data objects are stored
        :param pulumi.Input[_builtins.str] container: The name of the Azure Blob Storage container in which to store logs
        :param pulumi.Input[_builtins.str] name: A unique name to identify the Azure Blob Storage endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] sas_token: The Azure shared access signature providing write access to the blob service objects. Be sure to update your token before it expires or the logging functionality will not work
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.int] file_max_bytes: Maximum size of an uploaded log file, if non-zero.
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: The path to upload logs to. Must end with a trailing slash. If this field is left empty, the files will be saved in the container's root path
        :param pulumi.Input[_builtins.int] period: How frequently the logs should be transferred in seconds. Default `3600`
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sas_token", sas_token)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if file_max_bytes is not None:
            pulumi.set(__self__, "file_max_bytes", file_max_bytes)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique Azure Blob Storage namespace in which your data objects are stored
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter
    def container(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Azure Blob Storage container in which to store logs
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify the Azure Blob Storage endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> pulumi.Input[_builtins.str]:
        """
        The Azure shared access signature providing write access to the blob service objects. Be sure to update your token before it expires or the logging functionality will not work
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sas_token", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter(name="fileMaxBytes")
    def file_max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum size of an uploaded log file, if non-zero.
        """
        return pulumi.get(self, "file_max_bytes")

    @file_max_bytes.setter
    def file_max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "file_max_bytes", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to upload logs to. Must end with a trailing slash. If this field is left empty, the files will be saved in the container's root path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently the logs should be transferred in seconds. Default `3600`
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceComputeLoggingCloudfileArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        Your Cloud File account access key
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of your Cloud Files container
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Rackspace Cloud Files logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        user: pulumi.Input[_builtins.str]
        """
        The username for your Cloud Files account
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to upload logs to
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region to stream logs to. One of: DFW (Dallas), ORD (Chicago), IAD (Northern Virginia), LON (London), SYD (Sydney), HKG (Hong Kong)
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceComputeLoggingCloudfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingCloudfileArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 bucket_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: Your Cloud File account access key
        :param pulumi.Input[_builtins.str] bucket_name: The name of your Cloud Files container
        :param pulumi.Input[_builtins.str] name: The unique name of the Rackspace Cloud Files logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] user: The username for your Cloud Files account
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: The path to upload logs to
        :param pulumi.Input[_builtins.int] period: How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] region: The region to stream logs to. One of: DFW (Dallas), ORD (Chicago), IAD (Northern Virginia), LON (London), SYD (Sydney), HKG (Hong Kong)
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "user", user)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your Cloud File account access key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of your Cloud Files container
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Rackspace Cloud Files logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The username for your Cloud Files account
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to upload logs to
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region to stream logs to. One of: DFW (Dallas), ORD (Chicago), IAD (Northern Virginia), LON (London), SYD (Sydney), HKG (Hong Kong)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceComputeLoggingDatadogArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Datadog logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The API key from your Datadog account
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region that log data will be sent to. Defaults to `US` if undefined
        """
elif False:
    ServiceComputeLoggingDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingDatadogArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Datadog logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The API key from your Datadog account
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] region: The region that log data will be sent to. Defaults to `US` if undefined
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Datadog logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The API key from your Datadog account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region that log data will be sent to. Defaults to `US` if undefined
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ServiceComputeLoggingDigitaloceanArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        Your DigitalOcean Spaces account access key
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of the DigitalOcean Space
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the DigitalOcean Spaces logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        Your DigitalOcean Spaces account secret key
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to upload logs to
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceComputeLoggingDigitaloceanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingDigitaloceanArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 bucket_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: Your DigitalOcean Spaces account access key
        :param pulumi.Input[_builtins.str] bucket_name: The name of the DigitalOcean Space
        :param pulumi.Input[_builtins.str] name: The unique name of the DigitalOcean Spaces logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] secret_key: Your DigitalOcean Spaces account secret key
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] domain: The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: The path to upload logs to
        :param pulumi.Input[_builtins.int] period: How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your DigitalOcean Spaces account access key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the DigitalOcean Space
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the DigitalOcean Spaces logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your DigitalOcean Spaces account secret key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to upload logs to
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceComputeLoggingElasticsearchArgsDict(TypedDict):
        index: pulumi.Input[_builtins.str]
        """
        The name of the Elasticsearch index to send documents (logs) to
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Elasticsearch logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        url: pulumi.Input[_builtins.str]
        """
        The Elasticsearch URL to stream logs to
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        BasicAuth password for Elasticsearch
        """
        pipeline: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Elasticsearch ingest pipeline to apply pre-process transformations to before indexing
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        request_max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of logs sent in one request. Defaults to `0` for unbounded
        """
        request_max_entries: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of bytes sent in one request. Defaults to `0` for unbounded
        """
        tls_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        tls_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        tls_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname used to verify the server's certificate. It can either be the Common Name (CN) or a Subject Alternative Name (SAN)
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        BasicAuth username for Elasticsearch
        """
elif False:
    ServiceComputeLoggingElasticsearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingElasticsearchArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 pipeline: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 request_max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 request_max_entries: Optional[pulumi.Input[_builtins.int]] = None,
                 tls_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] index: The name of the Elasticsearch index to send documents (logs) to
        :param pulumi.Input[_builtins.str] name: The unique name of the Elasticsearch logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] url: The Elasticsearch URL to stream logs to
        :param pulumi.Input[_builtins.str] password: BasicAuth password for Elasticsearch
        :param pulumi.Input[_builtins.str] pipeline: The ID of the Elasticsearch ingest pipeline to apply pre-process transformations to before indexing
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.int] request_max_bytes: The maximum number of logs sent in one request. Defaults to `0` for unbounded
        :param pulumi.Input[_builtins.int] request_max_entries: The maximum number of bytes sent in one request. Defaults to `0` for unbounded
        :param pulumi.Input[_builtins.str] tls_ca_cert: A secure certificate to authenticate the server with. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_cert: The client certificate used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_key: The client private key used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_hostname: The hostname used to verify the server's certificate. It can either be the Common Name (CN) or a Subject Alternative Name (SAN)
        :param pulumi.Input[_builtins.str] user: BasicAuth username for Elasticsearch
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if request_max_bytes is not None:
            pulumi.set(__self__, "request_max_bytes", request_max_bytes)
        if request_max_entries is not None:
            pulumi.set(__self__, "request_max_entries", request_max_entries)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def index(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Elasticsearch index to send documents (logs) to
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Elasticsearch logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The Elasticsearch URL to stream logs to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BasicAuth password for Elasticsearch
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Elasticsearch ingest pipeline to apply pre-process transformations to before indexing
        """
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pipeline", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="requestMaxBytes")
    def request_max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of logs sent in one request. Defaults to `0` for unbounded
        """
        return pulumi.get(self, "request_max_bytes")

    @request_max_bytes.setter
    def request_max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_max_bytes", value)

    @_builtins.property
    @pulumi.getter(name="requestMaxEntries")
    def request_max_entries(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of bytes sent in one request. Defaults to `0` for unbounded
        """
        return pulumi.get(self, "request_max_entries")

    @request_max_entries.setter
    def request_max_entries(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_max_entries", value)

    @_builtins.property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        return pulumi.get(self, "tls_ca_cert")

    @tls_ca_cert.setter
    def tls_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname used to verify the server's certificate. It can either be the Common Name (CN) or a Subject Alternative Name (SAN)
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BasicAuth username for Elasticsearch
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ServiceComputeLoggingFtpArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        The FTP address to stream logs to
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the FTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        password: pulumi.Input[_builtins.str]
        """
        The password for the server (for anonymous use an email address)
        """
        path: pulumi.Input[_builtins.str]
        """
        The path to upload log files to. If the path ends in `/` then it is treated as a directory
        """
        user: pulumi.Input[_builtins.str]
        """
        The username for the server (can be `anonymous`)
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently the logs should be transferred, in seconds (Default `3600`)
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number. Default: `21`
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceComputeLoggingFtpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingFtpArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The FTP address to stream logs to
        :param pulumi.Input[_builtins.str] name: The unique name of the FTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] password: The password for the server (for anonymous use an email address)
        :param pulumi.Input[_builtins.str] path: The path to upload log files to. If the path ends in `/` then it is treated as a directory
        :param pulumi.Input[_builtins.str] user: The username for the server (can be `anonymous`)
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.int] period: How frequently the logs should be transferred, in seconds (Default `3600`)
        :param pulumi.Input[_builtins.int] port: The port number. Default: `21`
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "user", user)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        The FTP address to stream logs to
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the FTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        The password for the server (for anonymous use an email address)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to upload log files to. If the path ends in `/` then it is treated as a directory
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The username for the server (can be `anonymous`)
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently the logs should be transferred, in seconds (Default `3600`)
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number. Default: `21`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceComputeLoggingGcArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of the bucket in which to store the logs
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this GCS endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently the logs should be transferred, in seconds (Default 3600)
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of your Google Cloud Platform project
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret key associated with the target gcs bucket on your account. You may optionally provide this secret via an environment variable, `FASTLY_GCS_SECRET_KEY`. A typical format for the key is PEM format, containing actual newline characters where required
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GCS_EMAIL`.
        """
elif False:
    ServiceComputeLoggingGcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingGcArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The name of the bucket in which to store the logs
        :param pulumi.Input[_builtins.str] name: A unique name to identify this GCS endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] account_name: The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        :param pulumi.Input[_builtins.int] period: How frequently the logs should be transferred, in seconds (Default 3600)
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] project_id: The ID of your Google Cloud Platform project
        :param pulumi.Input[_builtins.str] secret_key: The secret key associated with the target gcs bucket on your account. You may optionally provide this secret via an environment variable, `FASTLY_GCS_SECRET_KEY`. A typical format for the key is PEM format, containing actual newline characters where required
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        :param pulumi.Input[_builtins.str] user: Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GCS_EMAIL`.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the bucket in which to store the logs
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this GCS endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently the logs should be transferred, in seconds (Default 3600)
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of your Google Cloud Platform project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret key associated with the target gcs bucket on your account. You may optionally provide this secret via an environment variable, `FASTLY_GCS_SECRET_KEY`. A typical format for the key is PEM format, containing actual newline characters where required
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GCS_EMAIL`.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ServiceComputeLoggingGooglepubsubArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Google Cloud Pub/Sub logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        project_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Cloud Platform project
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        Your Google Cloud Platform account secret key. The `private_key` field in your service account authentication JSON. You may optionally provide this secret via an environment variable, `FASTLY_GOOGLE_PUBSUB_SECRET_KEY`.
        """
        topic: pulumi.Input[_builtins.str]
        """
        The Google Cloud Pub/Sub topic to which logs will be published
        """
        user: pulumi.Input[_builtins.str]
        """
        Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GOOGLE_PUBSUB_EMAIL`.
        """
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
elif False:
    ServiceComputeLoggingGooglepubsubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingGooglepubsubArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Google Cloud Pub/Sub logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] project_id: The ID of your Google Cloud Platform project
        :param pulumi.Input[_builtins.str] secret_key: Your Google Cloud Platform account secret key. The `private_key` field in your service account authentication JSON. You may optionally provide this secret via an environment variable, `FASTLY_GOOGLE_PUBSUB_SECRET_KEY`.
        :param pulumi.Input[_builtins.str] topic: The Google Cloud Pub/Sub topic to which logs will be published
        :param pulumi.Input[_builtins.str] user: Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GOOGLE_PUBSUB_EMAIL`.
        :param pulumi.Input[_builtins.str] account_name: The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "topic", topic)
        pulumi.set(__self__, "user", user)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Google Cloud Pub/Sub logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Cloud Platform project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your Google Cloud Platform account secret key. The `private_key` field in your service account authentication JSON. You may optionally provide this secret via an environment variable, `FASTLY_GOOGLE_PUBSUB_SECRET_KEY`.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        The Google Cloud Pub/Sub topic to which logs will be published
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GOOGLE_PUBSUB_EMAIL`.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)


if not MYPY:
    class ServiceComputeLoggingGrafanacloudlogArgsDict(TypedDict):
        index: pulumi.Input[_builtins.str]
        """
        The stream identifier as a JSON string
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the GrafanaCloudLogs logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The Access Policy Token key for your GrafanaCloudLogs account
        """
        url: pulumi.Input[_builtins.str]
        """
        The URL to stream logs to
        """
        user: pulumi.Input[_builtins.str]
        """
        The Grafana User ID
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
elif False:
    ServiceComputeLoggingGrafanacloudlogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingGrafanacloudlogArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] index: The stream identifier as a JSON string
        :param pulumi.Input[_builtins.str] name: The unique name of the GrafanaCloudLogs logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The Access Policy Token key for your GrafanaCloudLogs account
        :param pulumi.Input[_builtins.str] url: The URL to stream logs to
        :param pulumi.Input[_builtins.str] user: The Grafana User ID
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "user", user)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)

    @_builtins.property
    @pulumi.getter
    def index(self) -> pulumi.Input[_builtins.str]:
        """
        The stream identifier as a JSON string
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the GrafanaCloudLogs logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Access Policy Token key for your GrafanaCloudLogs account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL to stream logs to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The Grafana User ID
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)


if not MYPY:
    class ServiceComputeLoggingHerokuArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Heroku logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The token to use for authentication (https://www.heroku.com/docs/customer-token-authentication-token/)
        """
        url: pulumi.Input[_builtins.str]
        """
        The URL to stream logs to
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
elif False:
    ServiceComputeLoggingHerokuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingHerokuArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Heroku logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The token to use for authentication (https://www.heroku.com/docs/customer-token-authentication-token/)
        :param pulumi.Input[_builtins.str] url: The URL to stream logs to
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Heroku logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The token to use for authentication (https://www.heroku.com/docs/customer-token-authentication-token/)
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL to stream logs to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)


if not MYPY:
    class ServiceComputeLoggingHoneycombArgsDict(TypedDict):
        dataset: pulumi.Input[_builtins.str]
        """
        The Honeycomb Dataset you want to log to
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Honeycomb logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The Write Key from the Account page of your Honeycomb account
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
elif False:
    ServiceComputeLoggingHoneycombArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingHoneycombArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: The Honeycomb Dataset you want to log to
        :param pulumi.Input[_builtins.str] name: The unique name of the Honeycomb logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The Write Key from the Account page of your Honeycomb account
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> pulumi.Input[_builtins.str]:
        """
        The Honeycomb Dataset you want to log to
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Honeycomb logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Write Key from the Account page of your Honeycomb account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)


if not MYPY:
    class ServiceComputeLoggingHttpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the HTTPS logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        url: pulumi.Input[_builtins.str]
        """
        URL that log data will be sent to. Must use the https protocol
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the `Content-Type` header sent with the request
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom header sent with the request
        """
        header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the custom header sent with the request
        """
        json_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Formats log entries as JSON. Can be either disabled (`0`), array of json (`1`), or newline delimited json (`2`)
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP method used for request. Can be either `POST` or `PUT`. Default `POST`
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently, in seconds, batches of log data are sent to the HTTPS endpoint. A value of 0 sends logs at the same interval as the default, which is 5 seconds.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        request_max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of bytes sent in one request
        """
        request_max_entries: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of logs sent in one request
        """
        tls_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        tls_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        tls_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used during the TLS handshake to validate the certificate
        """
elif False:
    ServiceComputeLoggingHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingHttpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 header_value: Optional[pulumi.Input[_builtins.str]] = None,
                 json_format: Optional[pulumi.Input[_builtins.str]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 request_max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 request_max_entries: Optional[pulumi.Input[_builtins.int]] = None,
                 tls_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the HTTPS logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] url: URL that log data will be sent to. Must use the https protocol
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] content_type: Value of the `Content-Type` header sent with the request
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] header_name: Custom header sent with the request
        :param pulumi.Input[_builtins.str] header_value: Value of the custom header sent with the request
        :param pulumi.Input[_builtins.str] json_format: Formats log entries as JSON. Can be either disabled (`0`), array of json (`1`), or newline delimited json (`2`)
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] method: HTTP method used for request. Can be either `POST` or `PUT`. Default `POST`
        :param pulumi.Input[_builtins.int] period: How frequently, in seconds, batches of log data are sent to the HTTPS endpoint. A value of 0 sends logs at the same interval as the default, which is 5 seconds.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.int] request_max_bytes: The maximum number of bytes sent in one request
        :param pulumi.Input[_builtins.int] request_max_entries: The maximum number of logs sent in one request
        :param pulumi.Input[_builtins.str] tls_ca_cert: A secure certificate to authenticate the server with. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_cert: The client certificate used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_key: The client private key used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_hostname: Used during the TLS handshake to validate the certificate
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if json_format is not None:
            pulumi.set(__self__, "json_format", json_format)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if request_max_bytes is not None:
            pulumi.set(__self__, "request_max_bytes", request_max_bytes)
        if request_max_entries is not None:
            pulumi.set(__self__, "request_max_entries", request_max_entries)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the HTTPS logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        URL that log data will be sent to. Must use the https protocol
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the `Content-Type` header sent with the request
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom header sent with the request
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the custom header sent with the request
        """
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_value", value)

    @_builtins.property
    @pulumi.getter(name="jsonFormat")
    def json_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Formats log entries as JSON. Can be either disabled (`0`), array of json (`1`), or newline delimited json (`2`)
        """
        return pulumi.get(self, "json_format")

    @json_format.setter
    def json_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json_format", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP method used for request. Can be either `POST` or `PUT`. Default `POST`
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently, in seconds, batches of log data are sent to the HTTPS endpoint. A value of 0 sends logs at the same interval as the default, which is 5 seconds.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="requestMaxBytes")
    def request_max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of bytes sent in one request
        """
        return pulumi.get(self, "request_max_bytes")

    @request_max_bytes.setter
    def request_max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_max_bytes", value)

    @_builtins.property
    @pulumi.getter(name="requestMaxEntries")
    def request_max_entries(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of logs sent in one request
        """
        return pulumi.get(self, "request_max_entries")

    @request_max_entries.setter
    def request_max_entries(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_max_entries", value)

    @_builtins.property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        return pulumi.get(self, "tls_ca_cert")

    @tls_ca_cert.setter
    def tls_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used during the TLS handshake to validate the certificate
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)


if not MYPY:
    class ServiceComputeLoggingKafkaArgsDict(TypedDict):
        brokers: pulumi.Input[_builtins.str]
        """
        A comma-separated list of IP addresses or hostnames of Kafka brokers
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Kafka logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        topic: pulumi.Input[_builtins.str]
        """
        The Kafka topic to send logs to
        """
        auth_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        SASL authentication method. One of: plain, scram-sha-256, scram-sha-512
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. One of: `gzip`, `snappy`, `lz4`
        """
        parse_log_keyvals: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables parsing of key=value tuples from the beginning of a logline, turning them into record headers
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        SASL Pass
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        request_max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum size of log batch, if non-zero. Defaults to 0 for unbounded
        """
        required_acks: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Number of acknowledgements a leader must receive before a write is considered successful. One of: `1` (default) One server needs to respond. `0` No servers need to respond. `-1` Wait for all in-sync replicas to respond
        """
        tls_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        tls_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        tls_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        """
        use_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use TLS for secure logging. Can be either `true` or `false`
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        SASL User
        """
elif False:
    ServiceComputeLoggingKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingKafkaArgs:
    def __init__(__self__, *,
                 brokers: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 auth_method: Optional[pulumi.Input[_builtins.str]] = None,
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 parse_log_keyvals: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 request_max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 required_acks: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 use_tls: Optional[pulumi.Input[_builtins.bool]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] brokers: A comma-separated list of IP addresses or hostnames of Kafka brokers
        :param pulumi.Input[_builtins.str] name: The unique name of the Kafka logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] topic: The Kafka topic to send logs to
        :param pulumi.Input[_builtins.str] auth_method: SASL authentication method. One of: plain, scram-sha-256, scram-sha-512
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. One of: `gzip`, `snappy`, `lz4`
        :param pulumi.Input[_builtins.bool] parse_log_keyvals: Enables parsing of key=value tuples from the beginning of a logline, turning them into record headers
        :param pulumi.Input[_builtins.str] password: SASL Pass
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.int] request_max_bytes: Maximum size of log batch, if non-zero. Defaults to 0 for unbounded
        :param pulumi.Input[_builtins.str] required_acks: The Number of acknowledgements a leader must receive before a write is considered successful. One of: `1` (default) One server needs to respond. `0` No servers need to respond. `-1` Wait for all in-sync replicas to respond
        :param pulumi.Input[_builtins.str] tls_ca_cert: A secure certificate to authenticate the server with. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_cert: The client certificate used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_key: The client private key used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_hostname: The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        :param pulumi.Input[_builtins.bool] use_tls: Whether to use TLS for secure logging. Can be either `true` or `false`
        :param pulumi.Input[_builtins.str] user: SASL User
        """
        pulumi.set(__self__, "brokers", brokers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic", topic)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if parse_log_keyvals is not None:
            pulumi.set(__self__, "parse_log_keyvals", parse_log_keyvals)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if request_max_bytes is not None:
            pulumi.set(__self__, "request_max_bytes", request_max_bytes)
        if required_acks is not None:
            pulumi.set(__self__, "required_acks", required_acks)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)
        if use_tls is not None:
            pulumi.set(__self__, "use_tls", use_tls)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def brokers(self) -> pulumi.Input[_builtins.str]:
        """
        A comma-separated list of IP addresses or hostnames of Kafka brokers
        """
        return pulumi.get(self, "brokers")

    @brokers.setter
    def brokers(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "brokers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Kafka logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka topic to send logs to
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SASL authentication method. One of: plain, scram-sha-256, scram-sha-512
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. One of: `gzip`, `snappy`, `lz4`
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter(name="parseLogKeyvals")
    def parse_log_keyvals(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables parsing of key=value tuples from the beginning of a logline, turning them into record headers
        """
        return pulumi.get(self, "parse_log_keyvals")

    @parse_log_keyvals.setter
    def parse_log_keyvals(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "parse_log_keyvals", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SASL Pass
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="requestMaxBytes")
    def request_max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum size of log batch, if non-zero. Defaults to 0 for unbounded
        """
        return pulumi.get(self, "request_max_bytes")

    @request_max_bytes.setter
    def request_max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_max_bytes", value)

    @_builtins.property
    @pulumi.getter(name="requiredAcks")
    def required_acks(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Number of acknowledgements a leader must receive before a write is considered successful. One of: `1` (default) One server needs to respond. `0` No servers need to respond. `-1` Wait for all in-sync replicas to respond
        """
        return pulumi.get(self, "required_acks")

    @required_acks.setter
    def required_acks(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "required_acks", value)

    @_builtins.property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        return pulumi.get(self, "tls_ca_cert")

    @tls_ca_cert.setter
    def tls_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)

    @_builtins.property
    @pulumi.getter(name="useTls")
    def use_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use TLS for secure logging. Can be either `true` or `false`
        """
        return pulumi.get(self, "use_tls")

    @use_tls.setter
    def use_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_tls", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SASL User
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ServiceComputeLoggingKineseArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Kinesis logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        topic: pulumi.Input[_builtins.str]
        """
        The Kinesis stream name
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS access key to be used to write to the stream
        """
        iam_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) for the IAM role granting Fastly access to Kinesis. Not required if `access_key` and `secret_key` are provided.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS region the stream resides in. (Default: `us-east-1`)
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS secret access key to authenticate with
        """
elif False:
    ServiceComputeLoggingKineseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingKineseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 iam_role: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Kinesis logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] topic: The Kinesis stream name
        :param pulumi.Input[_builtins.str] access_key: The AWS access key to be used to write to the stream
        :param pulumi.Input[_builtins.str] iam_role: The Amazon Resource Name (ARN) for the IAM role granting Fastly access to Kinesis. Not required if `access_key` and `secret_key` are provided.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] region: The AWS region the stream resides in. (Default: `us-east-1`)
        :param pulumi.Input[_builtins.str] secret_key: The AWS secret access key to authenticate with
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic", topic)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if iam_role is not None:
            pulumi.set(__self__, "iam_role", iam_role)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Kinesis logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        The Kinesis stream name
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS access key to be used to write to the stream
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="iamRole")
    def iam_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) for the IAM role granting Fastly access to Kinesis. Not required if `access_key` and `secret_key` are provided.
        """
        return pulumi.get(self, "iam_role")

    @iam_role.setter
    def iam_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iam_role", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS region the stream resides in. (Default: `us-east-1`)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS secret access key to authenticate with
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class ServiceComputeLoggingLogentryArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Logentries logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        Use token based authentication (https://logentries.com/doc/input-token/)
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number configured in Logentries
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        use_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use TLS for secure logging
        """
elif False:
    ServiceComputeLoggingLogentryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingLogentryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 use_tls: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Logentries logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: Use token based authentication (https://logentries.com/doc/input-token/)
        :param pulumi.Input[_builtins.int] port: The port number configured in Logentries
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.bool] use_tls: Whether to use TLS for secure logging
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if use_tls is not None:
            pulumi.set(__self__, "use_tls", use_tls)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Logentries logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        Use token based authentication (https://logentries.com/doc/input-token/)
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number configured in Logentries
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="useTls")
    def use_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use TLS for secure logging
        """
        return pulumi.get(self, "use_tls")

    @use_tls.setter
    def use_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_tls", value)


if not MYPY:
    class ServiceComputeLoggingLogglyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Loggly logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The token to use for authentication (https://www.loggly.com/docs/customer-token-authentication-token/).
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
elif False:
    ServiceComputeLoggingLogglyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingLogglyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Loggly logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The token to use for authentication (https://www.loggly.com/docs/customer-token-authentication-token/).
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Loggly logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The token to use for authentication (https://www.loggly.com/docs/customer-token-authentication-token/).
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)


if not MYPY:
    class ServiceComputeLoggingLogshuttleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Log Shuttle logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The data authentication token associated with this endpoint
        """
        url: pulumi.Input[_builtins.str]
        """
        Your Log Shuttle endpoint URL
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
elif False:
    ServiceComputeLoggingLogshuttleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingLogshuttleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Log Shuttle logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The data authentication token associated with this endpoint
        :param pulumi.Input[_builtins.str] url: Your Log Shuttle endpoint URL
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Log Shuttle logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The data authentication token associated with this endpoint
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Your Log Shuttle endpoint URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)


if not MYPY:
    class ServiceComputeLoggingNewrelicArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the New Relic logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The Insert API key from the Account page of your New Relic account
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region that log data will be sent to. Default: `US`
        """
elif False:
    ServiceComputeLoggingNewrelicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingNewrelicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the New Relic logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The Insert API key from the Account page of your New Relic account
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] region: The region that log data will be sent to. Default: `US`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the New Relic logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Insert API key from the Account page of your New Relic account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region that log data will be sent to. Default: `US`
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ServiceComputeLoggingNewrelicotlpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the New Relic OTLP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The Insert API key from the Account page of your New Relic account
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting. Your log must produce valid JSON that New Relic OTLP can ingest.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region that log data will be sent to. Default: `US`
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The optional New Relic Trace Observer URL to stream logs to for Infinite Tracing.
        """
elif False:
    ServiceComputeLoggingNewrelicotlpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingNewrelicotlpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the New Relic OTLP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The Insert API key from the Account page of your New Relic account
        :param pulumi.Input[_builtins.str] format: Apache style log formatting. Your log must produce valid JSON that New Relic OTLP can ingest.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] region: The region that log data will be sent to. Default: `US`
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply.
        :param pulumi.Input[_builtins.str] url: The optional New Relic Trace Observer URL to stream logs to for Infinite Tracing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the New Relic OTLP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Insert API key from the Account page of your New Relic account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting. Your log must produce valid JSON that New Relic OTLP can ingest.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region that log data will be sent to. Default: `US`
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The optional New Relic Trace Observer URL to stream logs to for Infinite Tracing.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ServiceComputeLoggingOpenstackArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        Your OpenStack account access key
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of your OpenStack container
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the OpenStack logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        url: pulumi.Input[_builtins.str]
        """
        Your OpenStack auth url
        """
        user: pulumi.Input[_builtins.str]
        """
        The username for your OpenStack account
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently the logs should be transferred, in seconds. Default `3600`
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceComputeLoggingOpenstackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingOpenstackArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 bucket_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: Your OpenStack account access key
        :param pulumi.Input[_builtins.str] bucket_name: The name of your OpenStack container
        :param pulumi.Input[_builtins.str] name: The unique name of the OpenStack logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] url: Your OpenStack auth url
        :param pulumi.Input[_builtins.str] user: The username for your OpenStack account
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        :param pulumi.Input[_builtins.int] period: How frequently the logs should be transferred, in seconds. Default `3600`
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "user", user)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your OpenStack account access key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of your OpenStack container
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the OpenStack logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Your OpenStack auth url
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The username for your OpenStack account
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently the logs should be transferred, in seconds. Default `3600`
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceComputeLoggingPapertrailArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        The address of the Papertrail endpoint
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this Papertrail endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        port: pulumi.Input[_builtins.int]
        """
        The port associated with the address where the Papertrail endpoint can be accessed
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
elif False:
    ServiceComputeLoggingPapertrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingPapertrailArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address of the Papertrail endpoint
        :param pulumi.Input[_builtins.str] name: A unique name to identify this Papertrail endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.int] port: The port associated with the address where the Papertrail endpoint can be accessed
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        The address of the Papertrail endpoint
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this Papertrail endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port associated with the address where the Papertrail endpoint can be accessed
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)


if not MYPY:
    class ServiceComputeLoggingS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of the bucket in which to store the logs
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the S3 logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        acl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl) to use for objects uploaded to the S3 bucket. Options are: `private`, `public-read`, `public-read-write`, `aws-exec-read`, `authenticated-read`, `bucket-owner-read`, `bucket-owner-full-control`
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        If you created the S3 bucket outside of `us-east-1`, then specify the corresponding bucket endpoint. Example: `s3-us-west-2.amazonaws.com`
        """
        file_max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum size of an uploaded log file, if non-zero.
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently the logs should be transferred, in seconds. Default `3600`
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        redundancy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The S3 storage class (redundancy level). Should be one of: `standard`, `intelligent_tiering`, `standard_ia`, `onezone_ia`, `glacier`, `glacier_ir`, `deep_archive`, or `reduced_redundancy`
        """
        s3_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS Access Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This key will be not be encrypted. Not required if `iam_role` is provided. You can provide this key via an environment variable, `FASTLY_S3_ACCESS_KEY`
        """
        s3_iam_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) for the IAM role granting Fastly access to S3. Not required if `access_key` and `secret_key` are provided. You can provide this value via an environment variable, `FASTLY_S3_IAM_ROLE`
        """
        s3_secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS Secret Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This secret will be not be encrypted. Not required if `iam_role` is provided. You can provide this secret via an environment variable, `FASTLY_S3_SECRET_KEY`
        """
        server_side_encryption: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specify what type of server side encryption should be used. Can be either `AES256` or `aws:kms`
        """
        server_side_encryption_kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional server-side KMS Key Id. Must be set if server_side_encryption is set to `aws:kms`
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceComputeLoggingS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 acl: Optional[pulumi.Input[_builtins.str]] = None,
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 file_max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 redundancy: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_iam_role: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 server_side_encryption: Optional[pulumi.Input[_builtins.str]] = None,
                 server_side_encryption_kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The name of the bucket in which to store the logs
        :param pulumi.Input[_builtins.str] name: The unique name of the S3 logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] acl: The AWS [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl) to use for objects uploaded to the S3 bucket. Options are: `private`, `public-read`, `public-read-write`, `aws-exec-read`, `authenticated-read`, `bucket-owner-read`, `bucket-owner-full-control`
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] domain: If you created the S3 bucket outside of `us-east-1`, then specify the corresponding bucket endpoint. Example: `s3-us-west-2.amazonaws.com`
        :param pulumi.Input[_builtins.int] file_max_bytes: Maximum size of an uploaded log file, if non-zero.
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        :param pulumi.Input[_builtins.int] period: How frequently the logs should be transferred, in seconds. Default `3600`
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] redundancy: The S3 storage class (redundancy level). Should be one of: `standard`, `intelligent_tiering`, `standard_ia`, `onezone_ia`, `glacier`, `glacier_ir`, `deep_archive`, or `reduced_redundancy`
        :param pulumi.Input[_builtins.str] s3_access_key: AWS Access Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This key will be not be encrypted. Not required if `iam_role` is provided. You can provide this key via an environment variable, `FASTLY_S3_ACCESS_KEY`
        :param pulumi.Input[_builtins.str] s3_iam_role: The Amazon Resource Name (ARN) for the IAM role granting Fastly access to S3. Not required if `access_key` and `secret_key` are provided. You can provide this value via an environment variable, `FASTLY_S3_IAM_ROLE`
        :param pulumi.Input[_builtins.str] s3_secret_key: AWS Secret Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This secret will be not be encrypted. Not required if `iam_role` is provided. You can provide this secret via an environment variable, `FASTLY_S3_SECRET_KEY`
        :param pulumi.Input[_builtins.str] server_side_encryption: Specify what type of server side encryption should be used. Can be either `AES256` or `aws:kms`
        :param pulumi.Input[_builtins.str] server_side_encryption_kms_key_id: Optional server-side KMS Key Id. Must be set if server_side_encryption is set to `aws:kms`
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)
        if acl is not None:
            pulumi.set(__self__, "acl", acl)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if file_max_bytes is not None:
            pulumi.set(__self__, "file_max_bytes", file_max_bytes)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if redundancy is not None:
            pulumi.set(__self__, "redundancy", redundancy)
        if s3_access_key is not None:
            pulumi.set(__self__, "s3_access_key", s3_access_key)
        if s3_iam_role is not None:
            pulumi.set(__self__, "s3_iam_role", s3_iam_role)
        if s3_secret_key is not None:
            pulumi.set(__self__, "s3_secret_key", s3_secret_key)
        if server_side_encryption is not None:
            pulumi.set(__self__, "server_side_encryption", server_side_encryption)
        if server_side_encryption_kms_key_id is not None:
            pulumi.set(__self__, "server_side_encryption_kms_key_id", server_side_encryption_kms_key_id)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the bucket in which to store the logs
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the S3 logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def acl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl) to use for objects uploaded to the S3 bucket. Options are: `private`, `public-read`, `public-read-write`, `aws-exec-read`, `authenticated-read`, `bucket-owner-read`, `bucket-owner-full-control`
        """
        return pulumi.get(self, "acl")

    @acl.setter
    def acl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acl", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If you created the S3 bucket outside of `us-east-1`, then specify the corresponding bucket endpoint. Example: `s3-us-west-2.amazonaws.com`
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="fileMaxBytes")
    def file_max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum size of an uploaded log file, if non-zero.
        """
        return pulumi.get(self, "file_max_bytes")

    @file_max_bytes.setter
    def file_max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "file_max_bytes", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently the logs should be transferred, in seconds. Default `3600`
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def redundancy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The S3 storage class (redundancy level). Should be one of: `standard`, `intelligent_tiering`, `standard_ia`, `onezone_ia`, `glacier`, `glacier_ir`, `deep_archive`, or `reduced_redundancy`
        """
        return pulumi.get(self, "redundancy")

    @redundancy.setter
    def redundancy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redundancy", value)

    @_builtins.property
    @pulumi.getter(name="s3AccessKey")
    def s3_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS Access Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This key will be not be encrypted. Not required if `iam_role` is provided. You can provide this key via an environment variable, `FASTLY_S3_ACCESS_KEY`
        """
        return pulumi.get(self, "s3_access_key")

    @s3_access_key.setter
    def s3_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_access_key", value)

    @_builtins.property
    @pulumi.getter(name="s3IamRole")
    def s3_iam_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) for the IAM role granting Fastly access to S3. Not required if `access_key` and `secret_key` are provided. You can provide this value via an environment variable, `FASTLY_S3_IAM_ROLE`
        """
        return pulumi.get(self, "s3_iam_role")

    @s3_iam_role.setter
    def s3_iam_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_iam_role", value)

    @_builtins.property
    @pulumi.getter(name="s3SecretKey")
    def s3_secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS Secret Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This secret will be not be encrypted. Not required if `iam_role` is provided. You can provide this secret via an environment variable, `FASTLY_S3_SECRET_KEY`
        """
        return pulumi.get(self, "s3_secret_key")

    @s3_secret_key.setter
    def s3_secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_secret_key", value)

    @_builtins.property
    @pulumi.getter(name="serverSideEncryption")
    def server_side_encryption(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify what type of server side encryption should be used. Can be either `AES256` or `aws:kms`
        """
        return pulumi.get(self, "server_side_encryption")

    @server_side_encryption.setter
    def server_side_encryption(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_side_encryption", value)

    @_builtins.property
    @pulumi.getter(name="serverSideEncryptionKmsKeyId")
    def server_side_encryption_kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional server-side KMS Key Id. Must be set if server_side_encryption is set to `aws:kms`
        """
        return pulumi.get(self, "server_side_encryption_kms_key_id")

    @server_side_encryption_kms_key_id.setter
    def server_side_encryption_kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_side_encryption_kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceComputeLoggingScalyrArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Scalyr logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The token to use for authentication (https://www.scalyr.com/keys)
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the logfile field sent to Scalyr
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region that log data will be sent to. One of `US` or `EU`. Defaults to `US` if undefined
        """
elif False:
    ServiceComputeLoggingScalyrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingScalyrArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Scalyr logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The token to use for authentication (https://www.scalyr.com/keys)
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] project_id: The name of the logfile field sent to Scalyr
        :param pulumi.Input[_builtins.str] region: The region that log data will be sent to. One of `US` or `EU`. Defaults to `US` if undefined
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Scalyr logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The token to use for authentication (https://www.scalyr.com/keys)
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the logfile field sent to Scalyr
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region that log data will be sent to. One of `US` or `EU`. Defaults to `US` if undefined
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class ServiceComputeLoggingSftpArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        The SFTP address to stream logs to
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the SFTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        path: pulumi.Input[_builtins.str]
        """
        The path to upload log files to. If the path ends in `/` then it is treated as a directory
        """
        ssh_known_hosts: pulumi.Input[_builtins.str]
        """
        A list of host keys for all hosts we can connect to over SFTP
        """
        user: pulumi.Input[_builtins.str]
        """
        The username for the server
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port the SFTP service listens on. (Default: `22`)
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSH private key for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceComputeLoggingSftpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingSftpArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 ssh_known_hosts: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The SFTP address to stream logs to
        :param pulumi.Input[_builtins.str] name: The unique name of the SFTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] path: The path to upload log files to. If the path ends in `/` then it is treated as a directory
        :param pulumi.Input[_builtins.str] ssh_known_hosts: A list of host keys for all hosts we can connect to over SFTP
        :param pulumi.Input[_builtins.str] user: The username for the server
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] password: The password for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        :param pulumi.Input[_builtins.int] period: How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        :param pulumi.Input[_builtins.int] port: The port the SFTP service listens on. (Default: `22`)
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] secret_key: The SSH private key for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "ssh_known_hosts", ssh_known_hosts)
        pulumi.set(__self__, "user", user)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        The SFTP address to stream logs to
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the SFTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to upload log files to. If the path ends in `/` then it is treated as a directory
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="sshKnownHosts")
    def ssh_known_hosts(self) -> pulumi.Input[_builtins.str]:
        """
        A list of host keys for all hosts we can connect to over SFTP
        """
        return pulumi.get(self, "ssh_known_hosts")

    @ssh_known_hosts.setter
    def ssh_known_hosts(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ssh_known_hosts", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The username for the server
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port the SFTP service listens on. (Default: `22`)
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSH private key for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceComputeLoggingSplunkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify the Splunk endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The Splunk token to be used for authentication
        """
        url: pulumi.Input[_builtins.str]
        """
        The Splunk URL to stream logs to
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        tls_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SPLUNK_CA_CERT`
        """
        tls_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate used to make authenticated requests. Must be in PEM format.
        """
        tls_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client private key used to make authenticated requests. Must be in PEM format.
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        """
        use_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use TLS for secure logging. Default: `false`
        """
elif False:
    ServiceComputeLoggingSplunkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingSplunkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 use_tls: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A unique name to identify the Splunk endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The Splunk token to be used for authentication
        :param pulumi.Input[_builtins.str] url: The Splunk URL to stream logs to
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] tls_ca_cert: A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SPLUNK_CA_CERT`
        :param pulumi.Input[_builtins.str] tls_client_cert: The client certificate used to make authenticated requests. Must be in PEM format.
        :param pulumi.Input[_builtins.str] tls_client_key: The client private key used to make authenticated requests. Must be in PEM format.
        :param pulumi.Input[_builtins.str] tls_hostname: The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        :param pulumi.Input[_builtins.bool] use_tls: Whether to use TLS for secure logging. Default: `false`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)
        if use_tls is not None:
            pulumi.set(__self__, "use_tls", use_tls)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify the Splunk endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Splunk token to be used for authentication
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The Splunk URL to stream logs to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SPLUNK_CA_CERT`
        """
        return pulumi.get(self, "tls_ca_cert")

    @tls_ca_cert.setter
    def tls_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate used to make authenticated requests. Must be in PEM format.
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client private key used to make authenticated requests. Must be in PEM format.
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)

    @_builtins.property
    @pulumi.getter(name="useTls")
    def use_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use TLS for secure logging. Default: `false`
        """
        return pulumi.get(self, "use_tls")

    @use_tls.setter
    def use_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_tls", value)


if not MYPY:
    class ServiceComputeLoggingSumologicArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this Sumologic endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        url: pulumi.Input[_builtins.str]
        """
        The URL to Sumologic collector endpoint
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
elif False:
    ServiceComputeLoggingSumologicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingSumologicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A unique name to identify this Sumologic endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] url: The URL to Sumologic collector endpoint
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this Sumologic endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL to Sumologic collector endpoint
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)


if not MYPY:
    class ServiceComputeLoggingSyslogArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        A hostname or IPv4 address of the Syslog endpoint
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this Syslog endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port associated with the address where the Syslog endpoint can be accessed. Default `514`
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        tls_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CA_CERT`
        """
        tls_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate used to make authenticated requests. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CLIENT_CERT`
        """
        tls_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client private key used to make authenticated requests. Must be in PEM format. You can provide this key via an environment variable, `FASTLY_SYSLOG_CLIENT_KEY`
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used during the TLS handshake to validate the certificate
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to prepend each message with a specific token
        """
        use_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use TLS for secure logging. Default `false`
        """
elif False:
    ServiceComputeLoggingSyslogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeLoggingSyslogArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None,
                 use_tls: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] address: A hostname or IPv4 address of the Syslog endpoint
        :param pulumi.Input[_builtins.str] name: A unique name to identify this Syslog endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.int] port: The port associated with the address where the Syslog endpoint can be accessed. Default `514`
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] tls_ca_cert: A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CA_CERT`
        :param pulumi.Input[_builtins.str] tls_client_cert: The client certificate used to make authenticated requests. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CLIENT_CERT`
        :param pulumi.Input[_builtins.str] tls_client_key: The client private key used to make authenticated requests. Must be in PEM format. You can provide this key via an environment variable, `FASTLY_SYSLOG_CLIENT_KEY`
        :param pulumi.Input[_builtins.str] tls_hostname: Used during the TLS handshake to validate the certificate
        :param pulumi.Input[_builtins.str] token: Whether to prepend each message with a specific token
        :param pulumi.Input[_builtins.bool] use_tls: Whether to use TLS for secure logging. Default `false`
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if use_tls is not None:
            pulumi.set(__self__, "use_tls", use_tls)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        A hostname or IPv4 address of the Syslog endpoint
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this Syslog endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port associated with the address where the Syslog endpoint can be accessed. Default `514`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CA_CERT`
        """
        return pulumi.get(self, "tls_ca_cert")

    @tls_ca_cert.setter
    def tls_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate used to make authenticated requests. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CLIENT_CERT`
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client private key used to make authenticated requests. Must be in PEM format. You can provide this key via an environment variable, `FASTLY_SYSLOG_CLIENT_KEY`
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used during the TLS handshake to validate the certificate
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to prepend each message with a specific token
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="useTls")
    def use_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use TLS for secure logging. Default `false`
        """
        return pulumi.get(self, "use_tls")

    @use_tls.setter
    def use_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_tls", value)


if not MYPY:
    class ServiceComputePackageArgsDict(TypedDict):
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        The contents of the Wasm deployment package as a base64 encoded string (e.g. could be provided using an input variable or via external data source output variable). Conflicts with `filename`. Exactly one of these two arguments must be specified
        """
        filename: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to the Wasm deployment package within your local filesystem. Conflicts with `content`. Exactly one of these two arguments must be specified
        """
        source_code_hash: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used to trigger updates. Must be set to a SHA512 hash of all files (in sorted order) within the package. The usual way to set this is using the get_package_hash data source.
        """
elif False:
    ServiceComputePackageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputePackageArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 filename: Optional[pulumi.Input[_builtins.str]] = None,
                 source_code_hash: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] content: The contents of the Wasm deployment package as a base64 encoded string (e.g. could be provided using an input variable or via external data source output variable). Conflicts with `filename`. Exactly one of these two arguments must be specified
        :param pulumi.Input[_builtins.str] filename: The path to the Wasm deployment package within your local filesystem. Conflicts with `content`. Exactly one of these two arguments must be specified
        :param pulumi.Input[_builtins.str] source_code_hash: Used to trigger updates. Must be set to a SHA512 hash of all files (in sorted order) within the package. The usual way to set this is using the get_package_hash data source.
        """
        if content is not None:
            pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)
        if source_code_hash is not None:
            pulumi.set(__self__, "source_code_hash", source_code_hash)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The contents of the Wasm deployment package as a base64 encoded string (e.g. could be provided using an input variable or via external data source output variable). Conflicts with `filename`. Exactly one of these two arguments must be specified
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def filename(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to the Wasm deployment package within your local filesystem. Conflicts with `content`. Exactly one of these two arguments must be specified
        """
        return pulumi.get(self, "filename")

    @filename.setter
    def filename(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filename", value)

    @_builtins.property
    @pulumi.getter(name="sourceCodeHash")
    def source_code_hash(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used to trigger updates. Must be set to a SHA512 hash of all files (in sorted order) within the package. The usual way to set this is using the get_package_hash data source.
        """
        return pulumi.get(self, "source_code_hash")

    @source_code_hash.setter
    def source_code_hash(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_code_hash", value)


if not MYPY:
    class ServiceComputeProductEnablementArgsDict(TypedDict):
        api_discovery: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable API Discovery support
        """
        ddos_protection: NotRequired[pulumi.Input['ServiceComputeProductEnablementDdosProtectionArgsDict']]
        """
        DDoS Protection product
        """
        fanout: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Fanout support
        """
        log_explorer_insights: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Log Explorer & Insights
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used by the provider to identify modified settings (changing this value will force the entire block to be deleted, then recreated)
        """
        ngwaf: NotRequired[pulumi.Input['ServiceComputeProductEnablementNgwafArgsDict']]
        """
        Next-Gen WAF product
        """
        websockets: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable WebSockets support
        """
elif False:
    ServiceComputeProductEnablementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeProductEnablementArgs:
    def __init__(__self__, *,
                 api_discovery: Optional[pulumi.Input[_builtins.bool]] = None,
                 ddos_protection: Optional[pulumi.Input['ServiceComputeProductEnablementDdosProtectionArgs']] = None,
                 fanout: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_explorer_insights: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 ngwaf: Optional[pulumi.Input['ServiceComputeProductEnablementNgwafArgs']] = None,
                 websockets: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] api_discovery: Enable API Discovery support
        :param pulumi.Input['ServiceComputeProductEnablementDdosProtectionArgs'] ddos_protection: DDoS Protection product
        :param pulumi.Input[_builtins.bool] fanout: Enable Fanout support
        :param pulumi.Input[_builtins.bool] log_explorer_insights: Enable Log Explorer & Insights
        :param pulumi.Input[_builtins.str] name: Used by the provider to identify modified settings (changing this value will force the entire block to be deleted, then recreated)
        :param pulumi.Input['ServiceComputeProductEnablementNgwafArgs'] ngwaf: Next-Gen WAF product
        :param pulumi.Input[_builtins.bool] websockets: Enable WebSockets support
        """
        if api_discovery is not None:
            pulumi.set(__self__, "api_discovery", api_discovery)
        if ddos_protection is not None:
            pulumi.set(__self__, "ddos_protection", ddos_protection)
        if fanout is not None:
            pulumi.set(__self__, "fanout", fanout)
        if log_explorer_insights is not None:
            pulumi.set(__self__, "log_explorer_insights", log_explorer_insights)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ngwaf is not None:
            pulumi.set(__self__, "ngwaf", ngwaf)
        if websockets is not None:
            pulumi.set(__self__, "websockets", websockets)

    @_builtins.property
    @pulumi.getter(name="apiDiscovery")
    def api_discovery(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable API Discovery support
        """
        return pulumi.get(self, "api_discovery")

    @api_discovery.setter
    def api_discovery(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "api_discovery", value)

    @_builtins.property
    @pulumi.getter(name="ddosProtection")
    def ddos_protection(self) -> Optional[pulumi.Input['ServiceComputeProductEnablementDdosProtectionArgs']]:
        """
        DDoS Protection product
        """
        return pulumi.get(self, "ddos_protection")

    @ddos_protection.setter
    def ddos_protection(self, value: Optional[pulumi.Input['ServiceComputeProductEnablementDdosProtectionArgs']]):
        pulumi.set(self, "ddos_protection", value)

    @_builtins.property
    @pulumi.getter
    def fanout(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Fanout support
        """
        return pulumi.get(self, "fanout")

    @fanout.setter
    def fanout(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fanout", value)

    @_builtins.property
    @pulumi.getter(name="logExplorerInsights")
    def log_explorer_insights(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Log Explorer & Insights
        """
        return pulumi.get(self, "log_explorer_insights")

    @log_explorer_insights.setter
    def log_explorer_insights(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log_explorer_insights", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used by the provider to identify modified settings (changing this value will force the entire block to be deleted, then recreated)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def ngwaf(self) -> Optional[pulumi.Input['ServiceComputeProductEnablementNgwafArgs']]:
        """
        Next-Gen WAF product
        """
        return pulumi.get(self, "ngwaf")

    @ngwaf.setter
    def ngwaf(self, value: Optional[pulumi.Input['ServiceComputeProductEnablementNgwafArgs']]):
        pulumi.set(self, "ngwaf", value)

    @_builtins.property
    @pulumi.getter
    def websockets(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable WebSockets support
        """
        return pulumi.get(self, "websockets")

    @websockets.setter
    def websockets(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "websockets", value)


if not MYPY:
    class ServiceComputeProductEnablementDdosProtectionArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enable DDoS Protection support
        """
        mode: pulumi.Input[_builtins.str]
        """
        Operation mode. Can be either `off`, `log`, or `block`.
        """
elif False:
    ServiceComputeProductEnablementDdosProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeProductEnablementDdosProtectionArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 mode: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable DDoS Protection support
        :param pulumi.Input[_builtins.str] mode: Operation mode. Can be either `off`, `log`, or `block`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable DDoS Protection support
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        Operation mode. Can be either `off`, `log`, or `block`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ServiceComputeProductEnablementNgwafArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enable Next-Gen WAF support
        """
        workspace_id: pulumi.Input[_builtins.str]
        """
        The workspace to link
        """
        traffic_ramp: NotRequired[pulumi.Input[_builtins.int]]
        """
        The percentage of traffic to inspect
        """
elif False:
    ServiceComputeProductEnablementNgwafArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeProductEnablementNgwafArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 workspace_id: pulumi.Input[_builtins.str],
                 traffic_ramp: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable Next-Gen WAF support
        :param pulumi.Input[_builtins.str] workspace_id: The workspace to link
        :param pulumi.Input[_builtins.int] traffic_ramp: The percentage of traffic to inspect
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "workspace_id", workspace_id)
        if traffic_ramp is not None:
            pulumi.set(__self__, "traffic_ramp", traffic_ramp)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable Next-Gen WAF support
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> pulumi.Input[_builtins.str]:
        """
        The workspace to link
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workspace_id", value)

    @_builtins.property
    @pulumi.getter(name="trafficRamp")
    def traffic_ramp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The percentage of traffic to inspect
        """
        return pulumi.get(self, "traffic_ramp")

    @traffic_ramp.setter
    def traffic_ramp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "traffic_ramp", value)


if not MYPY:
    class ServiceComputeResourceLinkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the resource link.
        """
        resource_id: pulumi.Input[_builtins.str]
        """
        The ID of the underlying linked resource.
        """
        link_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        An alphanumeric string identifying the resource link.
        """
elif False:
    ServiceComputeResourceLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceComputeResourceLinkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 resource_id: pulumi.Input[_builtins.str],
                 link_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the resource link.
        :param pulumi.Input[_builtins.str] resource_id: The ID of the underlying linked resource.
        :param pulumi.Input[_builtins.str] link_id: An alphanumeric string identifying the resource link.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_id", resource_id)
        if link_id is not None:
            pulumi.set(__self__, "link_id", link_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the resource link.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the underlying linked resource.
        """
        return pulumi.get(self, "resource_id")

    @resource_id.setter
    def resource_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_id", value)

    @_builtins.property
    @pulumi.getter(name="linkId")
    def link_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An alphanumeric string identifying the resource link.
        """
        return pulumi.get(self, "link_id")

    @link_id.setter
    def link_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "link_id", value)


if not MYPY:
    class ServiceVclAclArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this ACL. It is important to note that changing this attribute will delete and recreate the ACL, and discard the current items in the ACL
        """
        acl_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the ACL
        """
        force_destroy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow the ACL to be deleted, even if it contains entries. Defaults to false.
        """
elif False:
    ServiceVclAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclAclArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 acl_id: Optional[pulumi.Input[_builtins.str]] = None,
                 force_destroy: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A unique name to identify this ACL. It is important to note that changing this attribute will delete and recreate the ACL, and discard the current items in the ACL
        :param pulumi.Input[_builtins.str] acl_id: The ID of the ACL
        :param pulumi.Input[_builtins.bool] force_destroy: Allow the ACL to be deleted, even if it contains entries. Defaults to false.
        """
        pulumi.set(__self__, "name", name)
        if acl_id is not None:
            pulumi.set(__self__, "acl_id", acl_id)
        if force_destroy is not None:
            pulumi.set(__self__, "force_destroy", force_destroy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this ACL. It is important to note that changing this attribute will delete and recreate the ACL, and discard the current items in the ACL
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="aclId")
    def acl_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the ACL
        """
        return pulumi.get(self, "acl_id")

    @acl_id.setter
    def acl_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acl_id", value)

    @_builtins.property
    @pulumi.getter(name="forceDestroy")
    def force_destroy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow the ACL to be deleted, even if it contains entries. Defaults to false.
        """
        return pulumi.get(self, "force_destroy")

    @force_destroy.setter
    def force_destroy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force_destroy", value)


if not MYPY:
    class ServiceVclBackendArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        An IPv4, hostname, or IPv6 address for the Backend
        """
        name: pulumi.Input[_builtins.str]
        """
        Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        """
        auto_loadbalance: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Denotes if this Backend should be included in the pool of backends that requests are load balanced against. Default `false`
        """
        between_bytes_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        How long to wait between bytes in milliseconds. Default `10000`
        """
        connect_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        How long to wait for a timeout in milliseconds. Default `1000`
        """
        error_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of errors to allow before the Backend is marked as down. Default `0`
        """
        first_byte_timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        How long to wait for the first bytes in milliseconds. Default `15000`
        """
        healthcheck: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a defined `healthcheck` to assign to this backend
        """
        keepalive_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        How long in seconds to keep a persistent connection to the backend between requests.
        """
        max_conn: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of connections for this Backend. Default `200`
        """
        max_tls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum allowed TLS version on SSL connections to this backend.
        """
        min_tls_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum allowed TLS version on SSL connections to this backend.
        """
        override_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname to override the Host header
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number on which the Backend responds. Default `80`
        """
        prefer_ipv6: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Prefer IPv6 connections to origins for hostname backends. Default `false`
        """
        request_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a condition, which if met, will select this backend during a request.
        """
        share_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value that when shared across backends will enable those backends to share the same health check.
        """
        shield: NotRequired[pulumi.Input[_builtins.str]]
        """
        The POP of the shield designated to reduce inbound load. Valid values for `shield` are included in the `GET /datacenters` API response
        """
        ssl_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        CA certificate attached to origin.
        """
        ssl_cert_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure certificate validation. Does not affect SNI at all
        """
        ssl_check_cert: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Be strict about checking SSL certs. Default `true`
        """
        ssl_ciphers: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cipher list consisting of one or more cipher strings separated by colons. Commas or spaces are also acceptable separators but colons are normally used.
        """
        ssl_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client certificate attached to origin. Used when connecting to the backend
        """
        ssl_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client key attached to origin. Used when connecting to the backend
        """
        ssl_sni_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure SNI in the TLS handshake. Does not affect cert validation at all
        """
        use_ssl: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not to use SSL to reach the Backend. Default `false`
        """
        weight: NotRequired[pulumi.Input[_builtins.int]]
        """
        The [portion of traffic](https://docs.fastly.com/en/guides/load-balancing-configuration#how-weight-affects-load-balancing) to send to this Backend. Each Backend receives weight / total of the traffic. Default `100`
        """
elif False:
    ServiceVclBackendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclBackendArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 auto_loadbalance: Optional[pulumi.Input[_builtins.bool]] = None,
                 between_bytes_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 connect_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 error_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 first_byte_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 healthcheck: Optional[pulumi.Input[_builtins.str]] = None,
                 keepalive_time: Optional[pulumi.Input[_builtins.int]] = None,
                 max_conn: Optional[pulumi.Input[_builtins.int]] = None,
                 max_tls_version: Optional[pulumi.Input[_builtins.str]] = None,
                 min_tls_version: Optional[pulumi.Input[_builtins.str]] = None,
                 override_host: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 prefer_ipv6: Optional[pulumi.Input[_builtins.bool]] = None,
                 request_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 share_key: Optional[pulumi.Input[_builtins.str]] = None,
                 shield: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_cert_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_check_cert: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssl_ciphers: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 ssl_sni_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 use_ssl: Optional[pulumi.Input[_builtins.bool]] = None,
                 weight: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] address: An IPv4, hostname, or IPv6 address for the Backend
        :param pulumi.Input[_builtins.str] name: Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.bool] auto_loadbalance: Denotes if this Backend should be included in the pool of backends that requests are load balanced against. Default `false`
        :param pulumi.Input[_builtins.int] between_bytes_timeout: How long to wait between bytes in milliseconds. Default `10000`
        :param pulumi.Input[_builtins.int] connect_timeout: How long to wait for a timeout in milliseconds. Default `1000`
        :param pulumi.Input[_builtins.int] error_threshold: Number of errors to allow before the Backend is marked as down. Default `0`
        :param pulumi.Input[_builtins.int] first_byte_timeout: How long to wait for the first bytes in milliseconds. Default `15000`
        :param pulumi.Input[_builtins.str] healthcheck: Name of a defined `healthcheck` to assign to this backend
        :param pulumi.Input[_builtins.int] keepalive_time: How long in seconds to keep a persistent connection to the backend between requests.
        :param pulumi.Input[_builtins.int] max_conn: Maximum number of connections for this Backend. Default `200`
        :param pulumi.Input[_builtins.str] max_tls_version: Maximum allowed TLS version on SSL connections to this backend.
        :param pulumi.Input[_builtins.str] min_tls_version: Minimum allowed TLS version on SSL connections to this backend.
        :param pulumi.Input[_builtins.str] override_host: The hostname to override the Host header
        :param pulumi.Input[_builtins.int] port: The port number on which the Backend responds. Default `80`
        :param pulumi.Input[_builtins.bool] prefer_ipv6: Prefer IPv6 connections to origins for hostname backends. Default `false`
        :param pulumi.Input[_builtins.str] request_condition: Name of a condition, which if met, will select this backend during a request.
        :param pulumi.Input[_builtins.str] share_key: Value that when shared across backends will enable those backends to share the same health check.
        :param pulumi.Input[_builtins.str] shield: The POP of the shield designated to reduce inbound load. Valid values for `shield` are included in the `GET /datacenters` API response
        :param pulumi.Input[_builtins.str] ssl_ca_cert: CA certificate attached to origin.
        :param pulumi.Input[_builtins.str] ssl_cert_hostname: Configure certificate validation. Does not affect SNI at all
        :param pulumi.Input[_builtins.bool] ssl_check_cert: Be strict about checking SSL certs. Default `true`
        :param pulumi.Input[_builtins.str] ssl_ciphers: Cipher list consisting of one or more cipher strings separated by colons. Commas or spaces are also acceptable separators but colons are normally used.
        :param pulumi.Input[_builtins.str] ssl_client_cert: Client certificate attached to origin. Used when connecting to the backend
        :param pulumi.Input[_builtins.str] ssl_client_key: Client key attached to origin. Used when connecting to the backend
        :param pulumi.Input[_builtins.str] ssl_sni_hostname: Configure SNI in the TLS handshake. Does not affect cert validation at all
        :param pulumi.Input[_builtins.bool] use_ssl: Whether or not to use SSL to reach the Backend. Default `false`
        :param pulumi.Input[_builtins.int] weight: The [portion of traffic](https://docs.fastly.com/en/guides/load-balancing-configuration#how-weight-affects-load-balancing) to send to this Backend. Each Backend receives weight / total of the traffic. Default `100`
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if auto_loadbalance is not None:
            pulumi.set(__self__, "auto_loadbalance", auto_loadbalance)
        if between_bytes_timeout is not None:
            pulumi.set(__self__, "between_bytes_timeout", between_bytes_timeout)
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if error_threshold is not None:
            pulumi.set(__self__, "error_threshold", error_threshold)
        if first_byte_timeout is not None:
            pulumi.set(__self__, "first_byte_timeout", first_byte_timeout)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if keepalive_time is not None:
            pulumi.set(__self__, "keepalive_time", keepalive_time)
        if max_conn is not None:
            pulumi.set(__self__, "max_conn", max_conn)
        if max_tls_version is not None:
            pulumi.set(__self__, "max_tls_version", max_tls_version)
        if min_tls_version is not None:
            pulumi.set(__self__, "min_tls_version", min_tls_version)
        if override_host is not None:
            pulumi.set(__self__, "override_host", override_host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefer_ipv6 is not None:
            pulumi.set(__self__, "prefer_ipv6", prefer_ipv6)
        if request_condition is not None:
            pulumi.set(__self__, "request_condition", request_condition)
        if share_key is not None:
            pulumi.set(__self__, "share_key", share_key)
        if shield is not None:
            pulumi.set(__self__, "shield", shield)
        if ssl_ca_cert is not None:
            pulumi.set(__self__, "ssl_ca_cert", ssl_ca_cert)
        if ssl_cert_hostname is not None:
            pulumi.set(__self__, "ssl_cert_hostname", ssl_cert_hostname)
        if ssl_check_cert is not None:
            pulumi.set(__self__, "ssl_check_cert", ssl_check_cert)
        if ssl_ciphers is not None:
            pulumi.set(__self__, "ssl_ciphers", ssl_ciphers)
        if ssl_client_cert is not None:
            pulumi.set(__self__, "ssl_client_cert", ssl_client_cert)
        if ssl_client_key is not None:
            pulumi.set(__self__, "ssl_client_key", ssl_client_key)
        if ssl_sni_hostname is not None:
            pulumi.set(__self__, "ssl_sni_hostname", ssl_sni_hostname)
        if use_ssl is not None:
            pulumi.set(__self__, "use_ssl", use_ssl)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        An IPv4, hostname, or IPv6 address for the Backend
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name for this Backend. Must be unique to this Service. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="autoLoadbalance")
    def auto_loadbalance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Denotes if this Backend should be included in the pool of backends that requests are load balanced against. Default `false`
        """
        return pulumi.get(self, "auto_loadbalance")

    @auto_loadbalance.setter
    def auto_loadbalance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_loadbalance", value)

    @_builtins.property
    @pulumi.getter(name="betweenBytesTimeout")
    def between_bytes_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How long to wait between bytes in milliseconds. Default `10000`
        """
        return pulumi.get(self, "between_bytes_timeout")

    @between_bytes_timeout.setter
    def between_bytes_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "between_bytes_timeout", value)

    @_builtins.property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How long to wait for a timeout in milliseconds. Default `1000`
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_timeout", value)

    @_builtins.property
    @pulumi.getter(name="errorThreshold")
    def error_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of errors to allow before the Backend is marked as down. Default `0`
        """
        return pulumi.get(self, "error_threshold")

    @error_threshold.setter
    def error_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "error_threshold", value)

    @_builtins.property
    @pulumi.getter(name="firstByteTimeout")
    def first_byte_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How long to wait for the first bytes in milliseconds. Default `15000`
        """
        return pulumi.get(self, "first_byte_timeout")

    @first_byte_timeout.setter
    def first_byte_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "first_byte_timeout", value)

    @_builtins.property
    @pulumi.getter
    def healthcheck(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a defined `healthcheck` to assign to this backend
        """
        return pulumi.get(self, "healthcheck")

    @healthcheck.setter
    def healthcheck(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "healthcheck", value)

    @_builtins.property
    @pulumi.getter(name="keepaliveTime")
    def keepalive_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How long in seconds to keep a persistent connection to the backend between requests.
        """
        return pulumi.get(self, "keepalive_time")

    @keepalive_time.setter
    def keepalive_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "keepalive_time", value)

    @_builtins.property
    @pulumi.getter(name="maxConn")
    def max_conn(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of connections for this Backend. Default `200`
        """
        return pulumi.get(self, "max_conn")

    @max_conn.setter
    def max_conn(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_conn", value)

    @_builtins.property
    @pulumi.getter(name="maxTlsVersion")
    def max_tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum allowed TLS version on SSL connections to this backend.
        """
        return pulumi.get(self, "max_tls_version")

    @max_tls_version.setter
    def max_tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_tls_version", value)

    @_builtins.property
    @pulumi.getter(name="minTlsVersion")
    def min_tls_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum allowed TLS version on SSL connections to this backend.
        """
        return pulumi.get(self, "min_tls_version")

    @min_tls_version.setter
    def min_tls_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_tls_version", value)

    @_builtins.property
    @pulumi.getter(name="overrideHost")
    def override_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname to override the Host header
        """
        return pulumi.get(self, "override_host")

    @override_host.setter
    def override_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number on which the Backend responds. Default `80`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="preferIpv6")
    def prefer_ipv6(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Prefer IPv6 connections to origins for hostname backends. Default `false`
        """
        return pulumi.get(self, "prefer_ipv6")

    @prefer_ipv6.setter
    def prefer_ipv6(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "prefer_ipv6", value)

    @_builtins.property
    @pulumi.getter(name="requestCondition")
    def request_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a condition, which if met, will select this backend during a request.
        """
        return pulumi.get(self, "request_condition")

    @request_condition.setter
    def request_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_condition", value)

    @_builtins.property
    @pulumi.getter(name="shareKey")
    def share_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value that when shared across backends will enable those backends to share the same health check.
        """
        return pulumi.get(self, "share_key")

    @share_key.setter
    def share_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "share_key", value)

    @_builtins.property
    @pulumi.getter
    def shield(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The POP of the shield designated to reduce inbound load. Valid values for `shield` are included in the `GET /datacenters` API response
        """
        return pulumi.get(self, "shield")

    @shield.setter
    def shield(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shield", value)

    @_builtins.property
    @pulumi.getter(name="sslCaCert")
    def ssl_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CA certificate attached to origin.
        """
        return pulumi.get(self, "ssl_ca_cert")

    @ssl_ca_cert.setter
    def ssl_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="sslCertHostname")
    def ssl_cert_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure certificate validation. Does not affect SNI at all
        """
        return pulumi.get(self, "ssl_cert_hostname")

    @ssl_cert_hostname.setter
    def ssl_cert_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_cert_hostname", value)

    @_builtins.property
    @pulumi.getter(name="sslCheckCert")
    def ssl_check_cert(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Be strict about checking SSL certs. Default `true`
        """
        return pulumi.get(self, "ssl_check_cert")

    @ssl_check_cert.setter
    def ssl_check_cert(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ssl_check_cert", value)

    @_builtins.property
    @pulumi.getter(name="sslCiphers")
    def ssl_ciphers(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cipher list consisting of one or more cipher strings separated by colons. Commas or spaces are also acceptable separators but colons are normally used.
        """
        return pulumi.get(self, "ssl_ciphers")

    @ssl_ciphers.setter
    def ssl_ciphers(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_ciphers", value)

    @_builtins.property
    @pulumi.getter(name="sslClientCert")
    def ssl_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client certificate attached to origin. Used when connecting to the backend
        """
        return pulumi.get(self, "ssl_client_cert")

    @ssl_client_cert.setter
    def ssl_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="sslClientKey")
    def ssl_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client key attached to origin. Used when connecting to the backend
        """
        return pulumi.get(self, "ssl_client_key")

    @ssl_client_key.setter
    def ssl_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_client_key", value)

    @_builtins.property
    @pulumi.getter(name="sslSniHostname")
    def ssl_sni_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure SNI in the TLS handshake. Does not affect cert validation at all
        """
        return pulumi.get(self, "ssl_sni_hostname")

    @ssl_sni_hostname.setter
    def ssl_sni_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssl_sni_hostname", value)

    @_builtins.property
    @pulumi.getter(name="useSsl")
    def use_ssl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not to use SSL to reach the Backend. Default `false`
        """
        return pulumi.get(self, "use_ssl")

    @use_ssl.setter
    def use_ssl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_ssl", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The [portion of traffic](https://docs.fastly.com/en/guides/load-balancing-configuration#how-weight-affects-load-balancing) to send to this Backend. Each Backend receives weight / total of the traffic. Default `100`
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class ServiceVclCacheSettingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this Cache Setting. It is important to note that changing this attribute will delete and recreate the resource
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        One of cache, pass, or restart, as defined on Fastly's documentation under "[Caching action descriptions](https://docs.fastly.com/en/guides/controlling-caching#caching-action-descriptions)"
        """
        cache_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of already defined `condition` used to test whether this settings object should be used. This `condition` must be of type `CACHE`
        """
        stale_ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max "Time To Live" for stale (unreachable) objects
        """
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        The Time-To-Live (TTL) for the object
        """
elif False:
    ServiceVclCacheSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclCacheSettingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 cache_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 stale_ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 ttl: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique name for this Cache Setting. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] action: One of cache, pass, or restart, as defined on Fastly's documentation under "[Caching action descriptions](https://docs.fastly.com/en/guides/controlling-caching#caching-action-descriptions)"
        :param pulumi.Input[_builtins.str] cache_condition: Name of already defined `condition` used to test whether this settings object should be used. This `condition` must be of type `CACHE`
        :param pulumi.Input[_builtins.int] stale_ttl: Max "Time To Live" for stale (unreachable) objects
        :param pulumi.Input[_builtins.int] ttl: The Time-To-Live (TTL) for the object
        """
        pulumi.set(__self__, "name", name)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if cache_condition is not None:
            pulumi.set(__self__, "cache_condition", cache_condition)
        if stale_ttl is not None:
            pulumi.set(__self__, "stale_ttl", stale_ttl)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this Cache Setting. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        One of cache, pass, or restart, as defined on Fastly's documentation under "[Caching action descriptions](https://docs.fastly.com/en/guides/controlling-caching#caching-action-descriptions)"
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="cacheCondition")
    def cache_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of already defined `condition` used to test whether this settings object should be used. This `condition` must be of type `CACHE`
        """
        return pulumi.get(self, "cache_condition")

    @cache_condition.setter
    def cache_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_condition", value)

    @_builtins.property
    @pulumi.getter(name="staleTtl")
    def stale_ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max "Time To Live" for stale (unreachable) objects
        """
        return pulumi.get(self, "stale_ttl")

    @stale_ttl.setter
    def stale_ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "stale_ttl", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The Time-To-Live (TTL) for the object
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class ServiceVclConditionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name for the condition. It is important to note that changing this attribute will delete and recreate the resource
        """
        statement: pulumi.Input[_builtins.str]
        """
        The statement used to determine if the condition is met
        """
        type: pulumi.Input[_builtins.str]
        """
        Type of condition, either `REQUEST` (req), `RESPONSE` (req, resp), or `CACHE` (req, beresp)
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        A number used to determine the order in which multiple conditions execute. Lower numbers execute first. Default `10`
        """
elif False:
    ServiceVclConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclConditionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 statement: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name for the condition. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] statement: The statement used to determine if the condition is met
        :param pulumi.Input[_builtins.str] type: Type of condition, either `REQUEST` (req), `RESPONSE` (req, resp), or `CACHE` (req, beresp)
        :param pulumi.Input[_builtins.int] priority: A number used to determine the order in which multiple conditions execute. Lower numbers execute first. Default `10`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "statement", statement)
        pulumi.set(__self__, "type", type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name for the condition. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def statement(self) -> pulumi.Input[_builtins.str]:
        """
        The statement used to determine if the condition is met
        """
        return pulumi.get(self, "statement")

    @statement.setter
    def statement(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "statement", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of condition, either `REQUEST` (req), `RESPONSE` (req, resp), or `CACHE` (req, beresp)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A number used to determine the order in which multiple conditions execute. Lower numbers execute first. Default `10`
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class ServiceVclDictionaryArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this dictionary. It is important to note that changing this attribute will delete and recreate the dictionary, and discard the current items in the dictionary
        """
        dictionary_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the dictionary
        """
        force_destroy: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        """
        write_only: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    ServiceVclDictionaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclDictionaryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 dictionary_id: Optional[pulumi.Input[_builtins.str]] = None,
                 force_destroy: Optional[pulumi.Input[_builtins.bool]] = None,
                 write_only: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A unique name to identify this dictionary. It is important to note that changing this attribute will delete and recreate the dictionary, and discard the current items in the dictionary
        :param pulumi.Input[_builtins.str] dictionary_id: The ID of the dictionary
        :param pulumi.Input[_builtins.bool] force_destroy: Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        """
        pulumi.set(__self__, "name", name)
        if dictionary_id is not None:
            pulumi.set(__self__, "dictionary_id", dictionary_id)
        if force_destroy is not None:
            pulumi.set(__self__, "force_destroy", force_destroy)
        if write_only is not None:
            pulumi.set(__self__, "write_only", write_only)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this dictionary. It is important to note that changing this attribute will delete and recreate the dictionary, and discard the current items in the dictionary
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="dictionaryId")
    def dictionary_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the dictionary
        """
        return pulumi.get(self, "dictionary_id")

    @dictionary_id.setter
    def dictionary_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dictionary_id", value)

    @_builtins.property
    @pulumi.getter(name="forceDestroy")
    def force_destroy(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allow the dictionary to be deleted, even if it contains entries. Defaults to false.
        """
        return pulumi.get(self, "force_destroy")

    @force_destroy.setter
    def force_destroy(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force_destroy", value)

    @_builtins.property
    @pulumi.getter(name="writeOnly")
    def write_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "write_only")

    @write_only.setter
    def write_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "write_only", value)


if not MYPY:
    class ServiceVclDirectorArgsDict(TypedDict):
        backends: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Names of defined backends to map the director to. Example: `[ "origin1", "origin2" ]`
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this Director. It is important to note that changing this attribute will delete and recreate the resource
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional comment about the Director
        """
        quorum: NotRequired[pulumi.Input[_builtins.int]]
        """
        Percentage of capacity that needs to be up for the director itself to be considered up. Default `75`
        """
        retries: NotRequired[pulumi.Input[_builtins.int]]
        """
        How many backends to search if it fails. Default `5`
        """
        shield: NotRequired[pulumi.Input[_builtins.str]]
        """
        Selected POP to serve as a "shield" for backends. Valid values for `shield` are included in the [`GET /datacenters`](https://developer.fastly.com/reference/api/utils/datacenter/) API response
        """
        type: NotRequired[pulumi.Input[_builtins.int]]
        """
        Type of load balance group to use. Integer, 1 to 4. Values: `1` (random), `3` (hash), `4` (client). Default `1`
        """
elif False:
    ServiceVclDirectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclDirectorArgs:
    def __init__(__self__, *,
                 backends: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None,
                 quorum: Optional[pulumi.Input[_builtins.int]] = None,
                 retries: Optional[pulumi.Input[_builtins.int]] = None,
                 shield: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] backends: Names of defined backends to map the director to. Example: `[ "origin1", "origin2" ]`
        :param pulumi.Input[_builtins.str] name: Unique name for this Director. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] comment: An optional comment about the Director
        :param pulumi.Input[_builtins.int] quorum: Percentage of capacity that needs to be up for the director itself to be considered up. Default `75`
        :param pulumi.Input[_builtins.int] retries: How many backends to search if it fails. Default `5`
        :param pulumi.Input[_builtins.str] shield: Selected POP to serve as a "shield" for backends. Valid values for `shield` are included in the [`GET /datacenters`](https://developer.fastly.com/reference/api/utils/datacenter/) API response
        :param pulumi.Input[_builtins.int] type: Type of load balance group to use. Integer, 1 to 4. Values: `1` (random), `3` (hash), `4` (client). Default `1`
        """
        pulumi.set(__self__, "backends", backends)
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if quorum is not None:
            pulumi.set(__self__, "quorum", quorum)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if shield is not None:
            pulumi.set(__self__, "shield", shield)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def backends(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Names of defined backends to map the director to. Example: `[ "origin1", "origin2" ]`
        """
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "backends", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this Director. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional comment about the Director
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)

    @_builtins.property
    @pulumi.getter
    def quorum(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Percentage of capacity that needs to be up for the director itself to be considered up. Default `75`
        """
        return pulumi.get(self, "quorum")

    @quorum.setter
    def quorum(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "quorum", value)

    @_builtins.property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How many backends to search if it fails. Default `5`
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retries", value)

    @_builtins.property
    @pulumi.getter
    def shield(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Selected POP to serve as a "shield" for backends. Valid values for `shield` are included in the [`GET /datacenters`](https://developer.fastly.com/reference/api/utils/datacenter/) API response
        """
        return pulumi.get(self, "shield")

    @shield.setter
    def shield(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "shield", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Type of load balance group to use. Integer, 1 to 4. Values: `1` (random), `3` (hash), `4` (client). Default `1`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceVclDomainArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The domain that this Service will respond to. It is important to note that changing this attribute will delete and recreate the resource.
        """
        comment: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional comment about the Domain.
        """
elif False:
    ServiceVclDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclDomainArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 comment: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The domain that this Service will respond to. It is important to note that changing this attribute will delete and recreate the resource.
        :param pulumi.Input[_builtins.str] comment: An optional comment about the Domain.
        """
        pulumi.set(__self__, "name", name)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The domain that this Service will respond to. It is important to note that changing this attribute will delete and recreate the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional comment about the Domain.
        """
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "comment", value)


if not MYPY:
    class ServiceVclDynamicsnippetArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name that is unique across "regular" and "dynamic" VCL Snippet configuration blocks. It is important to note that changing this attribute will delete and recreate the resource
        """
        type: pulumi.Input[_builtins.str]
        """
        The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hash`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`)
        """
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        The VCL code that specifies exactly what the snippet does
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority determines the ordering for multiple snippets. Lower numbers execute first. Defaults to `100`
        """
        snippet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the dynamic snippet
        """
elif False:
    ServiceVclDynamicsnippetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclDynamicsnippetArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 snippet_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name that is unique across "regular" and "dynamic" VCL Snippet configuration blocks. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] type: The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hash`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`)
        :param pulumi.Input[_builtins.str] content: The VCL code that specifies exactly what the snippet does
        :param pulumi.Input[_builtins.int] priority: Priority determines the ordering for multiple snippets. Lower numbers execute first. Defaults to `100`
        :param pulumi.Input[_builtins.str] snippet_id: The ID of the dynamic snippet
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if snippet_id is not None:
            pulumi.set(__self__, "snippet_id", snippet_id)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name that is unique across "regular" and "dynamic" VCL Snippet configuration blocks. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hash`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The VCL code that specifies exactly what the snippet does
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority determines the ordering for multiple snippets. Lower numbers execute first. Defaults to `100`
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter(name="snippetId")
    def snippet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the dynamic snippet
        """
        return pulumi.get(self, "snippet_id")

    @snippet_id.setter
    def snippet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "snippet_id", value)


if not MYPY:
    class ServiceVclGzipArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name to refer to this gzip condition. It is important to note that changing this attribute will delete and recreate the resource
        """
        cache_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of already defined `condition` controlling when this gzip configuration applies. This `condition` must be of type `CACHE`. For detailed information about Conditionals, see [Fastly's Documentation on Conditionals](https://docs.fastly.com/en/guides/using-conditions)
        """
        content_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The content-type for each type of content you wish to have dynamically gzip'ed. Example: `["text/html", "text/css"]`
        """
        extensions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        File extensions for each file type to dynamically gzip. Example: `["css", "js"]`
        """
elif False:
    ServiceVclGzipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclGzipArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 cache_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 content_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 extensions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name to refer to this gzip condition. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] cache_condition: Name of already defined `condition` controlling when this gzip configuration applies. This `condition` must be of type `CACHE`. For detailed information about Conditionals, see [Fastly's Documentation on Conditionals](https://docs.fastly.com/en/guides/using-conditions)
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] content_types: The content-type for each type of content you wish to have dynamically gzip'ed. Example: `["text/html", "text/css"]`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] extensions: File extensions for each file type to dynamically gzip. Example: `["css", "js"]`
        """
        pulumi.set(__self__, "name", name)
        if cache_condition is not None:
            pulumi.set(__self__, "cache_condition", cache_condition)
        if content_types is not None:
            pulumi.set(__self__, "content_types", content_types)
        if extensions is not None:
            pulumi.set(__self__, "extensions", extensions)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name to refer to this gzip condition. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="cacheCondition")
    def cache_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of already defined `condition` controlling when this gzip configuration applies. This `condition` must be of type `CACHE`. For detailed information about Conditionals, see [Fastly's Documentation on Conditionals](https://docs.fastly.com/en/guides/using-conditions)
        """
        return pulumi.get(self, "cache_condition")

    @cache_condition.setter
    def cache_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_condition", value)

    @_builtins.property
    @pulumi.getter(name="contentTypes")
    def content_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The content-type for each type of content you wish to have dynamically gzip'ed. Example: `["text/html", "text/css"]`
        """
        return pulumi.get(self, "content_types")

    @content_types.setter
    def content_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "content_types", value)

    @_builtins.property
    @pulumi.getter
    def extensions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        File extensions for each file type to dynamically gzip. Example: `["css", "js"]`
        """
        return pulumi.get(self, "extensions")

    @extensions.setter
    def extensions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extensions", value)


if not MYPY:
    class ServiceVclHeaderArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        The Header manipulation action to take; must be one of `set`, `append`, `delete`, `regex`, or `regex_repeat`
        """
        destination: pulumi.Input[_builtins.str]
        """
        The name of the header that is going to be affected by the Action
        """
        name: pulumi.Input[_builtins.str]
        """
        Unique name for this header attribute. It is important to note that changing this attribute will delete and recreate the resource
        """
        type: pulumi.Input[_builtins.str]
        """
        The Request type on which to apply the selected Action; must be one of `request`, `fetch`, `cache` or `response`
        """
        cache_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of already defined `condition` to apply. This `condition` must be of type `CACHE`
        """
        ignore_if_set: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Don't add the header if it is already. (Only applies to `set` action.). Default `false`
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Lower priorities execute first. Default: `100`
        """
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        Regular expression to use (Only applies to `regex` and `regex_repeat` actions.)
        """
        request_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of already defined `condition` to apply. This `condition` must be of type `REQUEST`
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of already defined `condition` to apply. This `condition` must be of type `RESPONSE`. For detailed information about Conditionals, see [Fastly's Documentation on Conditionals](https://docs.fastly.com/en/guides/using-conditions)
        """
        source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Variable to be used as a source for the header content (Does not apply to `delete` action.)
        """
        substitution: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value to substitute in place of regular expression. (Only applies to `regex` and `regex_repeat`.)
        """
elif False:
    ServiceVclHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclHeaderArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 destination: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 cache_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_if_set: Optional[pulumi.Input[_builtins.bool]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 regex: Optional[pulumi.Input[_builtins.str]] = None,
                 request_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 source: Optional[pulumi.Input[_builtins.str]] = None,
                 substitution: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The Header manipulation action to take; must be one of `set`, `append`, `delete`, `regex`, or `regex_repeat`
        :param pulumi.Input[_builtins.str] destination: The name of the header that is going to be affected by the Action
        :param pulumi.Input[_builtins.str] name: Unique name for this header attribute. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] type: The Request type on which to apply the selected Action; must be one of `request`, `fetch`, `cache` or `response`
        :param pulumi.Input[_builtins.str] cache_condition: Name of already defined `condition` to apply. This `condition` must be of type `CACHE`
        :param pulumi.Input[_builtins.bool] ignore_if_set: Don't add the header if it is already. (Only applies to `set` action.). Default `false`
        :param pulumi.Input[_builtins.int] priority: Lower priorities execute first. Default: `100`
        :param pulumi.Input[_builtins.str] regex: Regular expression to use (Only applies to `regex` and `regex_repeat` actions.)
        :param pulumi.Input[_builtins.str] request_condition: Name of already defined `condition` to apply. This `condition` must be of type `REQUEST`
        :param pulumi.Input[_builtins.str] response_condition: Name of already defined `condition` to apply. This `condition` must be of type `RESPONSE`. For detailed information about Conditionals, see [Fastly's Documentation on Conditionals](https://docs.fastly.com/en/guides/using-conditions)
        :param pulumi.Input[_builtins.str] source: Variable to be used as a source for the header content (Does not apply to `delete` action.)
        :param pulumi.Input[_builtins.str] substitution: Value to substitute in place of regular expression. (Only applies to `regex` and `regex_repeat`.)
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "destination", destination)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if cache_condition is not None:
            pulumi.set(__self__, "cache_condition", cache_condition)
        if ignore_if_set is not None:
            pulumi.set(__self__, "ignore_if_set", ignore_if_set)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if request_condition is not None:
            pulumi.set(__self__, "request_condition", request_condition)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if substitution is not None:
            pulumi.set(__self__, "substitution", substitution)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        The Header manipulation action to take; must be one of `set`, `append`, `delete`, `regex`, or `regex_repeat`
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the header that is going to be affected by the Action
        """
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name for this header attribute. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The Request type on which to apply the selected Action; must be one of `request`, `fetch`, `cache` or `response`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="cacheCondition")
    def cache_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of already defined `condition` to apply. This `condition` must be of type `CACHE`
        """
        return pulumi.get(self, "cache_condition")

    @cache_condition.setter
    def cache_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_condition", value)

    @_builtins.property
    @pulumi.getter(name="ignoreIfSet")
    def ignore_if_set(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Don't add the header if it is already. (Only applies to `set` action.). Default `false`
        """
        return pulumi.get(self, "ignore_if_set")

    @ignore_if_set.setter
    def ignore_if_set(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_if_set", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Lower priorities execute first. Default: `100`
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Regular expression to use (Only applies to `regex` and `regex_repeat` actions.)
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)

    @_builtins.property
    @pulumi.getter(name="requestCondition")
    def request_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of already defined `condition` to apply. This `condition` must be of type `REQUEST`
        """
        return pulumi.get(self, "request_condition")

    @request_condition.setter
    def request_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_condition", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of already defined `condition` to apply. This `condition` must be of type `RESPONSE`. For detailed information about Conditionals, see [Fastly's Documentation on Conditionals](https://docs.fastly.com/en/guides/using-conditions)
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Variable to be used as a source for the header content (Does not apply to `delete` action.)
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def substitution(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value to substitute in place of regular expression. (Only applies to `regex` and `regex_repeat`.)
        """
        return pulumi.get(self, "substitution")

    @substitution.setter
    def substitution(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "substitution", value)


if not MYPY:
    class ServiceVclHealthcheckArgsDict(TypedDict):
        host: pulumi.Input[_builtins.str]
        """
        The Host header to send for this Healthcheck
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this Healthcheck. It is important to note that changing this attribute will delete and recreate the resource
        """
        path: pulumi.Input[_builtins.str]
        """
        The path to check
        """
        check_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        How often to run the Healthcheck in milliseconds. Default `5000`
        """
        expected_response: NotRequired[pulumi.Input[_builtins.int]]
        """
        The status code expected from the host. Default `200`
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Custom health check HTTP headers (e.g. if your health check requires an API key to be provided).
        """
        http_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to use version 1.0 or 1.1 HTTP. Default `1.1`
        """
        initial: NotRequired[pulumi.Input[_builtins.int]]
        """
        When loading a config, the initial number of probes to be seen as OK. Default `3`
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Which HTTP method to use. Default `HEAD`
        """
        threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        How many Healthchecks must succeed to be considered healthy. Default `3`
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in milliseconds. Default `5000`
        """
        window: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of most recent Healthcheck queries to keep for this Healthcheck. Default `5`
        """
elif False:
    ServiceVclHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclHealthcheckArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 check_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 expected_response: Optional[pulumi.Input[_builtins.int]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_version: Optional[pulumi.Input[_builtins.str]] = None,
                 initial: Optional[pulumi.Input[_builtins.int]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 window: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The Host header to send for this Healthcheck
        :param pulumi.Input[_builtins.str] name: A unique name to identify this Healthcheck. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] path: The path to check
        :param pulumi.Input[_builtins.int] check_interval: How often to run the Healthcheck in milliseconds. Default `5000`
        :param pulumi.Input[_builtins.int] expected_response: The status code expected from the host. Default `200`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] headers: Custom health check HTTP headers (e.g. if your health check requires an API key to be provided).
        :param pulumi.Input[_builtins.str] http_version: Whether to use version 1.0 or 1.1 HTTP. Default `1.1`
        :param pulumi.Input[_builtins.int] initial: When loading a config, the initial number of probes to be seen as OK. Default `3`
        :param pulumi.Input[_builtins.str] method: Which HTTP method to use. Default `HEAD`
        :param pulumi.Input[_builtins.int] threshold: How many Healthchecks must succeed to be considered healthy. Default `3`
        :param pulumi.Input[_builtins.int] timeout: Timeout in milliseconds. Default `5000`
        :param pulumi.Input[_builtins.int] window: The number of most recent Healthcheck queries to keep for this Healthcheck. Default `5`
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if check_interval is not None:
            pulumi.set(__self__, "check_interval", check_interval)
        if expected_response is not None:
            pulumi.set(__self__, "expected_response", expected_response)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if initial is not None:
            pulumi.set(__self__, "initial", initial)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        The Host header to send for this Healthcheck
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this Healthcheck. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to check
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="checkInterval")
    def check_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How often to run the Healthcheck in milliseconds. Default `5000`
        """
        return pulumi.get(self, "check_interval")

    @check_interval.setter
    def check_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "check_interval", value)

    @_builtins.property
    @pulumi.getter(name="expectedResponse")
    def expected_response(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The status code expected from the host. Default `200`
        """
        return pulumi.get(self, "expected_response")

    @expected_response.setter
    def expected_response(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expected_response", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Custom health check HTTP headers (e.g. if your health check requires an API key to be provided).
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to use version 1.0 or 1.1 HTTP. Default `1.1`
        """
        return pulumi.get(self, "http_version")

    @http_version.setter
    def http_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_version", value)

    @_builtins.property
    @pulumi.getter
    def initial(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        When loading a config, the initial number of probes to be seen as OK. Default `3`
        """
        return pulumi.get(self, "initial")

    @initial.setter
    def initial(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Which HTTP method to use. Default `HEAD`
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How many Healthchecks must succeed to be considered healthy. Default `3`
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "threshold", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in milliseconds. Default `5000`
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)

    @_builtins.property
    @pulumi.getter
    def window(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of most recent Healthcheck queries to keep for this Healthcheck. Default `5`
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "window", value)


if not MYPY:
    class ServiceVclImageOptimizerDefaultSettingsArgsDict(TypedDict):
        allow_video: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables GIF to MP4 transformations on this service.
        """
        jpeg_quality: NotRequired[pulumi.Input[_builtins.int]]
        """
        The default quality to use with JPEG output. This can be overridden with the "quality" parameter on specific image optimizer requests.
        """
        jpeg_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default type of JPEG output to use. This can be overridden with "format=bjpeg" and "format=pjpeg" on specific image optimizer requests. Valid values are `auto`, `baseline` and `progressive`.
        	- auto: Match the input JPEG type, or baseline if transforming from a non-JPEG input.
        	- baseline: Output baseline JPEG images
        	- progressive: Output progressive JPEG images
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used by the provider to identify modified settings. Changing this value will force the entire block to be deleted, then recreated.
        """
        resize_filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of filter to use while resizing an image. Valid values are `lanczos3`, `lanczos2`, `bicubic`, `bilinear` and `nearest`.
        	- lanczos3: A Lanczos filter with a kernel size of 3. Lanczos filters can detect edges and linear features within an image, providing the best possible reconstruction.
        	- lanczos2: A Lanczos filter with a kernel size of 2.
        	- bicubic: A filter using an average of a 4x4 environment of pixels, weighing the innermost pixels higher.
        	- bilinear: A filter using an average of a 2x2 environment of pixels.
        	- nearest: A filter using the value of nearby translated pixel values. Preserves hard edges.
        """
        upscale: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether or not we should allow output images to render at sizes larger than input.
        """
        webp: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Controls whether or not to default to WebP output when the client supports it. This is equivalent to adding "auto=webp" to all image optimizer requests.
        """
        webp_quality: NotRequired[pulumi.Input[_builtins.int]]
        """
        The default quality to use with WebP output. This can be overridden with the second option in the "quality" URL parameter on specific image optimizer requests.
        """
elif False:
    ServiceVclImageOptimizerDefaultSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclImageOptimizerDefaultSettingsArgs:
    def __init__(__self__, *,
                 allow_video: Optional[pulumi.Input[_builtins.bool]] = None,
                 jpeg_quality: Optional[pulumi.Input[_builtins.int]] = None,
                 jpeg_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 resize_filter: Optional[pulumi.Input[_builtins.str]] = None,
                 upscale: Optional[pulumi.Input[_builtins.bool]] = None,
                 webp: Optional[pulumi.Input[_builtins.bool]] = None,
                 webp_quality: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_video: Enables GIF to MP4 transformations on this service.
        :param pulumi.Input[_builtins.int] jpeg_quality: The default quality to use with JPEG output. This can be overridden with the "quality" parameter on specific image optimizer requests.
        :param pulumi.Input[_builtins.str] jpeg_type: The default type of JPEG output to use. This can be overridden with "format=bjpeg" and "format=pjpeg" on specific image optimizer requests. Valid values are `auto`, `baseline` and `progressive`.
               	- auto: Match the input JPEG type, or baseline if transforming from a non-JPEG input.
               	- baseline: Output baseline JPEG images
               	- progressive: Output progressive JPEG images
        :param pulumi.Input[_builtins.str] name: Used by the provider to identify modified settings. Changing this value will force the entire block to be deleted, then recreated.
        :param pulumi.Input[_builtins.str] resize_filter: The type of filter to use while resizing an image. Valid values are `lanczos3`, `lanczos2`, `bicubic`, `bilinear` and `nearest`.
               	- lanczos3: A Lanczos filter with a kernel size of 3. Lanczos filters can detect edges and linear features within an image, providing the best possible reconstruction.
               	- lanczos2: A Lanczos filter with a kernel size of 2.
               	- bicubic: A filter using an average of a 4x4 environment of pixels, weighing the innermost pixels higher.
               	- bilinear: A filter using an average of a 2x2 environment of pixels.
               	- nearest: A filter using the value of nearby translated pixel values. Preserves hard edges.
        :param pulumi.Input[_builtins.bool] upscale: Whether or not we should allow output images to render at sizes larger than input.
        :param pulumi.Input[_builtins.bool] webp: Controls whether or not to default to WebP output when the client supports it. This is equivalent to adding "auto=webp" to all image optimizer requests.
        :param pulumi.Input[_builtins.int] webp_quality: The default quality to use with WebP output. This can be overridden with the second option in the "quality" URL parameter on specific image optimizer requests.
        """
        if allow_video is not None:
            pulumi.set(__self__, "allow_video", allow_video)
        if jpeg_quality is not None:
            pulumi.set(__self__, "jpeg_quality", jpeg_quality)
        if jpeg_type is not None:
            pulumi.set(__self__, "jpeg_type", jpeg_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if resize_filter is not None:
            pulumi.set(__self__, "resize_filter", resize_filter)
        if upscale is not None:
            pulumi.set(__self__, "upscale", upscale)
        if webp is not None:
            pulumi.set(__self__, "webp", webp)
        if webp_quality is not None:
            pulumi.set(__self__, "webp_quality", webp_quality)

    @_builtins.property
    @pulumi.getter(name="allowVideo")
    def allow_video(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables GIF to MP4 transformations on this service.
        """
        return pulumi.get(self, "allow_video")

    @allow_video.setter
    def allow_video(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_video", value)

    @_builtins.property
    @pulumi.getter(name="jpegQuality")
    def jpeg_quality(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The default quality to use with JPEG output. This can be overridden with the "quality" parameter on specific image optimizer requests.
        """
        return pulumi.get(self, "jpeg_quality")

    @jpeg_quality.setter
    def jpeg_quality(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "jpeg_quality", value)

    @_builtins.property
    @pulumi.getter(name="jpegType")
    def jpeg_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default type of JPEG output to use. This can be overridden with "format=bjpeg" and "format=pjpeg" on specific image optimizer requests. Valid values are `auto`, `baseline` and `progressive`.
        	- auto: Match the input JPEG type, or baseline if transforming from a non-JPEG input.
        	- baseline: Output baseline JPEG images
        	- progressive: Output progressive JPEG images
        """
        return pulumi.get(self, "jpeg_type")

    @jpeg_type.setter
    def jpeg_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "jpeg_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used by the provider to identify modified settings. Changing this value will force the entire block to be deleted, then recreated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="resizeFilter")
    def resize_filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of filter to use while resizing an image. Valid values are `lanczos3`, `lanczos2`, `bicubic`, `bilinear` and `nearest`.
        	- lanczos3: A Lanczos filter with a kernel size of 3. Lanczos filters can detect edges and linear features within an image, providing the best possible reconstruction.
        	- lanczos2: A Lanczos filter with a kernel size of 2.
        	- bicubic: A filter using an average of a 4x4 environment of pixels, weighing the innermost pixels higher.
        	- bilinear: A filter using an average of a 2x2 environment of pixels.
        	- nearest: A filter using the value of nearby translated pixel values. Preserves hard edges.
        """
        return pulumi.get(self, "resize_filter")

    @resize_filter.setter
    def resize_filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resize_filter", value)

    @_builtins.property
    @pulumi.getter
    def upscale(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether or not we should allow output images to render at sizes larger than input.
        """
        return pulumi.get(self, "upscale")

    @upscale.setter
    def upscale(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "upscale", value)

    @_builtins.property
    @pulumi.getter
    def webp(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Controls whether or not to default to WebP output when the client supports it. This is equivalent to adding "auto=webp" to all image optimizer requests.
        """
        return pulumi.get(self, "webp")

    @webp.setter
    def webp(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "webp", value)

    @_builtins.property
    @pulumi.getter(name="webpQuality")
    def webp_quality(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The default quality to use with WebP output. This can be overridden with the second option in the "quality" URL parameter on specific image optimizer requests.
        """
        return pulumi.get(self, "webp_quality")

    @webp_quality.setter
    def webp_quality(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "webp_quality", value)


if not MYPY:
    class ServiceVclLoggingBigqueryArgsDict(TypedDict):
        dataset: pulumi.Input[_builtins.str]
        """
        The ID of your BigQuery dataset
        """
        email: pulumi.Input[_builtins.str]
        """
        The email for the service account with write access to your BigQuery dataset. If not provided, this will be pulled from a `FASTLY_BQ_EMAIL` environment variable
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this BigQuery logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        project_id: pulumi.Input[_builtins.str]
        """
        The ID of your GCP project
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        The secret key associated with the service account that has write access to your BigQuery table. If not provided, this will be pulled from the `FASTLY_BQ_SECRET_KEY` environment variable. Typical format for this is a private key in a string with newlines
        """
        table: pulumi.Input[_builtins.str]
        """
        The ID of your BigQuery table
        """
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The google account name used to obtain temporary credentials (default none). Not required if 'email' and 'secret_key' are provided. You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The logging format desired.
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a condition to apply this logging.
        """
        template: NotRequired[pulumi.Input[_builtins.str]]
        """
        BigQuery table name suffix template
        """
elif False:
    ServiceVclLoggingBigqueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingBigqueryArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input[_builtins.str],
                 email: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 table: pulumi.Input[_builtins.str],
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: The ID of your BigQuery dataset
        :param pulumi.Input[_builtins.str] email: The email for the service account with write access to your BigQuery dataset. If not provided, this will be pulled from a `FASTLY_BQ_EMAIL` environment variable
        :param pulumi.Input[_builtins.str] name: A unique name to identify this BigQuery logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] project_id: The ID of your GCP project
        :param pulumi.Input[_builtins.str] secret_key: The secret key associated with the service account that has write access to your BigQuery table. If not provided, this will be pulled from the `FASTLY_BQ_SECRET_KEY` environment variable. Typical format for this is a private key in a string with newlines
        :param pulumi.Input[_builtins.str] table: The ID of your BigQuery table
        :param pulumi.Input[_builtins.str] account_name: The google account name used to obtain temporary credentials (default none). Not required if 'email' and 'secret_key' are provided. You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        :param pulumi.Input[_builtins.str] format: The logging format desired.
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: Name of a condition to apply this logging.
        :param pulumi.Input[_builtins.str] template: BigQuery table name suffix template
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "table", table)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your BigQuery dataset
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> pulumi.Input[_builtins.str]:
        """
        The email for the service account with write access to your BigQuery dataset. If not provided, this will be pulled from a `FASTLY_BQ_EMAIL` environment variable
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this BigQuery logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your GCP project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        The secret key associated with the service account that has write access to your BigQuery table. If not provided, this will be pulled from the `FASTLY_BQ_SECRET_KEY` environment variable. Typical format for this is a private key in a string with newlines
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def table(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your BigQuery table
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "table", value)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The google account name used to obtain temporary credentials (default none). Not required if 'email' and 'secret_key' are provided. You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The logging format desired.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a condition to apply this logging.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BigQuery table name suffix template
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class ServiceVclLoggingBlobstorageArgsDict(TypedDict):
        account_name: pulumi.Input[_builtins.str]
        """
        The unique Azure Blob Storage namespace in which your data objects are stored
        """
        container: pulumi.Input[_builtins.str]
        """
        The name of the Azure Blob Storage container in which to store logs
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify the Azure Blob Storage endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        sas_token: pulumi.Input[_builtins.str]
        """
        The Azure shared access signature providing write access to the blob service objects. Be sure to update your token before it expires or the logging functionality will not work
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        file_max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum size of an uploaded log file, if non-zero.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2)
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to upload logs to. Must end with a trailing slash. If this field is left empty, the files will be saved in the container's root path
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently the logs should be transferred in seconds. Default `3600`
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceVclLoggingBlobstorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingBlobstorageArgs:
    def __init__(__self__, *,
                 account_name: pulumi.Input[_builtins.str],
                 container: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 sas_token: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 file_max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_name: The unique Azure Blob Storage namespace in which your data objects are stored
        :param pulumi.Input[_builtins.str] container: The name of the Azure Blob Storage container in which to store logs
        :param pulumi.Input[_builtins.str] name: A unique name to identify the Azure Blob Storage endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] sas_token: The Azure shared access signature providing write access to the blob service objects. Be sure to update your token before it expires or the logging functionality will not work
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.int] file_max_bytes: Maximum size of an uploaded log file, if non-zero.
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2)
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: The path to upload logs to. Must end with a trailing slash. If this field is left empty, the files will be saved in the container's root path
        :param pulumi.Input[_builtins.int] period: How frequently the logs should be transferred in seconds. Default `3600`
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "account_name", account_name)
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sas_token", sas_token)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if file_max_bytes is not None:
            pulumi.set(__self__, "file_max_bytes", file_max_bytes)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique Azure Blob Storage namespace in which your data objects are stored
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter
    def container(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Azure Blob Storage container in which to store logs
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify the Azure Blob Storage endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> pulumi.Input[_builtins.str]:
        """
        The Azure shared access signature providing write access to the blob service objects. Be sure to update your token before it expires or the logging functionality will not work
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sas_token", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter(name="fileMaxBytes")
    def file_max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum size of an uploaded log file, if non-zero.
        """
        return pulumi.get(self, "file_max_bytes")

    @file_max_bytes.setter
    def file_max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "file_max_bytes", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2)
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to upload logs to. Must end with a trailing slash. If this field is left empty, the files will be saved in the container's root path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently the logs should be transferred in seconds. Default `3600`
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceVclLoggingCloudfileArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        Your Cloud File account access key
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of your Cloud Files container
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Rackspace Cloud Files logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        user: pulumi.Input[_builtins.str]
        """
        The username for your Cloud Files account
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to upload logs to
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region to stream logs to. One of: DFW (Dallas), ORD (Chicago), IAD (Northern Virginia), LON (London), SYD (Sydney), HKG (Hong Kong)
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceVclLoggingCloudfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingCloudfileArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 bucket_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: Your Cloud File account access key
        :param pulumi.Input[_builtins.str] bucket_name: The name of your Cloud Files container
        :param pulumi.Input[_builtins.str] name: The unique name of the Rackspace Cloud Files logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] user: The username for your Cloud Files account
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] format: Apache style log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: The path to upload logs to
        :param pulumi.Input[_builtins.int] period: How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] region: The region to stream logs to. One of: DFW (Dallas), ORD (Chicago), IAD (Northern Virginia), LON (London), SYD (Sydney), HKG (Hong Kong)
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "user", user)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your Cloud File account access key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of your Cloud Files container
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Rackspace Cloud Files logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The username for your Cloud Files account
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to upload logs to
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region to stream logs to. One of: DFW (Dallas), ORD (Chicago), IAD (Northern Virginia), LON (London), SYD (Sydney), HKG (Hong Kong)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceVclLoggingDatadogArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Datadog logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The API key from your Datadog account
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region that log data will be sent to. Defaults to `US` if undefined
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply.
        """
elif False:
    ServiceVclLoggingDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingDatadogArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Datadog logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The API key from your Datadog account
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] region: The region that log data will be sent to. Defaults to `US` if undefined
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Datadog logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The API key from your Datadog account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region that log data will be sent to. Defaults to `US` if undefined
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingDigitaloceanArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        Your DigitalOcean Spaces account access key
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of the DigitalOcean Space
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the DigitalOcean Spaces logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        Your DigitalOcean Spaces account secret key
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to upload logs to
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceVclLoggingDigitaloceanArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingDigitaloceanArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 bucket_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: Your DigitalOcean Spaces account access key
        :param pulumi.Input[_builtins.str] bucket_name: The name of the DigitalOcean Space
        :param pulumi.Input[_builtins.str] name: The unique name of the DigitalOcean Spaces logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] secret_key: Your DigitalOcean Spaces account secret key
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] domain: The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        :param pulumi.Input[_builtins.str] format: Apache style log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: The path to upload logs to
        :param pulumi.Input[_builtins.int] period: How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "secret_key", secret_key)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your DigitalOcean Spaces account access key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the DigitalOcean Space
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the DigitalOcean Spaces logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your DigitalOcean Spaces account secret key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain of the DigitalOcean Spaces endpoint (default `nyc3.digitaloceanspaces.com`)
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to upload logs to
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceVclLoggingElasticsearchArgsDict(TypedDict):
        index: pulumi.Input[_builtins.str]
        """
        The name of the Elasticsearch index to send documents (logs) to
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Elasticsearch logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        url: pulumi.Input[_builtins.str]
        """
        The Elasticsearch URL to stream logs to
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        BasicAuth password for Elasticsearch
        """
        pipeline: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the Elasticsearch ingest pipeline to apply pre-process transformations to before indexing
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        request_max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of logs sent in one request. Defaults to `0` for unbounded
        """
        request_max_entries: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of bytes sent in one request. Defaults to `0` for unbounded
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply
        """
        tls_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        tls_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        tls_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname used to verify the server's certificate. It can either be the Common Name (CN) or a Subject Alternative Name (SAN)
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        BasicAuth username for Elasticsearch
        """
elif False:
    ServiceVclLoggingElasticsearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingElasticsearchArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 pipeline: Optional[pulumi.Input[_builtins.str]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 request_max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 request_max_entries: Optional[pulumi.Input[_builtins.int]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] index: The name of the Elasticsearch index to send documents (logs) to
        :param pulumi.Input[_builtins.str] name: The unique name of the Elasticsearch logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] url: The Elasticsearch URL to stream logs to
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        :param pulumi.Input[_builtins.str] password: BasicAuth password for Elasticsearch
        :param pulumi.Input[_builtins.str] pipeline: The ID of the Elasticsearch ingest pipeline to apply pre-process transformations to before indexing
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.int] request_max_bytes: The maximum number of logs sent in one request. Defaults to `0` for unbounded
        :param pulumi.Input[_builtins.int] request_max_entries: The maximum number of bytes sent in one request. Defaults to `0` for unbounded
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply
        :param pulumi.Input[_builtins.str] tls_ca_cert: A secure certificate to authenticate the server with. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_cert: The client certificate used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_key: The client private key used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_hostname: The hostname used to verify the server's certificate. It can either be the Common Name (CN) or a Subject Alternative Name (SAN)
        :param pulumi.Input[_builtins.str] user: BasicAuth username for Elasticsearch
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if request_max_bytes is not None:
            pulumi.set(__self__, "request_max_bytes", request_max_bytes)
        if request_max_entries is not None:
            pulumi.set(__self__, "request_max_entries", request_max_entries)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def index(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Elasticsearch index to send documents (logs) to
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Elasticsearch logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The Elasticsearch URL to stream logs to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BasicAuth password for Elasticsearch
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def pipeline(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the Elasticsearch ingest pipeline to apply pre-process transformations to before indexing
        """
        return pulumi.get(self, "pipeline")

    @pipeline.setter
    def pipeline(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pipeline", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="requestMaxBytes")
    def request_max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of logs sent in one request. Defaults to `0` for unbounded
        """
        return pulumi.get(self, "request_max_bytes")

    @request_max_bytes.setter
    def request_max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_max_bytes", value)

    @_builtins.property
    @pulumi.getter(name="requestMaxEntries")
    def request_max_entries(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of bytes sent in one request. Defaults to `0` for unbounded
        """
        return pulumi.get(self, "request_max_entries")

    @request_max_entries.setter
    def request_max_entries(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_max_entries", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        return pulumi.get(self, "tls_ca_cert")

    @tls_ca_cert.setter
    def tls_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname used to verify the server's certificate. It can either be the Common Name (CN) or a Subject Alternative Name (SAN)
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        BasicAuth username for Elasticsearch
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ServiceVclLoggingFtpArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        The FTP address to stream logs to
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the FTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        password: pulumi.Input[_builtins.str]
        """
        The password for the server (for anonymous use an email address)
        """
        path: pulumi.Input[_builtins.str]
        """
        The path to upload log files to. If the path ends in `/` then it is treated as a directory
        """
        user: pulumi.Input[_builtins.str]
        """
        The username for the server (can be `anonymous`)
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently the logs should be transferred, in seconds (Default `3600`)
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number. Default: `21`
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply.
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceVclLoggingFtpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingFtpArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The FTP address to stream logs to
        :param pulumi.Input[_builtins.str] name: The unique name of the FTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] password: The password for the server (for anonymous use an email address)
        :param pulumi.Input[_builtins.str] path: The path to upload log files to. If the path ends in `/` then it is treated as a directory
        :param pulumi.Input[_builtins.str] user: The username for the server (can be `anonymous`)
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.int] period: How frequently the logs should be transferred, in seconds (Default `3600`)
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.int] port: The port number. Default: `21`
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply.
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "user", user)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        The FTP address to stream logs to
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the FTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        The password for the server (for anonymous use an email address)
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to upload log files to. If the path ends in `/` then it is treated as a directory
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The username for the server (can be `anonymous`)
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently the logs should be transferred, in seconds (Default `3600`)
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number. Default: `21`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceVclLoggingGcArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of the bucket in which to store the logs
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this GCS endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2)
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently the logs should be transferred, in seconds (Default 3600)
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of your Google Cloud Platform project
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of a condition to apply this logging.
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret key associated with the target gcs bucket on your account. You may optionally provide this secret via an environment variable, `FASTLY_GCS_SECRET_KEY`. A typical format for the key is PEM format, containing actual newline characters where required
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GCS_EMAIL`.
        """
elif False:
    ServiceVclLoggingGcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingGcArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The name of the bucket in which to store the logs
        :param pulumi.Input[_builtins.str] name: A unique name to identify this GCS endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] account_name: The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2)
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        :param pulumi.Input[_builtins.int] period: How frequently the logs should be transferred, in seconds (Default 3600)
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] project_id: The ID of your Google Cloud Platform project
        :param pulumi.Input[_builtins.str] response_condition: Name of a condition to apply this logging.
        :param pulumi.Input[_builtins.str] secret_key: The secret key associated with the target gcs bucket on your account. You may optionally provide this secret via an environment variable, `FASTLY_GCS_SECRET_KEY`. A typical format for the key is PEM format, containing actual newline characters where required
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        :param pulumi.Input[_builtins.str] user: Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GCS_EMAIL`.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the bucket in which to store the logs
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this GCS endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2)
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently the logs should be transferred, in seconds (Default 3600)
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of your Google Cloud Platform project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of a condition to apply this logging.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret key associated with the target gcs bucket on your account. You may optionally provide this secret via an environment variable, `FASTLY_GCS_SECRET_KEY`. A typical format for the key is PEM format, containing actual newline characters where required
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GCS_EMAIL`.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ServiceVclLoggingGooglepubsubArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Google Cloud Pub/Sub logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        project_id: pulumi.Input[_builtins.str]
        """
        The ID of your Google Cloud Platform project
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        Your Google Cloud Platform account secret key. The `private_key` field in your service account authentication JSON. You may optionally provide this secret via an environment variable, `FASTLY_GOOGLE_PUBSUB_SECRET_KEY`.
        """
        topic: pulumi.Input[_builtins.str]
        """
        The Google Cloud Pub/Sub topic to which logs will be published
        """
        user: pulumi.Input[_builtins.str]
        """
        Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GOOGLE_PUBSUB_EMAIL`.
        """
        account_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
elif False:
    ServiceVclLoggingGooglepubsubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingGooglepubsubArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 account_name: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Google Cloud Pub/Sub logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] project_id: The ID of your Google Cloud Platform project
        :param pulumi.Input[_builtins.str] secret_key: Your Google Cloud Platform account secret key. The `private_key` field in your service account authentication JSON. You may optionally provide this secret via an environment variable, `FASTLY_GOOGLE_PUBSUB_SECRET_KEY`.
        :param pulumi.Input[_builtins.str] topic: The Google Cloud Pub/Sub topic to which logs will be published
        :param pulumi.Input[_builtins.str] user: Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GOOGLE_PUBSUB_EMAIL`.
        :param pulumi.Input[_builtins.str] account_name: The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        :param pulumi.Input[_builtins.str] format: Apache style log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "secret_key", secret_key)
        pulumi.set(__self__, "topic", topic)
        pulumi.set(__self__, "user", user)
        if account_name is not None:
            pulumi.set(__self__, "account_name", account_name)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Google Cloud Pub/Sub logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of your Google Cloud Platform project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your Google Cloud Platform account secret key. The `private_key` field in your service account authentication JSON. You may optionally provide this secret via an environment variable, `FASTLY_GOOGLE_PUBSUB_SECRET_KEY`.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        The Google Cloud Pub/Sub topic to which logs will be published
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        Your Google Cloud Platform service account email address. The `client_email` field in your service account authentication JSON. You may optionally provide this via an environment variable, `FASTLY_GOOGLE_PUBSUB_EMAIL`.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="accountName")
    def account_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The google account name used to obtain temporary credentials (default none). You may optionally provide this via an environment variable, `FASTLY_GCS_ACCOUNT_NAME`.
        """
        return pulumi.get(self, "account_name")

    @account_name.setter
    def account_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_name", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingGrafanacloudlogArgsDict(TypedDict):
        index: pulumi.Input[_builtins.str]
        """
        The stream identifier as a JSON string
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the GrafanaCloudLogs logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The Access Policy Token key for your GrafanaCloudLogs account
        """
        url: pulumi.Input[_builtins.str]
        """
        The URL to stream logs to
        """
        user: pulumi.Input[_builtins.str]
        """
        The Grafana User ID
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply.
        """
elif False:
    ServiceVclLoggingGrafanacloudlogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingGrafanacloudlogArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] index: The stream identifier as a JSON string
        :param pulumi.Input[_builtins.str] name: The unique name of the GrafanaCloudLogs logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The Access Policy Token key for your GrafanaCloudLogs account
        :param pulumi.Input[_builtins.str] url: The URL to stream logs to
        :param pulumi.Input[_builtins.str] user: The Grafana User ID
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "user", user)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def index(self) -> pulumi.Input[_builtins.str]:
        """
        The stream identifier as a JSON string
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the GrafanaCloudLogs logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Access Policy Token key for your GrafanaCloudLogs account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL to stream logs to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The Grafana User ID
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingHerokusArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Heroku logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The token to use for authentication (https://www.heroku.com/docs/customer-token-authentication-token/)
        """
        url: pulumi.Input[_builtins.str]
        """
        The URL to stream logs to
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
elif False:
    ServiceVclLoggingHerokusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingHerokusArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Heroku logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The token to use for authentication (https://www.heroku.com/docs/customer-token-authentication-token/)
        :param pulumi.Input[_builtins.str] url: The URL to stream logs to
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Heroku logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The token to use for authentication (https://www.heroku.com/docs/customer-token-authentication-token/)
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL to stream logs to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingHoneycombArgsDict(TypedDict):
        dataset: pulumi.Input[_builtins.str]
        """
        The Honeycomb Dataset you want to log to
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Honeycomb logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The Write Key from the Account page of your Honeycomb account
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting. Your log must produce valid JSON that Honeycomb can ingest.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
elif False:
    ServiceVclLoggingHoneycombArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingHoneycombArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: The Honeycomb Dataset you want to log to
        :param pulumi.Input[_builtins.str] name: The unique name of the Honeycomb logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The Write Key from the Account page of your Honeycomb account
        :param pulumi.Input[_builtins.str] format: Apache style log formatting. Your log must produce valid JSON that Honeycomb can ingest.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> pulumi.Input[_builtins.str]:
        """
        The Honeycomb Dataset you want to log to
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Honeycomb logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Write Key from the Account page of your Honeycomb account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting. Your log must produce valid JSON that Honeycomb can ingest.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingHttpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the HTTPS logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        url: pulumi.Input[_builtins.str]
        """
        URL that log data will be sent to. Must use the https protocol
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the `Content-Type` header sent with the request
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2)
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        header_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom header sent with the request
        """
        header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the custom header sent with the request
        """
        json_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Formats log entries as JSON. Can be either disabled (`0`), array of json (`1`), or newline delimited json (`2`)
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP method used for request. Can be either `POST` or `PUT`. Default `POST`
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently, in seconds, batches of log data are sent to the HTTPS endpoint. A value of 0 sends logs at the same interval as the default, which is 5 seconds.
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        request_max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of bytes sent in one request
        """
        request_max_entries: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of logs sent in one request
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply
        """
        tls_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        tls_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        tls_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used during the TLS handshake to validate the certificate
        """
elif False:
    ServiceVclLoggingHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingHttpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 header_name: Optional[pulumi.Input[_builtins.str]] = None,
                 header_value: Optional[pulumi.Input[_builtins.str]] = None,
                 json_format: Optional[pulumi.Input[_builtins.str]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 request_max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 request_max_entries: Optional[pulumi.Input[_builtins.int]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the HTTPS logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] url: URL that log data will be sent to. Must use the https protocol
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] content_type: Value of the `Content-Type` header sent with the request
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2)
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] header_name: Custom header sent with the request
        :param pulumi.Input[_builtins.str] header_value: Value of the custom header sent with the request
        :param pulumi.Input[_builtins.str] json_format: Formats log entries as JSON. Can be either disabled (`0`), array of json (`1`), or newline delimited json (`2`)
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] method: HTTP method used for request. Can be either `POST` or `PUT`. Default `POST`
        :param pulumi.Input[_builtins.int] period: How frequently, in seconds, batches of log data are sent to the HTTPS endpoint. A value of 0 sends logs at the same interval as the default, which is 5 seconds.
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.int] request_max_bytes: The maximum number of bytes sent in one request
        :param pulumi.Input[_builtins.int] request_max_entries: The maximum number of logs sent in one request
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply
        :param pulumi.Input[_builtins.str] tls_ca_cert: A secure certificate to authenticate the server with. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_cert: The client certificate used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_key: The client private key used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_hostname: Used during the TLS handshake to validate the certificate
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if json_format is not None:
            pulumi.set(__self__, "json_format", json_format)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if request_max_bytes is not None:
            pulumi.set(__self__, "request_max_bytes", request_max_bytes)
        if request_max_entries is not None:
            pulumi.set(__self__, "request_max_entries", request_max_entries)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the HTTPS logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        URL that log data will be sent to. Must use the https protocol
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the `Content-Type` header sent with the request
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2)
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom header sent with the request
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the custom header sent with the request
        """
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_value", value)

    @_builtins.property
    @pulumi.getter(name="jsonFormat")
    def json_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Formats log entries as JSON. Can be either disabled (`0`), array of json (`1`), or newline delimited json (`2`)
        """
        return pulumi.get(self, "json_format")

    @json_format.setter
    def json_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "json_format", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP method used for request. Can be either `POST` or `PUT`. Default `POST`
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently, in seconds, batches of log data are sent to the HTTPS endpoint. A value of 0 sends logs at the same interval as the default, which is 5 seconds.
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="requestMaxBytes")
    def request_max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of bytes sent in one request
        """
        return pulumi.get(self, "request_max_bytes")

    @request_max_bytes.setter
    def request_max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_max_bytes", value)

    @_builtins.property
    @pulumi.getter(name="requestMaxEntries")
    def request_max_entries(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of logs sent in one request
        """
        return pulumi.get(self, "request_max_entries")

    @request_max_entries.setter
    def request_max_entries(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_max_entries", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        return pulumi.get(self, "tls_ca_cert")

    @tls_ca_cert.setter
    def tls_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used during the TLS handshake to validate the certificate
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)


if not MYPY:
    class ServiceVclLoggingKafkaArgsDict(TypedDict):
        brokers: pulumi.Input[_builtins.str]
        """
        A comma-separated list of IP addresses or hostnames of Kafka brokers
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Kafka logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        topic: pulumi.Input[_builtins.str]
        """
        The Kafka topic to send logs to
        """
        auth_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        SASL authentication method. One of: plain, scram-sha-256, scram-sha-512
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. One of: `gzip`, `snappy`, `lz4`
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        parse_log_keyvals: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables parsing of key=value tuples from the beginning of a logline, turning them into record headers
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        SASL Pass
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        request_max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum size of log batch, if non-zero. Defaults to 0 for unbounded
        """
        required_acks: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Number of acknowledgements a leader must receive before a write is considered successful. One of: `1` (default) One server needs to respond. `0` No servers need to respond. `-1` Wait for all in-sync replicas to respond
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        tls_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        tls_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        tls_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        """
        use_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use TLS for secure logging. Can be either `true` or `false`
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        SASL User
        """
elif False:
    ServiceVclLoggingKafkaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingKafkaArgs:
    def __init__(__self__, *,
                 brokers: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 auth_method: Optional[pulumi.Input[_builtins.str]] = None,
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 parse_log_keyvals: Optional[pulumi.Input[_builtins.bool]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 request_max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 required_acks: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 use_tls: Optional[pulumi.Input[_builtins.bool]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] brokers: A comma-separated list of IP addresses or hostnames of Kafka brokers
        :param pulumi.Input[_builtins.str] name: The unique name of the Kafka logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] topic: The Kafka topic to send logs to
        :param pulumi.Input[_builtins.str] auth_method: SASL authentication method. One of: plain, scram-sha-256, scram-sha-512
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. One of: `gzip`, `snappy`, `lz4`
        :param pulumi.Input[_builtins.str] format: Apache style log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        :param pulumi.Input[_builtins.bool] parse_log_keyvals: Enables parsing of key=value tuples from the beginning of a logline, turning them into record headers
        :param pulumi.Input[_builtins.str] password: SASL Pass
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.int] request_max_bytes: Maximum size of log batch, if non-zero. Defaults to 0 for unbounded
        :param pulumi.Input[_builtins.str] required_acks: The Number of acknowledgements a leader must receive before a write is considered successful. One of: `1` (default) One server needs to respond. `0` No servers need to respond. `-1` Wait for all in-sync replicas to respond
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        :param pulumi.Input[_builtins.str] tls_ca_cert: A secure certificate to authenticate the server with. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_cert: The client certificate used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_client_key: The client private key used to make authenticated requests. Must be in PEM format
        :param pulumi.Input[_builtins.str] tls_hostname: The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        :param pulumi.Input[_builtins.bool] use_tls: Whether to use TLS for secure logging. Can be either `true` or `false`
        :param pulumi.Input[_builtins.str] user: SASL User
        """
        pulumi.set(__self__, "brokers", brokers)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic", topic)
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if parse_log_keyvals is not None:
            pulumi.set(__self__, "parse_log_keyvals", parse_log_keyvals)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if request_max_bytes is not None:
            pulumi.set(__self__, "request_max_bytes", request_max_bytes)
        if required_acks is not None:
            pulumi.set(__self__, "required_acks", required_acks)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)
        if use_tls is not None:
            pulumi.set(__self__, "use_tls", use_tls)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def brokers(self) -> pulumi.Input[_builtins.str]:
        """
        A comma-separated list of IP addresses or hostnames of Kafka brokers
        """
        return pulumi.get(self, "brokers")

    @brokers.setter
    def brokers(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "brokers", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Kafka logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        The Kafka topic to send logs to
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SASL authentication method. One of: plain, scram-sha-256, scram-sha-512
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. One of: `gzip`, `snappy`, `lz4`
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="parseLogKeyvals")
    def parse_log_keyvals(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables parsing of key=value tuples from the beginning of a logline, turning them into record headers
        """
        return pulumi.get(self, "parse_log_keyvals")

    @parse_log_keyvals.setter
    def parse_log_keyvals(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "parse_log_keyvals", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SASL Pass
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="requestMaxBytes")
    def request_max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum size of log batch, if non-zero. Defaults to 0 for unbounded
        """
        return pulumi.get(self, "request_max_bytes")

    @request_max_bytes.setter
    def request_max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "request_max_bytes", value)

    @_builtins.property
    @pulumi.getter(name="requiredAcks")
    def required_acks(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Number of acknowledgements a leader must receive before a write is considered successful. One of: `1` (default) One server needs to respond. `0` No servers need to respond. `-1` Wait for all in-sync replicas to respond
        """
        return pulumi.get(self, "required_acks")

    @required_acks.setter
    def required_acks(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "required_acks", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A secure certificate to authenticate the server with. Must be in PEM format
        """
        return pulumi.get(self, "tls_ca_cert")

    @tls_ca_cert.setter
    def tls_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client private key used to make authenticated requests. Must be in PEM format
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)

    @_builtins.property
    @pulumi.getter(name="useTls")
    def use_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use TLS for secure logging. Can be either `true` or `false`
        """
        return pulumi.get(self, "use_tls")

    @use_tls.setter
    def use_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_tls", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SASL User
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class ServiceVclLoggingKineseArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Kinesis logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        topic: pulumi.Input[_builtins.str]
        """
        The Kinesis stream name
        """
        access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS access key to be used to write to the stream
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        iam_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) for the IAM role granting Fastly access to Kinesis. Not required if `access_key` and `secret_key` are provided.
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS region the stream resides in. (Default: `us-east-1`)
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS secret access key to authenticate with
        """
elif False:
    ServiceVclLoggingKineseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingKineseArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 iam_role: Optional[pulumi.Input[_builtins.str]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Kinesis logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] topic: The Kinesis stream name
        :param pulumi.Input[_builtins.str] access_key: The AWS access key to be used to write to the stream
        :param pulumi.Input[_builtins.str] format: Apache style log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.str] iam_role: The Amazon Resource Name (ARN) for the IAM role granting Fastly access to Kinesis. Not required if `access_key` and `secret_key` are provided.
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] region: The AWS region the stream resides in. (Default: `us-east-1`)
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        :param pulumi.Input[_builtins.str] secret_key: The AWS secret access key to authenticate with
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "topic", topic)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if iam_role is not None:
            pulumi.set(__self__, "iam_role", iam_role)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Kinesis logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        The Kinesis stream name
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS access key to be used to write to the stream
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="iamRole")
    def iam_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) for the IAM role granting Fastly access to Kinesis. Not required if `access_key` and `secret_key` are provided.
        """
        return pulumi.get(self, "iam_role")

    @iam_role.setter
    def iam_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iam_role", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS region the stream resides in. (Default: `us-east-1`)
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS secret access key to authenticate with
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class ServiceVclLoggingLogentryArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Logentries logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        Use token based authentication (https://logentries.com/doc/input-token/)
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2)
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port number configured in Logentries
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of blockAttributes condition to apply this logging.
        """
        use_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use TLS for secure logging
        """
elif False:
    ServiceVclLoggingLogentryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingLogentryArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 use_tls: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Logentries logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: Use token based authentication (https://logentries.com/doc/input-token/)
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2)
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.int] port: The port number configured in Logentries
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: Name of blockAttributes condition to apply this logging.
        :param pulumi.Input[_builtins.bool] use_tls: Whether to use TLS for secure logging
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if use_tls is not None:
            pulumi.set(__self__, "use_tls", use_tls)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Logentries logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        Use token based authentication (https://logentries.com/doc/input-token/)
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2)
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port number configured in Logentries
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of blockAttributes condition to apply this logging.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="useTls")
    def use_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use TLS for secure logging
        """
        return pulumi.get(self, "use_tls")

    @use_tls.setter
    def use_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_tls", value)


if not MYPY:
    class ServiceVclLoggingLogglyArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Loggly logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The token to use for authentication (https://www.loggly.com/docs/customer-token-authentication-token/).
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
elif False:
    ServiceVclLoggingLogglyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingLogglyArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Loggly logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The token to use for authentication (https://www.loggly.com/docs/customer-token-authentication-token/).
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Loggly logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The token to use for authentication (https://www.loggly.com/docs/customer-token-authentication-token/).
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingLogshuttleArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Log Shuttle logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The data authentication token associated with this endpoint
        """
        url: pulumi.Input[_builtins.str]
        """
        Your Log Shuttle endpoint URL
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
elif False:
    ServiceVclLoggingLogshuttleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingLogshuttleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Log Shuttle logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The data authentication token associated with this endpoint
        :param pulumi.Input[_builtins.str] url: Your Log Shuttle endpoint URL
        :param pulumi.Input[_builtins.str] format: Apache style log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Log Shuttle logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The data authentication token associated with this endpoint
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Your Log Shuttle endpoint URL
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingNewrelicArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the New Relic logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The Insert API key from the Account page of your New Relic account
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting. Your log must produce valid JSON that New Relic Logs can ingest.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region that log data will be sent to. Default: `US`
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply.
        """
elif False:
    ServiceVclLoggingNewrelicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingNewrelicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the New Relic logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The Insert API key from the Account page of your New Relic account
        :param pulumi.Input[_builtins.str] format: Apache style log formatting. Your log must produce valid JSON that New Relic Logs can ingest.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] region: The region that log data will be sent to. Default: `US`
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the New Relic logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Insert API key from the Account page of your New Relic account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting. Your log must produce valid JSON that New Relic Logs can ingest.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region that log data will be sent to. Default: `US`
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingNewrelicotlpArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the New Relic OTLP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The Insert API key from the Account page of your New Relic account
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting. Your log must produce valid JSON that New Relic OTLP can ingest.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region that log data will be sent to. Default: `US`
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The optional New Relic Trace Observer URL to stream logs to for Infinite Tracing.
        """
elif False:
    ServiceVclLoggingNewrelicotlpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingNewrelicotlpArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the New Relic OTLP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The Insert API key from the Account page of your New Relic account
        :param pulumi.Input[_builtins.str] format: Apache style log formatting. Your log must produce valid JSON that New Relic OTLP can ingest.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] region: The region that log data will be sent to. Default: `US`
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply.
        :param pulumi.Input[_builtins.str] url: The optional New Relic Trace Observer URL to stream logs to for Infinite Tracing.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the New Relic OTLP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Insert API key from the Account page of your New Relic account
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting. Your log must produce valid JSON that New Relic OTLP can ingest.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region that log data will be sent to. Default: `US`
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The optional New Relic Trace Observer URL to stream logs to for Infinite Tracing.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ServiceVclLoggingOpenstackArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        Your OpenStack account access key
        """
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of your OpenStack container
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the OpenStack logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        url: pulumi.Input[_builtins.str]
        """
        Your OpenStack auth url
        """
        user: pulumi.Input[_builtins.str]
        """
        The username for your OpenStack account
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently the logs should be transferred, in seconds. Default `3600`
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceVclLoggingOpenstackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingOpenstackArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 bucket_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: Your OpenStack account access key
        :param pulumi.Input[_builtins.str] bucket_name: The name of your OpenStack container
        :param pulumi.Input[_builtins.str] name: The unique name of the OpenStack logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] url: Your OpenStack auth url
        :param pulumi.Input[_builtins.str] user: The username for your OpenStack account
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] format: Apache style log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        :param pulumi.Input[_builtins.int] period: How frequently the logs should be transferred, in seconds. Default `3600`
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "user", user)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Your OpenStack account access key
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of your OpenStack container
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the OpenStack logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Your OpenStack auth url
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The username for your OpenStack account
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either `1` or `2`. (default: `2`).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently the logs should be transferred, in seconds. Default `3600`
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed. Can be `none` or `none`.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceVclLoggingPapertrailArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        The address of the Papertrail endpoint
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this Papertrail endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        port: pulumi.Input[_builtins.int]
        """
        The port associated with the address where the Papertrail endpoint can be accessed
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats)
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. The logging call gets placed by default in `vcl_log` if `format_version` is set to `2` and in `vcl_deliver` if `format_version` is set to `1`
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed. If not set, endpoints with `format_version` of 2 are placed in `vcl_log` and those with `format_version` of 1 are placed in `vcl_deliver`
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute
        """
elif False:
    ServiceVclLoggingPapertrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingPapertrailArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The address of the Papertrail endpoint
        :param pulumi.Input[_builtins.str] name: A unique name to identify this Papertrail endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.int] port: The port associated with the address where the Papertrail endpoint can be accessed
        :param pulumi.Input[_builtins.str] format: A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats)
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. The logging call gets placed by default in `vcl_log` if `format_version` is set to `2` and in `vcl_deliver` if `format_version` is set to `1`
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed. If not set, endpoints with `format_version` of 2 are placed in `vcl_log` and those with `format_version` of 1 are placed in `vcl_deliver`
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        The address of the Papertrail endpoint
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this Papertrail endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port associated with the address where the Papertrail endpoint can be accessed
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A Fastly [log format string](https://docs.fastly.com/en/guides/custom-log-formats)
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. The logging call gets placed by default in `vcl_log` if `format_version` is set to `2` and in `vcl_deliver` if `format_version` is set to `1`
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed. If not set, endpoints with `format_version` of 2 are placed in `vcl_log` and those with `format_version` of 1 are placed in `vcl_deliver`
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingS3ArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        The name of the bucket in which to store the logs
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the S3 logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        acl: NotRequired[pulumi.Input[_builtins.str]]
        """
        The AWS [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl) to use for objects uploaded to the S3 bucket. Options are: `private`, `public-read`, `public-read-write`, `aws-exec-read`, `authenticated-read`, `bucket-owner-read`, `bucket-owner-full-control`
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        If you created the S3 bucket outside of `us-east-1`, then specify the corresponding bucket endpoint. Example: `s3-us-west-2.amazonaws.com`
        """
        file_max_bytes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum size of an uploaded log file, if non-zero.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2).
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently the logs should be transferred, in seconds. Default `3600`
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        redundancy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The S3 storage class (redundancy level). Should be one of: `standard`, `intelligent_tiering`, `standard_ia`, `onezone_ia`, `glacier`, `glacier_ir`, `deep_archive`, or `reduced_redundancy`
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of blockAttributes condition to apply this logging.
        """
        s3_access_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS Access Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This key will be not be encrypted. Not required if `iam_role` is provided. You can provide this key via an environment variable, `FASTLY_S3_ACCESS_KEY`
        """
        s3_iam_role: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) for the IAM role granting Fastly access to S3. Not required if `access_key` and `secret_key` are provided. You can provide this value via an environment variable, `FASTLY_S3_IAM_ROLE`
        """
        s3_secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS Secret Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This secret will be not be encrypted. Not required if `iam_role` is provided. You can provide this secret via an environment variable, `FASTLY_S3_SECRET_KEY`
        """
        server_side_encryption: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specify what type of server side encryption should be used. Can be either `AES256` or `aws:kms`
        """
        server_side_encryption_kms_key_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional server-side KMS Key Id. Must be set if server_side_encryption is set to `aws:kms`
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceVclLoggingS3ArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 acl: Optional[pulumi.Input[_builtins.str]] = None,
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 file_max_bytes: Optional[pulumi.Input[_builtins.int]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 redundancy: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_access_key: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_iam_role: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 server_side_encryption: Optional[pulumi.Input[_builtins.str]] = None,
                 server_side_encryption_kms_key_id: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The name of the bucket in which to store the logs
        :param pulumi.Input[_builtins.str] name: The unique name of the S3 logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] acl: The AWS [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl) to use for objects uploaded to the S3 bucket. Options are: `private`, `public-read`, `public-read-write`, `aws-exec-read`, `authenticated-read`, `bucket-owner-read`, `bucket-owner-full-control`
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] domain: If you created the S3 bucket outside of `us-east-1`, then specify the corresponding bucket endpoint. Example: `s3-us-west-2.amazonaws.com`
        :param pulumi.Input[_builtins.int] file_max_bytes: Maximum size of an uploaded log file, if non-zero.
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2).
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] path: Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        :param pulumi.Input[_builtins.int] period: How frequently the logs should be transferred, in seconds. Default `3600`
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] redundancy: The S3 storage class (redundancy level). Should be one of: `standard`, `intelligent_tiering`, `standard_ia`, `onezone_ia`, `glacier`, `glacier_ir`, `deep_archive`, or `reduced_redundancy`
        :param pulumi.Input[_builtins.str] response_condition: Name of blockAttributes condition to apply this logging.
        :param pulumi.Input[_builtins.str] s3_access_key: AWS Access Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This key will be not be encrypted. Not required if `iam_role` is provided. You can provide this key via an environment variable, `FASTLY_S3_ACCESS_KEY`
        :param pulumi.Input[_builtins.str] s3_iam_role: The Amazon Resource Name (ARN) for the IAM role granting Fastly access to S3. Not required if `access_key` and `secret_key` are provided. You can provide this value via an environment variable, `FASTLY_S3_IAM_ROLE`
        :param pulumi.Input[_builtins.str] s3_secret_key: AWS Secret Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This secret will be not be encrypted. Not required if `iam_role` is provided. You can provide this secret via an environment variable, `FASTLY_S3_SECRET_KEY`
        :param pulumi.Input[_builtins.str] server_side_encryption: Specify what type of server side encryption should be used. Can be either `AES256` or `aws:kms`
        :param pulumi.Input[_builtins.str] server_side_encryption_kms_key_id: Optional server-side KMS Key Id. Must be set if server_side_encryption is set to `aws:kms`
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "name", name)
        if acl is not None:
            pulumi.set(__self__, "acl", acl)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if file_max_bytes is not None:
            pulumi.set(__self__, "file_max_bytes", file_max_bytes)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if redundancy is not None:
            pulumi.set(__self__, "redundancy", redundancy)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if s3_access_key is not None:
            pulumi.set(__self__, "s3_access_key", s3_access_key)
        if s3_iam_role is not None:
            pulumi.set(__self__, "s3_iam_role", s3_iam_role)
        if s3_secret_key is not None:
            pulumi.set(__self__, "s3_secret_key", s3_secret_key)
        if server_side_encryption is not None:
            pulumi.set(__self__, "server_side_encryption", server_side_encryption)
        if server_side_encryption_kms_key_id is not None:
            pulumi.set(__self__, "server_side_encryption_kms_key_id", server_side_encryption_kms_key_id)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the bucket in which to store the logs
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the S3 logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def acl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The AWS [Canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/userguide/acl-overview.html#canned-acl) to use for objects uploaded to the S3 bucket. Options are: `private`, `public-read`, `public-read-write`, `aws-exec-read`, `authenticated-read`, `bucket-owner-read`, `bucket-owner-full-control`
        """
        return pulumi.get(self, "acl")

    @acl.setter
    def acl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acl", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If you created the S3 bucket outside of `us-east-1`, then specify the corresponding bucket endpoint. Example: `s3-us-west-2.amazonaws.com`
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter(name="fileMaxBytes")
    def file_max_bytes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum size of an uploaded log file, if non-zero.
        """
        return pulumi.get(self, "file_max_bytes")

    @file_max_bytes.setter
    def file_max_bytes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "file_max_bytes", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to store the files. Must end with a trailing slash. If this field is left empty, the files will be saved in the bucket's root path
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently the logs should be transferred, in seconds. Default `3600`
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter
    def redundancy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The S3 storage class (redundancy level). Should be one of: `standard`, `intelligent_tiering`, `standard_ia`, `onezone_ia`, `glacier`, `glacier_ir`, `deep_archive`, or `reduced_redundancy`
        """
        return pulumi.get(self, "redundancy")

    @redundancy.setter
    def redundancy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "redundancy", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of blockAttributes condition to apply this logging.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="s3AccessKey")
    def s3_access_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS Access Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This key will be not be encrypted. Not required if `iam_role` is provided. You can provide this key via an environment variable, `FASTLY_S3_ACCESS_KEY`
        """
        return pulumi.get(self, "s3_access_key")

    @s3_access_key.setter
    def s3_access_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_access_key", value)

    @_builtins.property
    @pulumi.getter(name="s3IamRole")
    def s3_iam_role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) for the IAM role granting Fastly access to S3. Not required if `access_key` and `secret_key` are provided. You can provide this value via an environment variable, `FASTLY_S3_IAM_ROLE`
        """
        return pulumi.get(self, "s3_iam_role")

    @s3_iam_role.setter
    def s3_iam_role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_iam_role", value)

    @_builtins.property
    @pulumi.getter(name="s3SecretKey")
    def s3_secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS Secret Key of an account with the required permissions to post logs. It is **strongly** recommended you create a separate IAM user with permissions to only operate on this Bucket. This secret will be not be encrypted. Not required if `iam_role` is provided. You can provide this secret via an environment variable, `FASTLY_S3_SECRET_KEY`
        """
        return pulumi.get(self, "s3_secret_key")

    @s3_secret_key.setter
    def s3_secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "s3_secret_key", value)

    @_builtins.property
    @pulumi.getter(name="serverSideEncryption")
    def server_side_encryption(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify what type of server side encryption should be used. Can be either `AES256` or `aws:kms`
        """
        return pulumi.get(self, "server_side_encryption")

    @server_side_encryption.setter
    def server_side_encryption(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_side_encryption", value)

    @_builtins.property
    @pulumi.getter(name="serverSideEncryptionKmsKeyId")
    def server_side_encryption_kms_key_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional server-side KMS Key Id. Must be set if server_side_encryption is set to `aws:kms`
        """
        return pulumi.get(self, "server_side_encryption_kms_key_id")

    @server_side_encryption_kms_key_id.setter
    def server_side_encryption_kms_key_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_side_encryption_kms_key_id", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceVclLoggingScalyrArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the Scalyr logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The token to use for authentication (https://www.scalyr.com/keys)
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache style log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the logfile field sent to Scalyr
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region that log data will be sent to. One of `US` or `EU`. Defaults to `US` if undefined
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
elif False:
    ServiceVclLoggingScalyrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingScalyrArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The unique name of the Scalyr logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The token to use for authentication (https://www.scalyr.com/keys)
        :param pulumi.Input[_builtins.str] format: Apache style log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] project_id: The name of the logfile field sent to Scalyr
        :param pulumi.Input[_builtins.str] region: The region that log data will be sent to. One of `US` or `EU`. Defaults to `US` if undefined
        :param pulumi.Input[_builtins.str] response_condition: The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the Scalyr logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The token to use for authentication (https://www.scalyr.com/keys)
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache style log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the logfile field sent to Scalyr
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region that log data will be sent to. One of `US` or `EU`. Defaults to `US` if undefined
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an existing condition in the configured endpoint, or leave blank to always execute.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingSftpArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        The SFTP address to stream logs to
        """
        name: pulumi.Input[_builtins.str]
        """
        The unique name of the SFTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        path: pulumi.Input[_builtins.str]
        """
        The path to upload log files to. If the path ends in `/` then it is treated as a directory
        """
        ssh_known_hosts: pulumi.Input[_builtins.str]
        """
        A list of host keys for all hosts we can connect to over SFTP
        """
        user: pulumi.Input[_builtins.str]
        """
        The username for the server
        """
        compression_codec: NotRequired[pulumi.Input[_builtins.str]]
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        gzip_level: NotRequired[pulumi.Input[_builtins.int]]
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        """
        period: NotRequired[pulumi.Input[_builtins.int]]
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port the SFTP service listens on. (Default: `22`)
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply.
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSH private key for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        """
        timestamp_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
elif False:
    ServiceVclLoggingSftpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingSftpArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 ssh_known_hosts: pulumi.Input[_builtins.str],
                 user: pulumi.Input[_builtins.str],
                 compression_codec: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 gzip_level: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 period: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 timestamp_format: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] address: The SFTP address to stream logs to
        :param pulumi.Input[_builtins.str] name: The unique name of the SFTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] path: The path to upload log files to. If the path ends in `/` then it is treated as a directory
        :param pulumi.Input[_builtins.str] ssh_known_hosts: A list of host keys for all hosts we can connect to over SFTP
        :param pulumi.Input[_builtins.str] user: The username for the server
        :param pulumi.Input[_builtins.str] compression_codec: The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting.
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        :param pulumi.Input[_builtins.int] gzip_level: Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] password: The password for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        :param pulumi.Input[_builtins.int] period: How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.int] port: The port the SFTP service listens on. (Default: `22`)
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] public_key: A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply.
        :param pulumi.Input[_builtins.str] secret_key: The SSH private key for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        :param pulumi.Input[_builtins.str] timestamp_format: The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "ssh_known_hosts", ssh_known_hosts)
        pulumi.set(__self__, "user", user)
        if compression_codec is not None:
            pulumi.set(__self__, "compression_codec", compression_codec)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if gzip_level is not None:
            pulumi.set(__self__, "gzip_level", gzip_level)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if timestamp_format is not None:
            pulumi.set(__self__, "timestamp_format", timestamp_format)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        The SFTP address to stream logs to
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The unique name of the SFTP logging endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        The path to upload log files to. If the path ends in `/` then it is treated as a directory
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="sshKnownHosts")
    def ssh_known_hosts(self) -> pulumi.Input[_builtins.str]:
        """
        A list of host keys for all hosts we can connect to over SFTP
        """
        return pulumi.get(self, "ssh_known_hosts")

    @ssh_known_hosts.setter
    def ssh_known_hosts(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ssh_known_hosts", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> pulumi.Input[_builtins.str]:
        """
        The username for the server
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "user", value)

    @_builtins.property
    @pulumi.getter(name="compressionCodec")
    def compression_codec(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The codec used for compression of your logs. Valid values are zstd, snappy, and gzip. If the specified codec is "gzip", gzip_level will default to 3. To specify a different level, leave compression_codec blank and explicitly set the level using gzip_level. Specifying both compression_codec and gzip_level in the same API request will result in an error.
        """
        return pulumi.get(self, "compression_codec")

    @compression_codec.setter
    def compression_codec(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_codec", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2).
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="gzipLevel")
    def gzip_level(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Level of Gzip compression from `0-9`. `0` means no compression. `1` is the fastest and the least compressed version, `9` is the slowest and the most compressed version. Default `0`
        """
        return pulumi.get(self, "gzip_level")

    @gzip_level.setter
    def gzip_level(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "gzip_level", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How frequently log files are finalized so they can be available for reading (in seconds, default `3600`)
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port the SFTP service listens on. (Default: `22`)
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A PGP public key that Fastly will use to encrypt your log files before writing them to disk
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSH private key for the server. If both `password` and `secret_key` are passed, `secret_key` will be preferred
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="timestampFormat")
    def timestamp_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `strftime` specified timestamp formatting (default `%Y-%m-%dT%H:%M:%S.000`)
        """
        return pulumi.get(self, "timestamp_format")

    @timestamp_format.setter
    def timestamp_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "timestamp_format", value)


if not MYPY:
    class ServiceVclLoggingSplunkArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify the Splunk endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        token: pulumi.Input[_builtins.str]
        """
        The Splunk token to be used for authentication
        """
        url: pulumi.Input[_builtins.str]
        """
        The Splunk URL to stream logs to
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting (default: `%h %l %u %t "%r" %>s %b`)
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2)
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the condition to apply
        """
        tls_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SPLUNK_CA_CERT`
        """
        tls_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate used to make authenticated requests. Must be in PEM format.
        """
        tls_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client private key used to make authenticated requests. Must be in PEM format.
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        """
        use_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use TLS for secure logging. Default: `false`
        """
elif False:
    ServiceVclLoggingSplunkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingSplunkArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 token: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 use_tls: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A unique name to identify the Splunk endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] token: The Splunk token to be used for authentication
        :param pulumi.Input[_builtins.str] url: The Splunk URL to stream logs to
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting (default: `%h %l %u %t "%r" %>s %b`)
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2)
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: The name of the condition to apply
        :param pulumi.Input[_builtins.str] tls_ca_cert: A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SPLUNK_CA_CERT`
        :param pulumi.Input[_builtins.str] tls_client_cert: The client certificate used to make authenticated requests. Must be in PEM format.
        :param pulumi.Input[_builtins.str] tls_client_key: The client private key used to make authenticated requests. Must be in PEM format.
        :param pulumi.Input[_builtins.str] tls_hostname: The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        :param pulumi.Input[_builtins.bool] use_tls: Whether to use TLS for secure logging. Default: `false`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "token", token)
        pulumi.set(__self__, "url", url)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)
        if use_tls is not None:
            pulumi.set(__self__, "use_tls", use_tls)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify the Splunk endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        The Splunk token to be used for authentication
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The Splunk URL to stream logs to
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting (default: `%h %l %u %t "%r" %>s %b`)
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (default: 2)
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the condition to apply
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SPLUNK_CA_CERT`
        """
        return pulumi.get(self, "tls_ca_cert")

    @tls_ca_cert.setter
    def tls_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate used to make authenticated requests. Must be in PEM format.
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client private key used to make authenticated requests. Must be in PEM format.
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The hostname used to verify the server's certificate. It can either be the Common Name or a Subject Alternative Name (SAN)
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)

    @_builtins.property
    @pulumi.getter(name="useTls")
    def use_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use TLS for secure logging. Default: `false`
        """
        return pulumi.get(self, "use_tls")

    @use_tls.setter
    def use_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_tls", value)


if not MYPY:
    class ServiceVclLoggingSumologicArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this Sumologic endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        url: pulumi.Input[_builtins.str]
        """
        The URL to Sumologic collector endpoint
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2)
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of blockAttributes condition to apply this logging.
        """
elif False:
    ServiceVclLoggingSumologicArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingSumologicArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A unique name to identify this Sumologic endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] url: The URL to Sumologic collector endpoint
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2)
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: Name of blockAttributes condition to apply this logging.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this Sumologic endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL to Sumologic collector endpoint
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format used for the configured endpoint. Can be either 1 or 2. (Default: 2)
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of blockAttributes condition to apply this logging.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)


if not MYPY:
    class ServiceVclLoggingSyslogArgsDict(TypedDict):
        address: pulumi.Input[_builtins.str]
        """
        A hostname or IPv4 address of the Syslog endpoint
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this Syslog endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Apache-style string or VCL variables to use for log formatting
        """
        format_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        The version of the custom logging format. Can be either 1 or 2. (Default: 2)
        """
        message_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        placement: NotRequired[pulumi.Input[_builtins.str]]
        """
        Where in the generated VCL the logging call should be placed.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port associated with the address where the Syslog endpoint can be accessed. Default `514`
        """
        processing_region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        response_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of blockAttributes condition to apply this logging.
        """
        tls_ca_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CA_CERT`
        """
        tls_client_cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client certificate used to make authenticated requests. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CLIENT_CERT`
        """
        tls_client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client private key used to make authenticated requests. Must be in PEM format. You can provide this key via an environment variable, `FASTLY_SYSLOG_CLIENT_KEY`
        """
        tls_hostname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used during the TLS handshake to validate the certificate
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether to prepend each message with a specific token
        """
        use_tls: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use TLS for secure logging. Default `false`
        """
elif False:
    ServiceVclLoggingSyslogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclLoggingSyslogArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 format_version: Optional[pulumi.Input[_builtins.int]] = None,
                 message_type: Optional[pulumi.Input[_builtins.str]] = None,
                 placement: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 processing_region: Optional[pulumi.Input[_builtins.str]] = None,
                 response_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_ca_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_cert: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_hostname: Optional[pulumi.Input[_builtins.str]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None,
                 use_tls: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] address: A hostname or IPv4 address of the Syslog endpoint
        :param pulumi.Input[_builtins.str] name: A unique name to identify this Syslog endpoint. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] format: Apache-style string or VCL variables to use for log formatting
        :param pulumi.Input[_builtins.int] format_version: The version of the custom logging format. Can be either 1 or 2. (Default: 2)
        :param pulumi.Input[_builtins.str] message_type: How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        :param pulumi.Input[_builtins.str] placement: Where in the generated VCL the logging call should be placed.
        :param pulumi.Input[_builtins.int] port: The port associated with the address where the Syslog endpoint can be accessed. Default `514`
        :param pulumi.Input[_builtins.str] processing_region: Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        :param pulumi.Input[_builtins.str] response_condition: Name of blockAttributes condition to apply this logging.
        :param pulumi.Input[_builtins.str] tls_ca_cert: A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CA_CERT`
        :param pulumi.Input[_builtins.str] tls_client_cert: The client certificate used to make authenticated requests. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CLIENT_CERT`
        :param pulumi.Input[_builtins.str] tls_client_key: The client private key used to make authenticated requests. Must be in PEM format. You can provide this key via an environment variable, `FASTLY_SYSLOG_CLIENT_KEY`
        :param pulumi.Input[_builtins.str] tls_hostname: Used during the TLS handshake to validate the certificate
        :param pulumi.Input[_builtins.str] token: Whether to prepend each message with a specific token
        :param pulumi.Input[_builtins.bool] use_tls: Whether to use TLS for secure logging. Default `false`
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "name", name)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_version is not None:
            pulumi.set(__self__, "format_version", format_version)
        if message_type is not None:
            pulumi.set(__self__, "message_type", message_type)
        if placement is not None:
            pulumi.set(__self__, "placement", placement)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if processing_region is not None:
            pulumi.set(__self__, "processing_region", processing_region)
        if response_condition is not None:
            pulumi.set(__self__, "response_condition", response_condition)
        if tls_ca_cert is not None:
            pulumi.set(__self__, "tls_ca_cert", tls_ca_cert)
        if tls_client_cert is not None:
            pulumi.set(__self__, "tls_client_cert", tls_client_cert)
        if tls_client_key is not None:
            pulumi.set(__self__, "tls_client_key", tls_client_key)
        if tls_hostname is not None:
            pulumi.set(__self__, "tls_hostname", tls_hostname)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if use_tls is not None:
            pulumi.set(__self__, "use_tls", use_tls)

    @_builtins.property
    @pulumi.getter
    def address(self) -> pulumi.Input[_builtins.str]:
        """
        A hostname or IPv4 address of the Syslog endpoint
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this Syslog endpoint. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Apache-style string or VCL variables to use for log formatting
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="formatVersion")
    def format_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The version of the custom logging format. Can be either 1 or 2. (Default: 2)
        """
        return pulumi.get(self, "format_version")

    @format_version.setter
    def format_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "format_version", value)

    @_builtins.property
    @pulumi.getter(name="messageType")
    def message_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        How the message should be formatted. Can be either `classic`, `loggly`, `logplex` or `blank`. Default is `classic`
        """
        return pulumi.get(self, "message_type")

    @message_type.setter
    def message_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_type", value)

    @_builtins.property
    @pulumi.getter
    def placement(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Where in the generated VCL the logging call should be placed.
        """
        return pulumi.get(self, "placement")

    @placement.setter
    def placement(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "placement", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port associated with the address where the Syslog endpoint can be accessed. Default `514`
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="processingRegion")
    def processing_region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region where logs will be processed before streaming to BigQuery. Valid values are 'none', 'us' and 'eu'.
        """
        return pulumi.get(self, "processing_region")

    @processing_region.setter
    def processing_region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "processing_region", value)

    @_builtins.property
    @pulumi.getter(name="responseCondition")
    def response_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of blockAttributes condition to apply this logging.
        """
        return pulumi.get(self, "response_condition")

    @response_condition.setter
    def response_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_condition", value)

    @_builtins.property
    @pulumi.getter(name="tlsCaCert")
    def tls_ca_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A secure certificate to authenticate the server with. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CA_CERT`
        """
        return pulumi.get(self, "tls_ca_cert")

    @tls_ca_cert.setter
    def tls_ca_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_ca_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientCert")
    def tls_client_cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client certificate used to make authenticated requests. Must be in PEM format. You can provide this certificate via an environment variable, `FASTLY_SYSLOG_CLIENT_CERT`
        """
        return pulumi.get(self, "tls_client_cert")

    @tls_client_cert.setter
    def tls_client_cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_cert", value)

    @_builtins.property
    @pulumi.getter(name="tlsClientKey")
    def tls_client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client private key used to make authenticated requests. Must be in PEM format. You can provide this key via an environment variable, `FASTLY_SYSLOG_CLIENT_KEY`
        """
        return pulumi.get(self, "tls_client_key")

    @tls_client_key.setter
    def tls_client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_client_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsHostname")
    def tls_hostname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used during the TLS handshake to validate the certificate
        """
        return pulumi.get(self, "tls_hostname")

    @tls_hostname.setter
    def tls_hostname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_hostname", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether to prepend each message with a specific token
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)

    @_builtins.property
    @pulumi.getter(name="useTls")
    def use_tls(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use TLS for secure logging. Default `false`
        """
        return pulumi.get(self, "use_tls")

    @use_tls.setter
    def use_tls(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_tls", value)


if not MYPY:
    class ServiceVclProductEnablementArgsDict(TypedDict):
        api_discovery: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable API Discovery support
        """
        bot_management: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Bot Management support
        """
        brotli_compression: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Brotli Compression support
        """
        ddos_protection: NotRequired[pulumi.Input['ServiceVclProductEnablementDdosProtectionArgsDict']]
        """
        DDoS Protection product
        """
        domain_inspector: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Domain Inspector support
        """
        image_optimizer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Image Optimizer support (all backends must have a `shield` attribute)
        """
        log_explorer_insights: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Log Explorer & Insights
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used by the provider to identify modified settings (changing this value will force the entire block to be deleted, then recreated)
        """
        ngwaf: NotRequired[pulumi.Input['ServiceVclProductEnablementNgwafArgsDict']]
        """
        Next-Gen WAF product
        """
        origin_inspector: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable Origin Inspector support
        """
        websockets: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable WebSockets support
        """
elif False:
    ServiceVclProductEnablementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclProductEnablementArgs:
    def __init__(__self__, *,
                 api_discovery: Optional[pulumi.Input[_builtins.bool]] = None,
                 bot_management: Optional[pulumi.Input[_builtins.bool]] = None,
                 brotli_compression: Optional[pulumi.Input[_builtins.bool]] = None,
                 ddos_protection: Optional[pulumi.Input['ServiceVclProductEnablementDdosProtectionArgs']] = None,
                 domain_inspector: Optional[pulumi.Input[_builtins.bool]] = None,
                 image_optimizer: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_explorer_insights: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 ngwaf: Optional[pulumi.Input['ServiceVclProductEnablementNgwafArgs']] = None,
                 origin_inspector: Optional[pulumi.Input[_builtins.bool]] = None,
                 websockets: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] api_discovery: Enable API Discovery support
        :param pulumi.Input[_builtins.bool] bot_management: Enable Bot Management support
        :param pulumi.Input[_builtins.bool] brotli_compression: Enable Brotli Compression support
        :param pulumi.Input['ServiceVclProductEnablementDdosProtectionArgs'] ddos_protection: DDoS Protection product
        :param pulumi.Input[_builtins.bool] domain_inspector: Enable Domain Inspector support
        :param pulumi.Input[_builtins.bool] image_optimizer: Enable Image Optimizer support (all backends must have a `shield` attribute)
        :param pulumi.Input[_builtins.bool] log_explorer_insights: Enable Log Explorer & Insights
        :param pulumi.Input[_builtins.str] name: Used by the provider to identify modified settings (changing this value will force the entire block to be deleted, then recreated)
        :param pulumi.Input['ServiceVclProductEnablementNgwafArgs'] ngwaf: Next-Gen WAF product
        :param pulumi.Input[_builtins.bool] origin_inspector: Enable Origin Inspector support
        :param pulumi.Input[_builtins.bool] websockets: Enable WebSockets support
        """
        if api_discovery is not None:
            pulumi.set(__self__, "api_discovery", api_discovery)
        if bot_management is not None:
            pulumi.set(__self__, "bot_management", bot_management)
        if brotli_compression is not None:
            pulumi.set(__self__, "brotli_compression", brotli_compression)
        if ddos_protection is not None:
            pulumi.set(__self__, "ddos_protection", ddos_protection)
        if domain_inspector is not None:
            pulumi.set(__self__, "domain_inspector", domain_inspector)
        if image_optimizer is not None:
            pulumi.set(__self__, "image_optimizer", image_optimizer)
        if log_explorer_insights is not None:
            pulumi.set(__self__, "log_explorer_insights", log_explorer_insights)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ngwaf is not None:
            pulumi.set(__self__, "ngwaf", ngwaf)
        if origin_inspector is not None:
            pulumi.set(__self__, "origin_inspector", origin_inspector)
        if websockets is not None:
            pulumi.set(__self__, "websockets", websockets)

    @_builtins.property
    @pulumi.getter(name="apiDiscovery")
    def api_discovery(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable API Discovery support
        """
        return pulumi.get(self, "api_discovery")

    @api_discovery.setter
    def api_discovery(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "api_discovery", value)

    @_builtins.property
    @pulumi.getter(name="botManagement")
    def bot_management(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Bot Management support
        """
        return pulumi.get(self, "bot_management")

    @bot_management.setter
    def bot_management(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bot_management", value)

    @_builtins.property
    @pulumi.getter(name="brotliCompression")
    def brotli_compression(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Brotli Compression support
        """
        return pulumi.get(self, "brotli_compression")

    @brotli_compression.setter
    def brotli_compression(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "brotli_compression", value)

    @_builtins.property
    @pulumi.getter(name="ddosProtection")
    def ddos_protection(self) -> Optional[pulumi.Input['ServiceVclProductEnablementDdosProtectionArgs']]:
        """
        DDoS Protection product
        """
        return pulumi.get(self, "ddos_protection")

    @ddos_protection.setter
    def ddos_protection(self, value: Optional[pulumi.Input['ServiceVclProductEnablementDdosProtectionArgs']]):
        pulumi.set(self, "ddos_protection", value)

    @_builtins.property
    @pulumi.getter(name="domainInspector")
    def domain_inspector(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Domain Inspector support
        """
        return pulumi.get(self, "domain_inspector")

    @domain_inspector.setter
    def domain_inspector(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "domain_inspector", value)

    @_builtins.property
    @pulumi.getter(name="imageOptimizer")
    def image_optimizer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Image Optimizer support (all backends must have a `shield` attribute)
        """
        return pulumi.get(self, "image_optimizer")

    @image_optimizer.setter
    def image_optimizer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "image_optimizer", value)

    @_builtins.property
    @pulumi.getter(name="logExplorerInsights")
    def log_explorer_insights(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Log Explorer & Insights
        """
        return pulumi.get(self, "log_explorer_insights")

    @log_explorer_insights.setter
    def log_explorer_insights(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "log_explorer_insights", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used by the provider to identify modified settings (changing this value will force the entire block to be deleted, then recreated)
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def ngwaf(self) -> Optional[pulumi.Input['ServiceVclProductEnablementNgwafArgs']]:
        """
        Next-Gen WAF product
        """
        return pulumi.get(self, "ngwaf")

    @ngwaf.setter
    def ngwaf(self, value: Optional[pulumi.Input['ServiceVclProductEnablementNgwafArgs']]):
        pulumi.set(self, "ngwaf", value)

    @_builtins.property
    @pulumi.getter(name="originInspector")
    def origin_inspector(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable Origin Inspector support
        """
        return pulumi.get(self, "origin_inspector")

    @origin_inspector.setter
    def origin_inspector(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "origin_inspector", value)

    @_builtins.property
    @pulumi.getter
    def websockets(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable WebSockets support
        """
        return pulumi.get(self, "websockets")

    @websockets.setter
    def websockets(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "websockets", value)


if not MYPY:
    class ServiceVclProductEnablementDdosProtectionArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enable DDoS Protection support
        """
        mode: pulumi.Input[_builtins.str]
        """
        Operation mode. Can be either `off`, `log`, or `block`.
        """
elif False:
    ServiceVclProductEnablementDdosProtectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclProductEnablementDdosProtectionArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 mode: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable DDoS Protection support
        :param pulumi.Input[_builtins.str] mode: Operation mode. Can be either `off`, `log`, or `block`.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable DDoS Protection support
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        Operation mode. Can be either `off`, `log`, or `block`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)


if not MYPY:
    class ServiceVclProductEnablementNgwafArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enable Next-Gen WAF support
        """
        workspace_id: pulumi.Input[_builtins.str]
        """
        The workspace to link
        """
        traffic_ramp: NotRequired[pulumi.Input[_builtins.int]]
        """
        The percentage of traffic to inspect
        """
elif False:
    ServiceVclProductEnablementNgwafArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclProductEnablementNgwafArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 workspace_id: pulumi.Input[_builtins.str],
                 traffic_ramp: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable Next-Gen WAF support
        :param pulumi.Input[_builtins.str] workspace_id: The workspace to link
        :param pulumi.Input[_builtins.int] traffic_ramp: The percentage of traffic to inspect
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "workspace_id", workspace_id)
        if traffic_ramp is not None:
            pulumi.set(__self__, "traffic_ramp", traffic_ramp)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable Next-Gen WAF support
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="workspaceId")
    def workspace_id(self) -> pulumi.Input[_builtins.str]:
        """
        The workspace to link
        """
        return pulumi.get(self, "workspace_id")

    @workspace_id.setter
    def workspace_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "workspace_id", value)

    @_builtins.property
    @pulumi.getter(name="trafficRamp")
    def traffic_ramp(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The percentage of traffic to inspect
        """
        return pulumi.get(self, "traffic_ramp")

    @traffic_ramp.setter
    def traffic_ramp(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "traffic_ramp", value)


if not MYPY:
    class ServiceVclRateLimiterArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        The action to take when a rate limiter violation is detected (one of: log_only, response, response_object)
        """
        client_key: pulumi.Input[_builtins.str]
        """
        Comma-separated list of VCL variables used to generate a counter key to identify a client
        """
        http_methods: pulumi.Input[_builtins.str]
        """
        Comma-separated list of HTTP methods to apply rate limiting to
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique human readable name for the rate limiting rule
        """
        penalty_box_duration: pulumi.Input[_builtins.int]
        """
        Length of time in minutes that the rate limiter is in effect after the initial violation is detected
        """
        rps_limit: pulumi.Input[_builtins.int]
        """
        Upper limit of requests per second allowed by the rate limiter
        """
        window_size: pulumi.Input[_builtins.int]
        """
        Number of seconds during which the RPS limit must be exceeded in order to trigger a violation (one of: 1, 10, 60)
        """
        feature_revision: NotRequired[pulumi.Input[_builtins.int]]
        """
        Revision number of the rate limiting feature implementation
        """
        logger_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the type of logging endpoint to be used when action is log_only (one of: azureblob, bigquery, cloudfiles, datadog, digitalocean, elasticsearch, ftp, gcs, googleanalytics, heroku, honeycomb, http, https, kafka, kinesis, logentries, loggly, logshuttle, newrelic, openstack, papertrail, pubsub, s3, scalyr, sftp, splunk, stackdriver, sumologic, syslog)
        """
        ratelimiter_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Alphanumeric string identifying the rate limiter
        """
        response: NotRequired[pulumi.Input['ServiceVclRateLimiterResponseArgsDict']]
        """
        Custom response to be sent when the rate limit is exceeded. Required if action is response
        """
        response_object_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of existing response object. Required if action is response_object
        """
        uri_dictionary_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of an Edge Dictionary containing URIs as keys. If not defined or null, all origin URIs will be rate limited
        """
elif False:
    ServiceVclRateLimiterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclRateLimiterArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 client_key: pulumi.Input[_builtins.str],
                 http_methods: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 penalty_box_duration: pulumi.Input[_builtins.int],
                 rps_limit: pulumi.Input[_builtins.int],
                 window_size: pulumi.Input[_builtins.int],
                 feature_revision: Optional[pulumi.Input[_builtins.int]] = None,
                 logger_type: Optional[pulumi.Input[_builtins.str]] = None,
                 ratelimiter_id: Optional[pulumi.Input[_builtins.str]] = None,
                 response: Optional[pulumi.Input['ServiceVclRateLimiterResponseArgs']] = None,
                 response_object_name: Optional[pulumi.Input[_builtins.str]] = None,
                 uri_dictionary_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: The action to take when a rate limiter violation is detected (one of: log_only, response, response_object)
        :param pulumi.Input[_builtins.str] client_key: Comma-separated list of VCL variables used to generate a counter key to identify a client
        :param pulumi.Input[_builtins.str] http_methods: Comma-separated list of HTTP methods to apply rate limiting to
        :param pulumi.Input[_builtins.str] name: A unique human readable name for the rate limiting rule
        :param pulumi.Input[_builtins.int] penalty_box_duration: Length of time in minutes that the rate limiter is in effect after the initial violation is detected
        :param pulumi.Input[_builtins.int] rps_limit: Upper limit of requests per second allowed by the rate limiter
        :param pulumi.Input[_builtins.int] window_size: Number of seconds during which the RPS limit must be exceeded in order to trigger a violation (one of: 1, 10, 60)
        :param pulumi.Input[_builtins.int] feature_revision: Revision number of the rate limiting feature implementation
        :param pulumi.Input[_builtins.str] logger_type: Name of the type of logging endpoint to be used when action is log_only (one of: azureblob, bigquery, cloudfiles, datadog, digitalocean, elasticsearch, ftp, gcs, googleanalytics, heroku, honeycomb, http, https, kafka, kinesis, logentries, loggly, logshuttle, newrelic, openstack, papertrail, pubsub, s3, scalyr, sftp, splunk, stackdriver, sumologic, syslog)
        :param pulumi.Input[_builtins.str] ratelimiter_id: Alphanumeric string identifying the rate limiter
        :param pulumi.Input['ServiceVclRateLimiterResponseArgs'] response: Custom response to be sent when the rate limit is exceeded. Required if action is response
        :param pulumi.Input[_builtins.str] response_object_name: Name of existing response object. Required if action is response_object
        :param pulumi.Input[_builtins.str] uri_dictionary_name: The name of an Edge Dictionary containing URIs as keys. If not defined or null, all origin URIs will be rate limited
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "client_key", client_key)
        pulumi.set(__self__, "http_methods", http_methods)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "penalty_box_duration", penalty_box_duration)
        pulumi.set(__self__, "rps_limit", rps_limit)
        pulumi.set(__self__, "window_size", window_size)
        if feature_revision is not None:
            pulumi.set(__self__, "feature_revision", feature_revision)
        if logger_type is not None:
            pulumi.set(__self__, "logger_type", logger_type)
        if ratelimiter_id is not None:
            pulumi.set(__self__, "ratelimiter_id", ratelimiter_id)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if response_object_name is not None:
            pulumi.set(__self__, "response_object_name", response_object_name)
        if uri_dictionary_name is not None:
            pulumi.set(__self__, "uri_dictionary_name", uri_dictionary_name)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        The action to take when a rate limiter violation is detected (one of: log_only, response, response_object)
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> pulumi.Input[_builtins.str]:
        """
        Comma-separated list of VCL variables used to generate a counter key to identify a client
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> pulumi.Input[_builtins.str]:
        """
        Comma-separated list of HTTP methods to apply rate limiting to
        """
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "http_methods", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique human readable name for the rate limiting rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="penaltyBoxDuration")
    def penalty_box_duration(self) -> pulumi.Input[_builtins.int]:
        """
        Length of time in minutes that the rate limiter is in effect after the initial violation is detected
        """
        return pulumi.get(self, "penalty_box_duration")

    @penalty_box_duration.setter
    def penalty_box_duration(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "penalty_box_duration", value)

    @_builtins.property
    @pulumi.getter(name="rpsLimit")
    def rps_limit(self) -> pulumi.Input[_builtins.int]:
        """
        Upper limit of requests per second allowed by the rate limiter
        """
        return pulumi.get(self, "rps_limit")

    @rps_limit.setter
    def rps_limit(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rps_limit", value)

    @_builtins.property
    @pulumi.getter(name="windowSize")
    def window_size(self) -> pulumi.Input[_builtins.int]:
        """
        Number of seconds during which the RPS limit must be exceeded in order to trigger a violation (one of: 1, 10, 60)
        """
        return pulumi.get(self, "window_size")

    @window_size.setter
    def window_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "window_size", value)

    @_builtins.property
    @pulumi.getter(name="featureRevision")
    def feature_revision(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Revision number of the rate limiting feature implementation
        """
        return pulumi.get(self, "feature_revision")

    @feature_revision.setter
    def feature_revision(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "feature_revision", value)

    @_builtins.property
    @pulumi.getter(name="loggerType")
    def logger_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the type of logging endpoint to be used when action is log_only (one of: azureblob, bigquery, cloudfiles, datadog, digitalocean, elasticsearch, ftp, gcs, googleanalytics, heroku, honeycomb, http, https, kafka, kinesis, logentries, loggly, logshuttle, newrelic, openstack, papertrail, pubsub, s3, scalyr, sftp, splunk, stackdriver, sumologic, syslog)
        """
        return pulumi.get(self, "logger_type")

    @logger_type.setter
    def logger_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logger_type", value)

    @_builtins.property
    @pulumi.getter(name="ratelimiterId")
    def ratelimiter_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Alphanumeric string identifying the rate limiter
        """
        return pulumi.get(self, "ratelimiter_id")

    @ratelimiter_id.setter
    def ratelimiter_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ratelimiter_id", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['ServiceVclRateLimiterResponseArgs']]:
        """
        Custom response to be sent when the rate limit is exceeded. Required if action is response
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['ServiceVclRateLimiterResponseArgs']]):
        pulumi.set(self, "response", value)

    @_builtins.property
    @pulumi.getter(name="responseObjectName")
    def response_object_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of existing response object. Required if action is response_object
        """
        return pulumi.get(self, "response_object_name")

    @response_object_name.setter
    def response_object_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response_object_name", value)

    @_builtins.property
    @pulumi.getter(name="uriDictionaryName")
    def uri_dictionary_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of an Edge Dictionary containing URIs as keys. If not defined or null, all origin URIs will be rate limited
        """
        return pulumi.get(self, "uri_dictionary_name")

    @uri_dictionary_name.setter
    def uri_dictionary_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri_dictionary_name", value)


if not MYPY:
    class ServiceVclRateLimiterResponseArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        HTTP response body data
        """
        content_type: pulumi.Input[_builtins.str]
        """
        HTTP Content-Type (e.g. application/json)
        """
        status: pulumi.Input[_builtins.int]
        """
        HTTP response status code (e.g. 429)
        """
elif False:
    ServiceVclRateLimiterResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclRateLimiterResponseArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 content_type: pulumi.Input[_builtins.str],
                 status: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] content: HTTP response body data
        :param pulumi.Input[_builtins.str] content_type: HTTP Content-Type (e.g. application/json)
        :param pulumi.Input[_builtins.int] status: HTTP response status code (e.g. 429)
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "content_type", content_type)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        HTTP response body data
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> pulumi.Input[_builtins.str]:
        """
        HTTP Content-Type (e.g. application/json)
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> pulumi.Input[_builtins.int]:
        """
        HTTP response status code (e.g. 429)
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ServiceVclRequestSettingArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Unique name to refer to this Request Setting. It is important to note that changing this attribute will delete and recreate the resource
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows you to terminate request handling and immediately perform an action. When set it can be `lookup` or `pass` (Ignore the cache completely)
        """
        bypass_busy_wait: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable collapsed forwarding, so you don't wait for other objects to origin
        """
        default_host: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sets the host header
        """
        force_miss: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Force a cache miss for the request. If specified, can be `true` or `false`
        """
        force_ssl: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Forces the request to use SSL (Redirects a non-SSL request to SSL)
        """
        hash_keys: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma separated list of varnish request object fields that should be in the hash key
        """
        max_stale_age: NotRequired[pulumi.Input[_builtins.int]]
        """
        How old an object is allowed to be to serve `stale-if-error` or `stale-while-revalidate`, in seconds
        """
        request_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of already defined `condition` to determine if this request setting should be applied (should be unique across multiple instances of `request_setting`)
        """
        timer_support: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Injects the X-Timer info into the request for viewing origin fetch durations
        """
        xff: NotRequired[pulumi.Input[_builtins.str]]
        """
        X-Forwarded-For, should be `clear`, `leave`, `append`, `append_all`, or `overwrite`
        """
elif False:
    ServiceVclRequestSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclRequestSettingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 bypass_busy_wait: Optional[pulumi.Input[_builtins.bool]] = None,
                 default_host: Optional[pulumi.Input[_builtins.str]] = None,
                 force_miss: Optional[pulumi.Input[_builtins.bool]] = None,
                 force_ssl: Optional[pulumi.Input[_builtins.bool]] = None,
                 hash_keys: Optional[pulumi.Input[_builtins.str]] = None,
                 max_stale_age: Optional[pulumi.Input[_builtins.int]] = None,
                 request_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 timer_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 xff: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Unique name to refer to this Request Setting. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] action: Allows you to terminate request handling and immediately perform an action. When set it can be `lookup` or `pass` (Ignore the cache completely)
        :param pulumi.Input[_builtins.bool] bypass_busy_wait: Disable collapsed forwarding, so you don't wait for other objects to origin
        :param pulumi.Input[_builtins.str] default_host: Sets the host header
        :param pulumi.Input[_builtins.bool] force_miss: Force a cache miss for the request. If specified, can be `true` or `false`
        :param pulumi.Input[_builtins.bool] force_ssl: Forces the request to use SSL (Redirects a non-SSL request to SSL)
        :param pulumi.Input[_builtins.str] hash_keys: Comma separated list of varnish request object fields that should be in the hash key
        :param pulumi.Input[_builtins.int] max_stale_age: How old an object is allowed to be to serve `stale-if-error` or `stale-while-revalidate`, in seconds
        :param pulumi.Input[_builtins.str] request_condition: Name of already defined `condition` to determine if this request setting should be applied (should be unique across multiple instances of `request_setting`)
        :param pulumi.Input[_builtins.bool] timer_support: Injects the X-Timer info into the request for viewing origin fetch durations
        :param pulumi.Input[_builtins.str] xff: X-Forwarded-For, should be `clear`, `leave`, `append`, `append_all`, or `overwrite`
        """
        pulumi.set(__self__, "name", name)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if bypass_busy_wait is not None:
            pulumi.set(__self__, "bypass_busy_wait", bypass_busy_wait)
        if default_host is not None:
            pulumi.set(__self__, "default_host", default_host)
        if force_miss is not None:
            pulumi.set(__self__, "force_miss", force_miss)
        if force_ssl is not None:
            pulumi.set(__self__, "force_ssl", force_ssl)
        if hash_keys is not None:
            pulumi.set(__self__, "hash_keys", hash_keys)
        if max_stale_age is not None:
            pulumi.set(__self__, "max_stale_age", max_stale_age)
        if request_condition is not None:
            pulumi.set(__self__, "request_condition", request_condition)
        if timer_support is not None:
            pulumi.set(__self__, "timer_support", timer_support)
        if xff is not None:
            pulumi.set(__self__, "xff", xff)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Unique name to refer to this Request Setting. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows you to terminate request handling and immediately perform an action. When set it can be `lookup` or `pass` (Ignore the cache completely)
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="bypassBusyWait")
    def bypass_busy_wait(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable collapsed forwarding, so you don't wait for other objects to origin
        """
        return pulumi.get(self, "bypass_busy_wait")

    @bypass_busy_wait.setter
    def bypass_busy_wait(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "bypass_busy_wait", value)

    @_builtins.property
    @pulumi.getter(name="defaultHost")
    def default_host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sets the host header
        """
        return pulumi.get(self, "default_host")

    @default_host.setter
    def default_host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_host", value)

    @_builtins.property
    @pulumi.getter(name="forceMiss")
    def force_miss(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Force a cache miss for the request. If specified, can be `true` or `false`
        """
        return pulumi.get(self, "force_miss")

    @force_miss.setter
    def force_miss(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force_miss", value)

    @_builtins.property
    @pulumi.getter(name="forceSsl")
    def force_ssl(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Forces the request to use SSL (Redirects a non-SSL request to SSL)
        """
        return pulumi.get(self, "force_ssl")

    @force_ssl.setter
    def force_ssl(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "force_ssl", value)

    @_builtins.property
    @pulumi.getter(name="hashKeys")
    def hash_keys(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma separated list of varnish request object fields that should be in the hash key
        """
        return pulumi.get(self, "hash_keys")

    @hash_keys.setter
    def hash_keys(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "hash_keys", value)

    @_builtins.property
    @pulumi.getter(name="maxStaleAge")
    def max_stale_age(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        How old an object is allowed to be to serve `stale-if-error` or `stale-while-revalidate`, in seconds
        """
        return pulumi.get(self, "max_stale_age")

    @max_stale_age.setter
    def max_stale_age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_stale_age", value)

    @_builtins.property
    @pulumi.getter(name="requestCondition")
    def request_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of already defined `condition` to determine if this request setting should be applied (should be unique across multiple instances of `request_setting`)
        """
        return pulumi.get(self, "request_condition")

    @request_condition.setter
    def request_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_condition", value)

    @_builtins.property
    @pulumi.getter(name="timerSupport")
    def timer_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Injects the X-Timer info into the request for viewing origin fetch durations
        """
        return pulumi.get(self, "timer_support")

    @timer_support.setter
    def timer_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "timer_support", value)

    @_builtins.property
    @pulumi.getter
    def xff(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        X-Forwarded-For, should be `clear`, `leave`, `append`, `append_all`, or `overwrite`
        """
        return pulumi.get(self, "xff")

    @xff.setter
    def xff(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "xff", value)


if not MYPY:
    class ServiceVclResponseObjectArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A unique name to identify this Response Object. It is important to note that changing this attribute will delete and recreate the resource
        """
        cache_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of already defined `condition` to check after we have retrieved an object. If the condition passes then deliver this Request Object instead. This `condition` must be of type `CACHE`. For detailed information about Conditionals, see [Fastly's Documentation on Conditionals](https://docs.fastly.com/en/guides/using-conditions)
        """
        content: NotRequired[pulumi.Input[_builtins.str]]
        """
        The content to deliver for the response object
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MIME type of the content
        """
        request_condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of already defined `condition` to be checked during the request phase. If the condition passes then this object will be delivered. This `condition` must be of type `REQUEST`
        """
        response: NotRequired[pulumi.Input[_builtins.str]]
        """
        The HTTP Response. Default `OK`
        """
        status: NotRequired[pulumi.Input[_builtins.int]]
        """
        The HTTP Status Code. Default `200`
        """
elif False:
    ServiceVclResponseObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclResponseObjectArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 cache_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 content: Optional[pulumi.Input[_builtins.str]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 request_condition: Optional[pulumi.Input[_builtins.str]] = None,
                 response: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A unique name to identify this Response Object. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] cache_condition: Name of already defined `condition` to check after we have retrieved an object. If the condition passes then deliver this Request Object instead. This `condition` must be of type `CACHE`. For detailed information about Conditionals, see [Fastly's Documentation on Conditionals](https://docs.fastly.com/en/guides/using-conditions)
        :param pulumi.Input[_builtins.str] content: The content to deliver for the response object
        :param pulumi.Input[_builtins.str] content_type: The MIME type of the content
        :param pulumi.Input[_builtins.str] request_condition: Name of already defined `condition` to be checked during the request phase. If the condition passes then this object will be delivered. This `condition` must be of type `REQUEST`
        :param pulumi.Input[_builtins.str] response: The HTTP Response. Default `OK`
        :param pulumi.Input[_builtins.int] status: The HTTP Status Code. Default `200`
        """
        pulumi.set(__self__, "name", name)
        if cache_condition is not None:
            pulumi.set(__self__, "cache_condition", cache_condition)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if request_condition is not None:
            pulumi.set(__self__, "request_condition", request_condition)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name to identify this Response Object. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="cacheCondition")
    def cache_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of already defined `condition` to check after we have retrieved an object. If the condition passes then deliver this Request Object instead. This `condition` must be of type `CACHE`. For detailed information about Conditionals, see [Fastly's Documentation on Conditionals](https://docs.fastly.com/en/guides/using-conditions)
        """
        return pulumi.get(self, "cache_condition")

    @cache_condition.setter
    def cache_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_condition", value)

    @_builtins.property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The content to deliver for the response object
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MIME type of the content
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="requestCondition")
    def request_condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of already defined `condition` to be checked during the request phase. If the condition passes then this object will be delivered. This `condition` must be of type `REQUEST`
        """
        return pulumi.get(self, "request_condition")

    @request_condition.setter
    def request_condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_condition", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The HTTP Response. Default `OK`
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The HTTP Status Code. Default `200`
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class ServiceVclSnippetArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        The VCL code that specifies exactly what the snippet does
        """
        name: pulumi.Input[_builtins.str]
        """
        A name that is unique across "regular" and "dynamic" VCL Snippet configuration blocks. It is important to note that changing this attribute will delete and recreate the resource
        """
        type: pulumi.Input[_builtins.str]
        """
        The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hash`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`)
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority determines the ordering for multiple snippets. Lower numbers execute first. Defaults to `100`
        """
elif False:
    ServiceVclSnippetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclSnippetArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str],
                 priority: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] content: The VCL code that specifies exactly what the snippet does
        :param pulumi.Input[_builtins.str] name: A name that is unique across "regular" and "dynamic" VCL Snippet configuration blocks. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.str] type: The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hash`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`)
        :param pulumi.Input[_builtins.int] priority: Priority determines the ordering for multiple snippets. Lower numbers execute first. Defaults to `100`
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        The VCL code that specifies exactly what the snippet does
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name that is unique across "regular" and "dynamic" VCL Snippet configuration blocks. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The location in generated VCL where the snippet should be placed (can be one of `init`, `recv`, `hash`, `hit`, `miss`, `pass`, `fetch`, `error`, `deliver`, `log` or `none`)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority determines the ordering for multiple snippets. Lower numbers execute first. Defaults to `100`
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class ServiceVclVclArgsDict(TypedDict):
        content: pulumi.Input[_builtins.str]
        """
        The custom VCL code to upload
        """
        name: pulumi.Input[_builtins.str]
        """
        A unique name for this configuration block. It is important to note that changing this attribute will delete and recreate the resource
        """
        main: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If `true`, use this block as the main configuration. If `false`, use this block as an includable library. Only a single VCL block can be marked as the main block. Default is `false`
        """
elif False:
    ServiceVclVclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceVclVclArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 main: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] content: The custom VCL code to upload
        :param pulumi.Input[_builtins.str] name: A unique name for this configuration block. It is important to note that changing this attribute will delete and recreate the resource
        :param pulumi.Input[_builtins.bool] main: If `true`, use this block as the main configuration. If `false`, use this block as an includable library. Only a single VCL block can be marked as the main block. Default is `false`
        """
        pulumi.set(__self__, "content", content)
        pulumi.set(__self__, "name", name)
        if main is not None:
            pulumi.set(__self__, "main", main)

    @_builtins.property
    @pulumi.getter
    def content(self) -> pulumi.Input[_builtins.str]:
        """
        The custom VCL code to upload
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "content", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A unique name for this configuration block. It is important to note that changing this attribute will delete and recreate the resource
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def main(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If `true`, use this block as the main configuration. If `false`, use this block as an includable library. Only a single VCL block can be marked as the main block. Default is `false`
        """
        return pulumi.get(self, "main")

    @main.setter
    def main(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "main", value)


if not MYPY:
    class TlsSubscriptionManagedDnsChallengeArgsDict(TypedDict):
        record_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the DNS record to add. For example `_acme-challenge.example.com`.
        """
        record_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of DNS record to add, e.g. `A`, or `CNAME`.
        """
        record_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value to which the DNS record should point, e.g. `xxxxx.fastly-validations.com`.
        """
elif False:
    TlsSubscriptionManagedDnsChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsSubscriptionManagedDnsChallengeArgs:
    def __init__(__self__, *,
                 record_name: Optional[pulumi.Input[_builtins.str]] = None,
                 record_type: Optional[pulumi.Input[_builtins.str]] = None,
                 record_value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] record_name: The name of the DNS record to add. For example `_acme-challenge.example.com`.
        :param pulumi.Input[_builtins.str] record_type: The type of DNS record to add, e.g. `A`, or `CNAME`.
        :param pulumi.Input[_builtins.str] record_value: The value to which the DNS record should point, e.g. `xxxxx.fastly-validations.com`.
        """
        if record_name is not None:
            pulumi.set(__self__, "record_name", record_name)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if record_value is not None:
            pulumi.set(__self__, "record_value", record_value)

    @_builtins.property
    @pulumi.getter(name="recordName")
    def record_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the DNS record to add. For example `_acme-challenge.example.com`.
        """
        return pulumi.get(self, "record_name")

    @record_name.setter
    def record_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_name", value)

    @_builtins.property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of DNS record to add, e.g. `A`, or `CNAME`.
        """
        return pulumi.get(self, "record_type")

    @record_type.setter
    def record_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_type", value)

    @_builtins.property
    @pulumi.getter(name="recordValue")
    def record_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value to which the DNS record should point, e.g. `xxxxx.fastly-validations.com`.
        """
        return pulumi.get(self, "record_value")

    @record_value.setter
    def record_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_value", value)


if not MYPY:
    class TlsSubscriptionManagedHttpChallengeArgsDict(TypedDict):
        record_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the DNS record to add. For example `example.com`. Best accessed through a `for` expression to filter the relevant record.
        """
        record_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of DNS record to add, e.g. `A`, or `CNAME`.
        """
        record_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list with the value(s) to which the DNS record should point.
        """
elif False:
    TlsSubscriptionManagedHttpChallengeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TlsSubscriptionManagedHttpChallengeArgs:
    def __init__(__self__, *,
                 record_name: Optional[pulumi.Input[_builtins.str]] = None,
                 record_type: Optional[pulumi.Input[_builtins.str]] = None,
                 record_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] record_name: The name of the DNS record to add. For example `example.com`. Best accessed through a `for` expression to filter the relevant record.
        :param pulumi.Input[_builtins.str] record_type: The type of DNS record to add, e.g. `A`, or `CNAME`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] record_values: A list with the value(s) to which the DNS record should point.
        """
        if record_name is not None:
            pulumi.set(__self__, "record_name", record_name)
        if record_type is not None:
            pulumi.set(__self__, "record_type", record_type)
        if record_values is not None:
            pulumi.set(__self__, "record_values", record_values)

    @_builtins.property
    @pulumi.getter(name="recordName")
    def record_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the DNS record to add. For example `example.com`. Best accessed through a `for` expression to filter the relevant record.
        """
        return pulumi.get(self, "record_name")

    @record_name.setter
    def record_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_name", value)

    @_builtins.property
    @pulumi.getter(name="recordType")
    def record_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of DNS record to add, e.g. `A`, or `CNAME`.
        """
        return pulumi.get(self, "record_type")

    @record_type.setter
    def record_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_type", value)

    @_builtins.property
    @pulumi.getter(name="recordValues")
    def record_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list with the value(s) to which the DNS record should point.
        """
        return pulumi.get(self, "record_values")

    @record_values.setter
    def record_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "record_values", value)


